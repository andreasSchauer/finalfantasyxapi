// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package database

import (
	"database/sql"
	"database/sql/driver"
	"fmt"
)

type AaActivationCondition string

const (
	AaActivationConditionAlways        AaActivationCondition = "always"
	AaActivationConditionActiveParty   AaActivationCondition = "active-party"
	AaActivationConditionHpCritical    AaActivationCondition = "hp-critical"
	AaActivationConditionOutsideBattle AaActivationCondition = "outside-battle"
)

func (e *AaActivationCondition) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AaActivationCondition(s)
	case string:
		*e = AaActivationCondition(s)
	default:
		return fmt.Errorf("unsupported scan type for AaActivationCondition: %T", src)
	}
	return nil
}

type NullAaActivationCondition struct {
	AaActivationCondition AaActivationCondition
	Valid                 bool // Valid is true if AaActivationCondition is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAaActivationCondition) Scan(value interface{}) error {
	if value == nil {
		ns.AaActivationCondition, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AaActivationCondition.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAaActivationCondition) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AaActivationCondition), nil
}

type AbilityType string

const (
	AbilityTypePlayerAbility    AbilityType = "player-ability"
	AbilityTypeEnemyAbility     AbilityType = "enemy-ability"
	AbilityTypeOverdriveAbility AbilityType = "overdrive-ability"
	AbilityTypeTriggerCommand   AbilityType = "trigger-command"
	AbilityTypeItem             AbilityType = "item"
)

func (e *AbilityType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AbilityType(s)
	case string:
		*e = AbilityType(s)
	default:
		return fmt.Errorf("unsupported scan type for AbilityType: %T", src)
	}
	return nil
}

type NullAbilityType struct {
	AbilityType AbilityType
	Valid       bool // Valid is true if AbilityType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAbilityType) Scan(value interface{}) error {
	if value == nil {
		ns.AbilityType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AbilityType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAbilityType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AbilityType), nil
}

type AccuracySource string

const (
	AccuracySourceAccuracy AccuracySource = "accuracy"
	AccuracySourceRate     AccuracySource = "rate"
)

func (e *AccuracySource) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AccuracySource(s)
	case string:
		*e = AccuracySource(s)
	default:
		return fmt.Errorf("unsupported scan type for AccuracySource: %T", src)
	}
	return nil
}

type NullAccuracySource struct {
	AccuracySource AccuracySource
	Valid          bool // Valid is true if AccuracySource is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAccuracySource) Scan(value interface{}) error {
	if value == nil {
		ns.AccuracySource, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AccuracySource.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAccuracySource) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AccuracySource), nil
}

type ArmorType string

const (
	ArmorTypeShield       ArmorType = "shield"
	ArmorTypeRing         ArmorType = "ring"
	ArmorTypeArmguard     ArmorType = "armguard"
	ArmorTypeBangle       ArmorType = "bangle"
	ArmorTypeArmlet       ArmorType = "armlet"
	ArmorTypeBracer       ArmorType = "bracer"
	ArmorTypeTarge        ArmorType = "targe"
	ArmorTypeSeymourArmor ArmorType = "seymour-armor"
)

func (e *ArmorType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ArmorType(s)
	case string:
		*e = ArmorType(s)
	default:
		return fmt.Errorf("unsupported scan type for ArmorType: %T", src)
	}
	return nil
}

type NullArmorType struct {
	ArmorType ArmorType
	Valid     bool // Valid is true if ArmorType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullArmorType) Scan(value interface{}) error {
	if value == nil {
		ns.ArmorType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ArmorType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullArmorType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ArmorType), nil
}

type AutoAbilityCategory string

const (
	AutoAbilityCategoryApOverdrive         AutoAbilityCategory = "ap-overdrive"
	AutoAbilityCategoryAutoCure            AutoAbilityCategory = "auto-cure"
	AutoAbilityCategoryAutoStatus          AutoAbilityCategory = "auto-status"
	AutoAbilityCategoryBreakLimit          AutoAbilityCategory = "break-limit"
	AutoAbilityCategoryCounter             AutoAbilityCategory = "counter"
	AutoAbilityCategoryElementalProtection AutoAbilityCategory = "elemental-protection"
	AutoAbilityCategoryElementalStrike     AutoAbilityCategory = "elemental-strike"
	AutoAbilityCategoryOther               AutoAbilityCategory = "other"
	AutoAbilityCategorySosStatus           AutoAbilityCategory = "sos-status"
	AutoAbilityCategoryStatX               AutoAbilityCategory = "stat-+x%"
	AutoAbilityCategoryStatusInfliction    AutoAbilityCategory = "status-infliction"
	AutoAbilityCategoryStatusProtection    AutoAbilityCategory = "status-protection"
)

func (e *AutoAbilityCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AutoAbilityCategory(s)
	case string:
		*e = AutoAbilityCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for AutoAbilityCategory: %T", src)
	}
	return nil
}

type NullAutoAbilityCategory struct {
	AutoAbilityCategory AutoAbilityCategory
	Valid               bool // Valid is true if AutoAbilityCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAutoAbilityCategory) Scan(value interface{}) error {
	if value == nil {
		ns.AutoAbilityCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AutoAbilityCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAutoAbilityCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AutoAbilityCategory), nil
}

type BlitzballItemSlot string

const (
	BlitzballItemSlot1st       BlitzballItemSlot = "1st"
	BlitzballItemSlot2nd       BlitzballItemSlot = "2nd"
	BlitzballItemSlot3rd       BlitzballItemSlot = "3rd"
	BlitzballItemSlotTopScorer BlitzballItemSlot = "top-scorer"
)

func (e *BlitzballItemSlot) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BlitzballItemSlot(s)
	case string:
		*e = BlitzballItemSlot(s)
	default:
		return fmt.Errorf("unsupported scan type for BlitzballItemSlot: %T", src)
	}
	return nil
}

type NullBlitzballItemSlot struct {
	BlitzballItemSlot BlitzballItemSlot
	Valid             bool // Valid is true if BlitzballItemSlot is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBlitzballItemSlot) Scan(value interface{}) error {
	if value == nil {
		ns.BlitzballItemSlot, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BlitzballItemSlot.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBlitzballItemSlot) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BlitzballItemSlot), nil
}

type BlitzballTournamentCategory string

const (
	BlitzballTournamentCategoryLeague     BlitzballTournamentCategory = "league"
	BlitzballTournamentCategoryTournament BlitzballTournamentCategory = "tournament"
)

func (e *BlitzballTournamentCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BlitzballTournamentCategory(s)
	case string:
		*e = BlitzballTournamentCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for BlitzballTournamentCategory: %T", src)
	}
	return nil
}

type NullBlitzballTournamentCategory struct {
	BlitzballTournamentCategory BlitzballTournamentCategory
	Valid                       bool // Valid is true if BlitzballTournamentCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBlitzballTournamentCategory) Scan(value interface{}) error {
	if value == nil {
		ns.BlitzballTournamentCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BlitzballTournamentCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBlitzballTournamentCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BlitzballTournamentCategory), nil
}

type CalculationType string

const (
	CalculationTypeAddedPercentage CalculationType = "added-percentage"
	CalculationTypeAddedValue      CalculationType = "added-value"
	CalculationTypeMultiply        CalculationType = "multiply"
	CalculationTypeMultiplyHighest CalculationType = "multiply-highest"
	CalculationTypeSetValue        CalculationType = "set-value"
)

func (e *CalculationType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CalculationType(s)
	case string:
		*e = CalculationType(s)
	default:
		return fmt.Errorf("unsupported scan type for CalculationType: %T", src)
	}
	return nil
}

type NullCalculationType struct {
	CalculationType CalculationType
	Valid           bool // Valid is true if CalculationType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCalculationType) Scan(value interface{}) error {
	if value == nil {
		ns.CalculationType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CalculationType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCalculationType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CalculationType), nil
}

type CelestialFormula string

const (
	CelestialFormulaHpHigh CelestialFormula = "hp-high"
	CelestialFormulaHpLow  CelestialFormula = "hp-low"
	CelestialFormulaMpHigh CelestialFormula = "mp-high"
)

func (e *CelestialFormula) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CelestialFormula(s)
	case string:
		*e = CelestialFormula(s)
	default:
		return fmt.Errorf("unsupported scan type for CelestialFormula: %T", src)
	}
	return nil
}

type NullCelestialFormula struct {
	CelestialFormula CelestialFormula
	Valid            bool // Valid is true if CelestialFormula is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCelestialFormula) Scan(value interface{}) error {
	if value == nil {
		ns.CelestialFormula, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CelestialFormula.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCelestialFormula) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CelestialFormula), nil
}

type CounterType string

const (
	CounterTypePhysical CounterType = "physical"
	CounterTypeMagical  CounterType = "magical"
)

func (e *CounterType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CounterType(s)
	case string:
		*e = CounterType(s)
	default:
		return fmt.Errorf("unsupported scan type for CounterType: %T", src)
	}
	return nil
}

type NullCounterType struct {
	CounterType CounterType
	Valid       bool // Valid is true if CounterType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCounterType) Scan(value interface{}) error {
	if value == nil {
		ns.CounterType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CounterType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCounterType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CounterType), nil
}

type CreationsUnlockedCategory string

const (
	CreationsUnlockedCategoryArea    CreationsUnlockedCategory = "area"
	CreationsUnlockedCategorySpecies CreationsUnlockedCategory = "species"
)

func (e *CreationsUnlockedCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CreationsUnlockedCategory(s)
	case string:
		*e = CreationsUnlockedCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for CreationsUnlockedCategory: %T", src)
	}
	return nil
}

type NullCreationsUnlockedCategory struct {
	CreationsUnlockedCategory CreationsUnlockedCategory
	Valid                     bool // Valid is true if CreationsUnlockedCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCreationsUnlockedCategory) Scan(value interface{}) error {
	if value == nil {
		ns.CreationsUnlockedCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CreationsUnlockedCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCreationsUnlockedCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CreationsUnlockedCategory), nil
}

type CtbIconType string

const (
	CtbIconTypeMonster      CtbIconType = "monster"
	CtbIconTypeBoss         CtbIconType = "boss"
	CtbIconTypeBossNumbered CtbIconType = "boss-numbered"
	CtbIconTypeSummon       CtbIconType = "summon"
)

func (e *CtbIconType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CtbIconType(s)
	case string:
		*e = CtbIconType(s)
	default:
		return fmt.Errorf("unsupported scan type for CtbIconType: %T", src)
	}
	return nil
}

type NullCtbIconType struct {
	CtbIconType CtbIconType
	Valid       bool // Valid is true if CtbIconType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCtbIconType) Scan(value interface{}) error {
	if value == nil {
		ns.CtbIconType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CtbIconType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCtbIconType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CtbIconType), nil
}

type DurationType string

const (
	DurationTypeBlocks    DurationType = "blocks"
	DurationTypeEndless   DurationType = "endless"
	DurationTypeInstant   DurationType = "instant"
	DurationTypeTurns     DurationType = "turns"
	DurationTypeUserTurns DurationType = "user-turns"
)

func (e *DurationType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DurationType(s)
	case string:
		*e = DurationType(s)
	default:
		return fmt.Errorf("unsupported scan type for DurationType: %T", src)
	}
	return nil
}

type NullDurationType struct {
	DurationType DurationType
	Valid        bool // Valid is true if DurationType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDurationType) Scan(value interface{}) error {
	if value == nil {
		ns.DurationType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DurationType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDurationType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DurationType), nil
}

type EquipClass string

const (
	EquipClassStandard        EquipClass = "standard"
	EquipClassUnique          EquipClass = "unique"
	EquipClassCelestialWeapon EquipClass = "celestial-weapon"
)

func (e *EquipClass) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EquipClass(s)
	case string:
		*e = EquipClass(s)
	default:
		return fmt.Errorf("unsupported scan type for EquipClass: %T", src)
	}
	return nil
}

type NullEquipClass struct {
	EquipClass EquipClass
	Valid      bool // Valid is true if EquipClass is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEquipClass) Scan(value interface{}) error {
	if value == nil {
		ns.EquipClass, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EquipClass.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEquipClass) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EquipClass), nil
}

type EquipType string

const (
	EquipTypeWeapon EquipType = "weapon"
	EquipTypeArmor  EquipType = "armor"
)

func (e *EquipType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EquipType(s)
	case string:
		*e = EquipType(s)
	default:
		return fmt.Errorf("unsupported scan type for EquipType: %T", src)
	}
	return nil
}

type NullEquipType struct {
	EquipType EquipType
	Valid     bool // Valid is true if EquipType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEquipType) Scan(value interface{}) error {
	if value == nil {
		ns.EquipType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EquipType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEquipType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EquipType), nil
}

type ItemCategory string

const (
	ItemCategoryDistiller ItemCategory = "distiller"
	ItemCategoryHealing   ItemCategory = "healing"
	ItemCategoryOffensive ItemCategory = "offensive"
	ItemCategoryOther     ItemCategory = "other"
	ItemCategorySphere    ItemCategory = "sphere"
	ItemCategorySupport   ItemCategory = "support"
)

func (e *ItemCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ItemCategory(s)
	case string:
		*e = ItemCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for ItemCategory: %T", src)
	}
	return nil
}

type NullItemCategory struct {
	ItemCategory ItemCategory
	Valid        bool // Valid is true if ItemCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullItemCategory) Scan(value interface{}) error {
	if value == nil {
		ns.ItemCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ItemCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullItemCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ItemCategory), nil
}

type ItemType string

const (
	ItemTypeItem    ItemType = "item"
	ItemTypeKeyItem ItemType = "key-item"
)

func (e *ItemType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ItemType(s)
	case string:
		*e = ItemType(s)
	default:
		return fmt.Errorf("unsupported scan type for ItemType: %T", src)
	}
	return nil
}

type NullItemType struct {
	ItemType ItemType
	Valid    bool // Valid is true if ItemType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullItemType) Scan(value interface{}) error {
	if value == nil {
		ns.ItemType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ItemType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullItemType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ItemType), nil
}

type ItemUsability string

const (
	ItemUsabilityAlways        ItemUsability = "always"
	ItemUsabilityInBattle      ItemUsability = "in-battle"
	ItemUsabilityOutsideBattle ItemUsability = "outside-battle"
)

func (e *ItemUsability) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ItemUsability(s)
	case string:
		*e = ItemUsability(s)
	default:
		return fmt.Errorf("unsupported scan type for ItemUsability: %T", src)
	}
	return nil
}

type NullItemUsability struct {
	ItemUsability ItemUsability
	Valid         bool // Valid is true if ItemUsability is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullItemUsability) Scan(value interface{}) error {
	if value == nil {
		ns.ItemUsability, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ItemUsability.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullItemUsability) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ItemUsability), nil
}

type KeyItemBase string

const (
	KeyItemBaseSun     KeyItemBase = "sun"
	KeyItemBaseMoon    KeyItemBase = "moon"
	KeyItemBaseJupiter KeyItemBase = "jupiter"
	KeyItemBaseVenus   KeyItemBase = "venus"
	KeyItemBaseSaturn  KeyItemBase = "saturn"
	KeyItemBaseMars    KeyItemBase = "mars"
	KeyItemBaseMercury KeyItemBase = "mercury"
)

func (e *KeyItemBase) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = KeyItemBase(s)
	case string:
		*e = KeyItemBase(s)
	default:
		return fmt.Errorf("unsupported scan type for KeyItemBase: %T", src)
	}
	return nil
}

type NullKeyItemBase struct {
	KeyItemBase KeyItemBase
	Valid       bool // Valid is true if KeyItemBase is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullKeyItemBase) Scan(value interface{}) error {
	if value == nil {
		ns.KeyItemBase, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.KeyItemBase.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullKeyItemBase) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.KeyItemBase), nil
}

type KeyItemCategory string

const (
	KeyItemCategoryCelestial   KeyItemCategory = "celestial"
	KeyItemCategoryJechtSphere KeyItemCategory = "jecht-sphere"
	KeyItemCategoryOther       KeyItemCategory = "other"
	KeyItemCategoryPrimer      KeyItemCategory = "primer"
	KeyItemCategoryStory       KeyItemCategory = "story"
)

func (e *KeyItemCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = KeyItemCategory(s)
	case string:
		*e = KeyItemCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for KeyItemCategory: %T", src)
	}
	return nil
}

type NullKeyItemCategory struct {
	KeyItemCategory KeyItemCategory
	Valid           bool // Valid is true if KeyItemCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullKeyItemCategory) Scan(value interface{}) error {
	if value == nil {
		ns.KeyItemCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.KeyItemCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullKeyItemCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.KeyItemCategory), nil
}

type LootType string

const (
	LootTypeItem      LootType = "item"
	LootTypeEquipment LootType = "equipment"
	LootTypeGil       LootType = "gil"
)

func (e *LootType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LootType(s)
	case string:
		*e = LootType(s)
	default:
		return fmt.Errorf("unsupported scan type for LootType: %T", src)
	}
	return nil
}

type NullLootType struct {
	LootType LootType
	Valid    bool // Valid is true if LootType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLootType) Scan(value interface{}) error {
	if value == nil {
		ns.LootType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LootType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLootType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LootType), nil
}

type MaCreationArea string

const (
	MaCreationAreaBesaid                 MaCreationArea = "besaid"
	MaCreationAreaKilika                 MaCreationArea = "kilika"
	MaCreationAreaMiihenHighroad         MaCreationArea = "mi'ihen-highroad"
	MaCreationAreaMushroomRockRoad       MaCreationArea = "mushroom-rock-road"
	MaCreationAreaDjose                  MaCreationArea = "djose"
	MaCreationAreaThunderPlains          MaCreationArea = "thunder-plains"
	MaCreationAreaMacalania              MaCreationArea = "macalania"
	MaCreationAreaBikanel                MaCreationArea = "bikanel"
	MaCreationAreaCalmLands              MaCreationArea = "calm-lands"
	MaCreationAreaCavernOfTheStolenFayth MaCreationArea = "cavern-of-the-stolen-fayth"
	MaCreationAreaMountGagazet           MaCreationArea = "mount-gagazet"
	MaCreationAreaSin                    MaCreationArea = "sin"
	MaCreationAreaOmegaRuins             MaCreationArea = "omega-ruins"
)

func (e *MaCreationArea) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MaCreationArea(s)
	case string:
		*e = MaCreationArea(s)
	default:
		return fmt.Errorf("unsupported scan type for MaCreationArea: %T", src)
	}
	return nil
}

type NullMaCreationArea struct {
	MaCreationArea MaCreationArea
	Valid          bool // Valid is true if MaCreationArea is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMaCreationArea) Scan(value interface{}) error {
	if value == nil {
		ns.MaCreationArea, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MaCreationArea.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMaCreationArea) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MaCreationArea), nil
}

type MaCreationCategory string

const (
	MaCreationCategoryArea     MaCreationCategory = "area"
	MaCreationCategorySpecies  MaCreationCategory = "species"
	MaCreationCategoryOriginal MaCreationCategory = "original"
)

func (e *MaCreationCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MaCreationCategory(s)
	case string:
		*e = MaCreationCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for MaCreationCategory: %T", src)
	}
	return nil
}

type NullMaCreationCategory struct {
	MaCreationCategory MaCreationCategory
	Valid              bool // Valid is true if MaCreationCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMaCreationCategory) Scan(value interface{}) error {
	if value == nil {
		ns.MaCreationCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MaCreationCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMaCreationCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MaCreationCategory), nil
}

type MaCreationSpecies string

const (
	MaCreationSpeciesBird      MaCreationSpecies = "bird"
	MaCreationSpeciesBomb      MaCreationSpecies = "bomb"
	MaCreationSpeciesDrake     MaCreationSpecies = "drake"
	MaCreationSpeciesElemental MaCreationSpecies = "elemental"
	MaCreationSpeciesEvilEye   MaCreationSpecies = "evil-eye"
	MaCreationSpeciesFlan      MaCreationSpecies = "flan"
	MaCreationSpeciesFungus    MaCreationSpecies = "fungus"
	MaCreationSpeciesHelm      MaCreationSpecies = "helm"
	MaCreationSpeciesImp       MaCreationSpecies = "imp"
	MaCreationSpeciesIronGiant MaCreationSpecies = "iron-giant"
	MaCreationSpeciesLupine    MaCreationSpecies = "lupine"
	MaCreationSpeciesReptile   MaCreationSpecies = "reptile"
	MaCreationSpeciesRuminant  MaCreationSpecies = "ruminant"
	MaCreationSpeciesWasp      MaCreationSpecies = "wasp"
)

func (e *MaCreationSpecies) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MaCreationSpecies(s)
	case string:
		*e = MaCreationSpecies(s)
	default:
		return fmt.Errorf("unsupported scan type for MaCreationSpecies: %T", src)
	}
	return nil
}

type NullMaCreationSpecies struct {
	MaCreationSpecies MaCreationSpecies
	Valid             bool // Valid is true if MaCreationSpecies is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMaCreationSpecies) Scan(value interface{}) error {
	if value == nil {
		ns.MaCreationSpecies, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MaCreationSpecies.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMaCreationSpecies) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MaCreationSpecies), nil
}

type MixCategory string

const (
	MixCategory9999Damage         MixCategory = "9999-damage"
	MixCategoryCriticalHits       MixCategory = "critical-hits"
	MixCategoryFireElemental      MixCategory = "fire-elemental"
	MixCategoryGravityBased       MixCategory = "gravity-based"
	MixCategoryHpMp               MixCategory = "hp-mp"
	MixCategoryIceElemental       MixCategory = "ice-elemental"
	MixCategoryLightningElemental MixCategory = "lightning-elemental"
	MixCategoryNonElemental       MixCategory = "non-elemental"
	MixCategoryOverdriveSpeed     MixCategory = "overdrive-speed"
	MixCategoryPositiveStatus     MixCategory = "positive-status"
	MixCategoryRecovery           MixCategory = "recovery"
	MixCategoryWaterElemental     MixCategory = "water-elemental"
)

func (e *MixCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MixCategory(s)
	case string:
		*e = MixCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for MixCategory: %T", src)
	}
	return nil
}

type NullMixCategory struct {
	MixCategory MixCategory
	Valid       bool // Valid is true if MixCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMixCategory) Scan(value interface{}) error {
	if value == nil {
		ns.MixCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MixCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMixCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MixCategory), nil
}

type ModifierType string

const (
	ModifierTypeBattleDependent ModifierType = "battle-dependent"
	ModifierTypeFactor          ModifierType = "factor"
	ModifierTypeFixedValue      ModifierType = "fixed-value"
	ModifierTypePercentage      ModifierType = "percentage"
)

func (e *ModifierType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ModifierType(s)
	case string:
		*e = ModifierType(s)
	default:
		return fmt.Errorf("unsupported scan type for ModifierType: %T", src)
	}
	return nil
}

type NullModifierType struct {
	ModifierType ModifierType
	Valid        bool // Valid is true if ModifierType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullModifierType) Scan(value interface{}) error {
	if value == nil {
		ns.ModifierType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ModifierType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullModifierType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ModifierType), nil
}

type MonsterSpecies string

const (
	MonsterSpeciesAdamantoise  MonsterSpecies = "adamantoise"
	MonsterSpeciesAeon         MonsterSpecies = "aeon"
	MonsterSpeciesArmor        MonsterSpecies = "armor"
	MonsterSpeciesBasilisk     MonsterSpecies = "basilisk"
	MonsterSpeciesBlade        MonsterSpecies = "blade"
	MonsterSpeciesBehemoth     MonsterSpecies = "behemoth"
	MonsterSpeciesBird         MonsterSpecies = "bird"
	MonsterSpeciesBomb         MonsterSpecies = "bomb"
	MonsterSpeciesCactuar      MonsterSpecies = "cactuar"
	MonsterSpeciesCephalopod   MonsterSpecies = "cephalopod"
	MonsterSpeciesChest        MonsterSpecies = "chest"
	MonsterSpeciesChimera      MonsterSpecies = "chimera"
	MonsterSpeciesCoeurl       MonsterSpecies = "coeurl"
	MonsterSpeciesDefender     MonsterSpecies = "defender"
	MonsterSpeciesDinofish     MonsterSpecies = "dinofish"
	MonsterSpeciesDoomstone    MonsterSpecies = "doomstone"
	MonsterSpeciesDrake        MonsterSpecies = "drake"
	MonsterSpeciesEater        MonsterSpecies = "eater"
	MonsterSpeciesElemental    MonsterSpecies = "elemental"
	MonsterSpeciesEvilEye      MonsterSpecies = "evil-eye"
	MonsterSpeciesFlan         MonsterSpecies = "flan"
	MonsterSpeciesFungus       MonsterSpecies = "fungus"
	MonsterSpeciesGel          MonsterSpecies = "gel"
	MonsterSpeciesGeo          MonsterSpecies = "geo"
	MonsterSpeciesHaizhe       MonsterSpecies = "haizhe"
	MonsterSpeciesHelm         MonsterSpecies = "helm"
	MonsterSpeciesHermit       MonsterSpecies = "hermit"
	MonsterSpeciesHumanoid     MonsterSpecies = "humanoid"
	MonsterSpeciesImp          MonsterSpecies = "imp"
	MonsterSpeciesIronGiant    MonsterSpecies = "iron-giant"
	MonsterSpeciesLarva        MonsterSpecies = "larva"
	MonsterSpeciesLupine       MonsterSpecies = "lupine"
	MonsterSpeciesMachina      MonsterSpecies = "machina"
	MonsterSpeciesMalboro      MonsterSpecies = "malboro"
	MonsterSpeciesMech         MonsterSpecies = "mech"
	MonsterSpeciesMimic        MonsterSpecies = "mimic"
	MonsterSpeciesOchu         MonsterSpecies = "ochu"
	MonsterSpeciesOgre         MonsterSpecies = "ogre"
	MonsterSpeciesPhantom      MonsterSpecies = "phantom"
	MonsterSpeciesPiranha      MonsterSpecies = "piranha"
	MonsterSpeciesPlant        MonsterSpecies = "plant"
	MonsterSpeciesReptile      MonsterSpecies = "reptile"
	MonsterSpeciesRoc          MonsterSpecies = "roc"
	MonsterSpeciesRuminant     MonsterSpecies = "ruminant"
	MonsterSpeciesSacredBeast  MonsterSpecies = "sacred-beast"
	MonsterSpeciesSahagin      MonsterSpecies = "sahagin"
	MonsterSpeciesSin          MonsterSpecies = "sin"
	MonsterSpeciesSinspawn     MonsterSpecies = "sinspawn"
	MonsterSpeciesSpellspinner MonsterSpecies = "spellspinner"
	MonsterSpeciesSpiritBeast  MonsterSpecies = "spirit-beast"
	MonsterSpeciesTonberry     MonsterSpecies = "tonberry"
	MonsterSpeciesUnspecified  MonsterSpecies = "unspecified"
	MonsterSpeciesWasp         MonsterSpecies = "wasp"
	MonsterSpeciesWeapon       MonsterSpecies = "weapon"
	MonsterSpeciesWorm         MonsterSpecies = "worm"
	MonsterSpeciesWyrm         MonsterSpecies = "wyrm"
)

func (e *MonsterSpecies) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MonsterSpecies(s)
	case string:
		*e = MonsterSpecies(s)
	default:
		return fmt.Errorf("unsupported scan type for MonsterSpecies: %T", src)
	}
	return nil
}

type NullMonsterSpecies struct {
	MonsterSpecies MonsterSpecies
	Valid          bool // Valid is true if MonsterSpecies is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMonsterSpecies) Scan(value interface{}) error {
	if value == nil {
		ns.MonsterSpecies, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MonsterSpecies.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMonsterSpecies) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MonsterSpecies), nil
}

type MusicUseCase string

const (
	MusicUseCaseBlitzballGame          MusicUseCase = "blitzball-game"
	MusicUseCaseBlitzballMenu          MusicUseCase = "blitzball-menu"
	MusicUseCaseBossBattleDefault      MusicUseCase = "boss-battle-default"
	MusicUseCaseChocobo                MusicUseCase = "chocobo"
	MusicUseCaseGameOver               MusicUseCase = "game-over"
	MusicUseCaseMainMenu               MusicUseCase = "main-menu"
	MusicUseCaseRandomEncounterDefault MusicUseCase = "random-encounter-default"
	MusicUseCaseVictory                MusicUseCase = "victory"
)

func (e *MusicUseCase) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MusicUseCase(s)
	case string:
		*e = MusicUseCase(s)
	default:
		return fmt.Errorf("unsupported scan type for MusicUseCase: %T", src)
	}
	return nil
}

type NullMusicUseCase struct {
	MusicUseCase MusicUseCase
	Valid        bool // Valid is true if MusicUseCase is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMusicUseCase) Scan(value interface{}) error {
	if value == nil {
		ns.MusicUseCase, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MusicUseCase.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMusicUseCase) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MusicUseCase), nil
}

type NullifyArmored string

const (
	NullifyArmoredTarget NullifyArmored = "target"
	NullifyArmoredBearer NullifyArmored = "bearer"
)

func (e *NullifyArmored) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = NullifyArmored(s)
	case string:
		*e = NullifyArmored(s)
	default:
		return fmt.Errorf("unsupported scan type for NullifyArmored: %T", src)
	}
	return nil
}

type NullNullifyArmored struct {
	NullifyArmored NullifyArmored
	Valid          bool // Valid is true if NullifyArmored is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullNullifyArmored) Scan(value interface{}) error {
	if value == nil {
		ns.NullifyArmored, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.NullifyArmored.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullNullifyArmored) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.NullifyArmored), nil
}

type OverdriveType string

const (
	OverdriveTypeFormula   OverdriveType = "formula"
	OverdriveTypePerAction OverdriveType = "per-action"
)

func (e *OverdriveType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = OverdriveType(s)
	case string:
		*e = OverdriveType(s)
	default:
		return fmt.Errorf("unsupported scan type for OverdriveType: %T", src)
	}
	return nil
}

type NullOverdriveType struct {
	OverdriveType OverdriveType
	Valid         bool // Valid is true if OverdriveType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOverdriveType) Scan(value interface{}) error {
	if value == nil {
		ns.OverdriveType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.OverdriveType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullOverdriveType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.OverdriveType), nil
}

type QuestType string

const (
	QuestTypeSidequest QuestType = "sidequest"
	QuestTypeSubquest  QuestType = "subquest"
)

func (e *QuestType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = QuestType(s)
	case string:
		*e = QuestType(s)
	default:
		return fmt.Errorf("unsupported scan type for QuestType: %T", src)
	}
	return nil
}

type NullQuestType struct {
	QuestType QuestType
	Valid     bool // Valid is true if QuestType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullQuestType) Scan(value interface{}) error {
	if value == nil {
		ns.QuestType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.QuestType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullQuestType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.QuestType), nil
}

type ShopCategory string

const (
	ShopCategoryStandard     ShopCategory = "standard"
	ShopCategoryOaka         ShopCategory = "oaka"
	ShopCategoryTravelAgency ShopCategory = "travel-agency"
	ShopCategoryWantz        ShopCategory = "wantz"
)

func (e *ShopCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ShopCategory(s)
	case string:
		*e = ShopCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for ShopCategory: %T", src)
	}
	return nil
}

type NullShopCategory struct {
	ShopCategory ShopCategory
	Valid        bool // Valid is true if ShopCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullShopCategory) Scan(value interface{}) error {
	if value == nil {
		ns.ShopCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ShopCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullShopCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ShopCategory), nil
}

type TargetType string

const (
	TargetTypeSelf            TargetType = "self"
	TargetTypeSingleCharacter TargetType = "single-character"
	TargetTypeSingleEnemy     TargetType = "single-enemy"
	TargetTypeSingleTarget    TargetType = "single-target"
	TargetTypeRandomEnemy     TargetType = "random-enemy"
	TargetTypeAllCharacters   TargetType = "all-characters"
	TargetTypeAllEnemies      TargetType = "all-enemies"
	TargetTypeTargetParty     TargetType = "target-party"
	TargetTypeEveryone        TargetType = "everyone"
)

func (e *TargetType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TargetType(s)
	case string:
		*e = TargetType(s)
	default:
		return fmt.Errorf("unsupported scan type for TargetType: %T", src)
	}
	return nil
}

type NullTargetType struct {
	TargetType TargetType
	Valid      bool // Valid is true if TargetType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTargetType) Scan(value interface{}) error {
	if value == nil {
		ns.TargetType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TargetType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTargetType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TargetType), nil
}

type TopmenuType string

const (
	TopmenuTypeMain   TopmenuType = "main"
	TopmenuTypeLeft   TopmenuType = "left"
	TopmenuTypeRight  TopmenuType = "right"
	TopmenuTypeHidden TopmenuType = "hidden"
)

func (e *TopmenuType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TopmenuType(s)
	case string:
		*e = TopmenuType(s)
	default:
		return fmt.Errorf("unsupported scan type for TopmenuType: %T", src)
	}
	return nil
}

type NullTopmenuType struct {
	TopmenuType TopmenuType
	Valid       bool // Valid is true if TopmenuType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTopmenuType) Scan(value interface{}) error {
	if value == nil {
		ns.TopmenuType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TopmenuType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTopmenuType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TopmenuType), nil
}

type TreasureType string

const (
	TreasureTypeChest  TreasureType = "chest"
	TreasureTypeGift   TreasureType = "gift"
	TreasureTypeObject TreasureType = "object"
)

func (e *TreasureType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TreasureType(s)
	case string:
		*e = TreasureType(s)
	default:
		return fmt.Errorf("unsupported scan type for TreasureType: %T", src)
	}
	return nil
}

type NullTreasureType struct {
	TreasureType TreasureType
	Valid        bool // Valid is true if TreasureType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTreasureType) Scan(value interface{}) error {
	if value == nil {
		ns.TreasureType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TreasureType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTreasureType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TreasureType), nil
}

type UnitType string

const (
	UnitTypeAeon      UnitType = "aeon"
	UnitTypeCharacter UnitType = "character"
)

func (e *UnitType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UnitType(s)
	case string:
		*e = UnitType(s)
	default:
		return fmt.Errorf("unsupported scan type for UnitType: %T", src)
	}
	return nil
}

type NullUnitType struct {
	UnitType UnitType
	Valid    bool // Valid is true if UnitType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUnitType) Scan(value interface{}) error {
	if value == nil {
		ns.UnitType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UnitType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUnitType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UnitType), nil
}

type WeaponType string

const (
	WeaponTypeSword        WeaponType = "sword"
	WeaponTypeStaff        WeaponType = "staff"
	WeaponTypeBlitzball    WeaponType = "blitzball"
	WeaponTypeDoll         WeaponType = "doll"
	WeaponTypeSpear        WeaponType = "spear"
	WeaponTypeBlade        WeaponType = "blade"
	WeaponTypeClaw         WeaponType = "claw"
	WeaponTypeSeymourStaff WeaponType = "seymour-staff"
)

func (e *WeaponType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WeaponType(s)
	case string:
		*e = WeaponType(s)
	default:
		return fmt.Errorf("unsupported scan type for WeaponType: %T", src)
	}
	return nil
}

type NullWeaponType struct {
	WeaponType WeaponType
	Valid      bool // Valid is true if WeaponType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWeaponType) Scan(value interface{}) error {
	if value == nil {
		ns.WeaponType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WeaponType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWeaponType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WeaponType), nil
}

type Ability struct {
	ID            int32
	DataHash      string
	Name          string
	Version       sql.NullInt32
	Specification sql.NullString
	AttributesID  sql.NullInt32
	Type          AbilityType
}

type AbilityAttribute struct {
	ID               int32
	DataHash         string
	Rank             sql.NullInt32
	AppearsInHelpBar bool
	CanCopycat       bool
}

type Aeon struct {
	ID                    int32
	DataHash              string
	UnitID                int32
	UnlockCondition       string
	IsOptional            bool
	BattlesToRegenerate   int32
	PhysAtkDamageConstant sql.NullInt32
	PhysAtkRange          interface{}
	PhysAtkShatterRate    interface{}
	PhysAtkAccSource      NullAccuracySource
	PhysAtkHitChance      interface{}
	PhysAtkAccModifier    sql.NullFloat64
}

type AeonCommand struct {
	ID          int32
	DataHash    string
	Name        string
	Description string
	Effect      string
	Topmenu     TopmenuType
	Cursor      NullTargetType
}

type Affinity struct {
	ID           int32
	DataHash     string
	Name         string
	DamageFactor sql.NullFloat64
}

type AgilitySubtier struct {
	ID                int32
	DataHash          string
	AgilityTierID     int32
	SubtierMinAgility interface{}
	SubtierMaxAgility interface{}
	CharacterMinIcv   sql.NullInt32
}

type AgilityTier struct {
	ID              int32
	DataHash        string
	MinAgility      interface{}
	MaxAgility      interface{}
	TickSpeed       int32
	MonsterMinIcv   sql.NullInt32
	MonsterMaxIcv   sql.NullInt32
	CharacterMaxIcv sql.NullInt32
}

type Area struct {
	ID                   int32
	DataHash             string
	SubLocationID        int32
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	StoryOnly            bool
	HasSaveSphere        bool
	AirshipDropOff       bool
	HasCompilationSphere bool
	CanRideChocobo       bool
}

type AutoAbility struct {
	ID                   int32
	DataHash             string
	Name                 string
	Description          sql.NullString
	Effect               string
	Type                 NullEquipType
	Category             AutoAbilityCategory
	AbilityValue         sql.NullInt32
	ActivationCondition  NullAaActivationCondition
	Counter              NullCounterType
	RequiredItemAmountID sql.NullInt32
	GradRcvryStatID      sql.NullInt32
	OnHitElementID       sql.NullInt32
	AddedElemAffinityID  sql.NullInt32
	OnHitStatusID        sql.NullInt32
	AddedPropertyID      sql.NullInt32
	CnvrsnFromModID      sql.NullInt32
	CnvrsnToModID        sql.NullInt32
}

type BaseStat struct {
	ID       int32
	DataHash string
	StatID   int32
	Value    int32
}

type BlitzballItemsList struct {
	ID       int32
	DataHash string
	Category BlitzballTournamentCategory
	Slot     BlitzballItemSlot
}

type CelestialWeapon struct {
	ID          int32
	DataHash    string
	Name        string
	KeyItemBase KeyItemBase
	Formula     CelestialFormula
	CharacterID sql.NullInt32
	AeonID      sql.NullInt32
}

type Character struct {
	ID                  int32
	DataHash            string
	UnitID              int32
	StoryOnly           bool
	WeaponType          WeaponType
	ArmorType           ArmorType
	PhysicalAttackRange interface{}
	CanFightUnderwater  bool
}

type CharacterClass struct {
	ID       int32
	DataHash string
	Name     string
}

type DefaultAbility struct {
	ID       int32
	DataHash string
	Name     string
}

type Element struct {
	ID                int32
	DataHash          string
	Name              string
	OppositeElementID sql.NullInt32
}

type ElementalAffinity struct {
	ID         int32
	DataHash   string
	ElementID  int32
	AffinityID int32
}

type EnemyAbility struct {
	ID        int32
	DataHash  string
	AbilityID int32
	Effect    sql.NullString
}

type EquipmentAbility struct {
	ID                  int32
	DataHash            string
	Type                EquipType
	Classification      EquipClass
	SpecificCharacterID sql.NullInt32
	Version             sql.NullInt32
	Priority            sql.NullInt32
	Pool1Amt            sql.NullInt32
	Pool2Amt            sql.NullInt32
	EmptySlotsAmt       int32
}

type Fmv struct {
	ID                  int32
	DataHash            string
	Name                string
	Translation         sql.NullString
	CutsceneDescription string
	SongID              sql.NullInt32
	AreaID              int32
}

type InflictedStatuss struct {
	ID                int32
	DataHash          string
	StatusConditionID int32
	Probability       interface{}
	DurationType      DurationType
	Amount            sql.NullInt32
}

type Item struct {
	ID                    int32
	DataHash              string
	MasterItemID          int32
	Description           string
	Effect                string
	SphereGridDescription sql.NullString
	Category              ItemCategory
	Usability             NullItemUsability
	BasePrice             sql.NullInt32
	SellValue             int32
}

type ItemAbility struct {
	ID        int32
	DataHash  string
	ItemID    int32
	AbilityID int32
	Cursor    TargetType
}

type ItemAmount struct {
	ID           int32
	DataHash     string
	MasterItemID int32
	Amount       int32
}

type JAutoAbilityItem struct {
	ID            int32
	DataHash      string
	AutoAbilityID int32
	ItemID        int32
}

type JAutoAbilityModifierChange struct {
	ID               int32
	DataHash         string
	AutoAbilityID    int32
	ModifierChangeID int32
}

type JAutoAbilitySelf struct {
	ID              int32
	DataHash        string
	ParentAbilityID int32
	ChildAbilityID  int32
}

type JAutoAbilityStat struct {
	ID            int32
	DataHash      string
	AutoAbilityID int32
	StatID        int32
}

type JAutoAbilityStatChange struct {
	ID            int32
	DataHash      string
	AutoAbilityID int32
	StatChangeID  int32
}

type JAutoAbilityStatusCondition struct {
	ID                int32
	DataHash          string
	AutoAbilityID     int32
	StatusConditionID int32
}

type JAutoAbilityStatusResist struct {
	ID             int32
	DataHash       string
	AutoAbilityID  int32
	StatusResistID int32
}

type JCharacterBaseStat struct {
	ID          int32
	DataHash    string
	CharacterID int32
	BaseStatID  int32
}

type JMixCombo struct {
	ID          int32
	DataHash    string
	MixID       int32
	ComboID     int32
	IsBestCombo bool
}

type JOdModeAction struct {
	ID              int32
	DataHash        string
	OverdriveModeID int32
	ActionID        int32
}

type JPropertyModifierChange struct {
	ID               int32
	DataHash         string
	PropertyID       int32
	ModifierChangeID int32
}

type JPropertyStat struct {
	ID         int32
	DataHash   string
	PropertyID int32
	StatID     int32
}

type JPropertyStatChange struct {
	ID           int32
	DataHash     string
	PropertyID   int32
	StatChangeID int32
}

type JPropertyStatusCondition struct {
	ID                int32
	DataHash          string
	PropertyID        int32
	StatusConditionID int32
}

type JStatusConditionModifierChange struct {
	ID                int32
	DataHash          string
	StatusConditionID int32
	ModifierChangeID  int32
}

type JStatusConditionSelf struct {
	ID                int32
	DataHash          string
	ParentConditionID int32
	ChildConditionID  int32
}

type JStatusConditionStat struct {
	ID                int32
	DataHash          string
	StatusConditionID int32
	StatID            int32
}

type JStatusConditionStatChange struct {
	ID                int32
	DataHash          string
	StatusConditionID int32
	StatChangeID      int32
}

type JSubmenuCharacterClass struct {
	ID               int32
	DataHash         string
	SubmenuID        int32
	CharacterClassID int32
}

type JUnitCharacterClass struct {
	ID       int32
	DataHash string
	UnitID   int32
	ClassID  int32
}

type KeyItem struct {
	ID           int32
	DataHash     string
	MasterItemID int32
	Category     KeyItemCategory
	Description  string
	Effect       string
}

type Location struct {
	ID       int32
	DataHash string
	Name     string
}

type MasterItem struct {
	ID       int32
	DataHash string
	Name     string
	Type     ItemType
}

type Mix struct {
	ID          int32
	DataHash    string
	OverdriveID int32
	Category    MixCategory
}

type MixCombination struct {
	ID           int32
	DataHash     string
	FirstItemID  int32
	SecondItemID int32
}

type Modifier struct {
	ID           int32
	DataHash     string
	Name         string
	Effect       string
	Type         ModifierType
	DefaultValue sql.NullFloat64
}

type ModifierChange struct {
	ID              int32
	DataHash        string
	ModifierID      int32
	CalculationType CalculationType
	Value           float32
}

type Monster struct {
	ID                   int32
	DataHash             string
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	Notes                sql.NullString
	Species              MonsterSpecies
	IsStoryBased         bool
	CanBeCaptured        bool
	AreaConquestLocation NullMaCreationArea
	CtbIconType          CtbIconType
	HasOverdrive         bool
	IsUnderwater         bool
	IsZombie             bool
	Distance             interface{}
	Ap                   int32
	ApOverkill           int32
	OverkillDamage       int32
	Gil                  int32
	StealGil             sql.NullInt32
	DoomCountdown        interface{}
	PoisonRate           interface{}
	ThreatenChance       interface{}
	ZanmatoLevel         interface{}
	MonsterArenaPrice    sql.NullInt32
	SensorText           string
	ScanText             sql.NullString
}

type MonsterArenaCreation struct {
	ID                        int32
	DataHash                  string
	SubquestID                int32
	Category                  MaCreationCategory
	RequiredArea              NullMaCreationArea
	RequiredSpecies           NullMaCreationSpecies
	UnderwaterOnly            bool
	CreationsUnlockedCategory NullCreationsUnlockedCategory
	Amount                    int32
}

type MonsterFormationList struct {
	ID       int32
	DataHash string
	Version  sql.NullInt32
	AreaID   int32
	Notes    sql.NullString
}

type OdModeAction struct {
	ID       int32
	DataHash string
	UserID   int32
	Amount   int32
}

type Overdrife struct {
	ID              int32
	DataHash        string
	OdCommandID     sql.NullInt32
	Name            string
	Version         sql.NullInt32
	Description     string
	Effect          string
	Topmenu         NullTopmenuType
	AttributesID    int32
	UnlockCondition sql.NullString
	CountdownInSec  sql.NullInt32
	Cursor          NullTargetType
}

type OverdriveAbility struct {
	ID        int32
	DataHash  string
	AbilityID int32
}

type OverdriveCommand struct {
	ID          int32
	DataHash    string
	Name        string
	Description string
	Rank        int32
	Topmenu     NullTopmenuType
}

type OverdriveMode struct {
	ID          int32
	DataHash    string
	Name        string
	Description string
	Effect      string
	Type        OverdriveType
	FillRate    interface{}
}

type PlayerAbility struct {
	ID                  int32
	DataHash            string
	AbilityID           int32
	Description         sql.NullString
	Effect              string
	Topmenu             NullTopmenuType
	CanUseOutsideBattle bool
	MpCost              sql.NullInt32
	Cursor              NullTargetType
}

type PlayerUnit struct {
	ID       int32
	DataHash string
	Name     string
	Type     UnitType
}

type Primer struct {
	ID            int32
	DataHash      string
	KeyItemID     int32
	AlBhedLetter  string
	EnglishLetter string
}

type Property struct {
	ID             int32
	DataHash       string
	Name           string
	Effect         string
	NullifyArmored NullNullifyArmored
}

type Quest struct {
	ID       int32
	DataHash string
	Name     string
	Type     QuestType
}

type Shop struct {
	ID       int32
	DataHash string
	Version  sql.NullInt32
	AreaID   int32
	Notes    sql.NullString
	Category ShopCategory
}

type Sidequest struct {
	ID       int32
	DataHash string
	QuestID  int32
}

type Song struct {
	ID                   int32
	DataHash             string
	Name                 string
	StreamingName        sql.NullString
	InGameName           sql.NullString
	OstName              sql.NullString
	Translation          sql.NullString
	StreamingTrackNumber sql.NullInt32
	MusicSphereID        sql.NullInt32
	OstDisc              interface{}
	OstTrackNumber       sql.NullInt32
	DurationInSeconds    int32
	CanLoop              bool
	SpecialUseCase       NullMusicUseCase
	CreditsID            sql.NullInt32
}

type SongCredit struct {
	ID        int32
	DataHash  string
	Composer  sql.NullString
	Arranger  sql.NullString
	Performer sql.NullString
	Lyricist  sql.NullString
}

type Stat struct {
	ID       int32
	DataHash string
	Name     string
	Effect   string
	MinVal   int32
	MaxVal   int32
	MaxVal2  sql.NullInt32
	SphereID sql.NullInt32
}

type StatChange struct {
	ID              int32
	DataHash        string
	StatID          int32
	CalculationType CalculationType
	Value           float32
}

type StatusCondition struct {
	ID             int32
	DataHash       string
	Name           string
	Effect         string
	Visualization  sql.NullString
	NullifyArmored NullNullifyArmored
}

type StatusResist struct {
	ID                int32
	DataHash          string
	StatusConditionID int32
	Resistance        interface{}
}

type SubLocation struct {
	ID            int32
	DataHash      string
	LocationID    int32
	Name          string
	Specification sql.NullString
}

type Submenu struct {
	ID          int32
	DataHash    string
	Name        string
	Description string
	Effect      string
	Topmenu     NullTopmenuType
}

type Subquest struct {
	ID                int32
	DataHash          string
	QuestID           int32
	ParentSidequestID int32
}

type Treasure struct {
	ID              int32
	DataHash        string
	AreaID          int32
	Version         int32
	TreasureType    TreasureType
	LootType        LootType
	IsPostAirship   bool
	IsAnimaTreasure bool
	Notes           sql.NullString
	GilAmount       sql.NullInt32
}

type TriggerCommand struct {
	ID          int32
	DataHash    string
	AbilityID   int32
	Description string
	Effect      string
	Topmenu     TopmenuType
	Cursor      TargetType
}

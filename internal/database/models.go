// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package database

import (
	"database/sql"
	"database/sql/driver"
	"fmt"
)

type AaActivationCondition string

const (
	AaActivationConditionAlways        AaActivationCondition = "always"
	AaActivationConditionActiveParty   AaActivationCondition = "active-party"
	AaActivationConditionHpCritical    AaActivationCondition = "hp-critical"
	AaActivationConditionOutsideBattle AaActivationCondition = "outside-battle"
)

func (e *AaActivationCondition) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AaActivationCondition(s)
	case string:
		*e = AaActivationCondition(s)
	default:
		return fmt.Errorf("unsupported scan type for AaActivationCondition: %T", src)
	}
	return nil
}

type NullAaActivationCondition struct {
	AaActivationCondition AaActivationCondition
	Valid                 bool // Valid is true if AaActivationCondition is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAaActivationCondition) Scan(value interface{}) error {
	if value == nil {
		ns.AaActivationCondition, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AaActivationCondition.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAaActivationCondition) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AaActivationCondition), nil
}

type AbilityType string

const (
	AbilityTypePlayerAbility    AbilityType = "player-ability"
	AbilityTypeEnemyAbility     AbilityType = "enemy-ability"
	AbilityTypeOverdriveAbility AbilityType = "overdrive-ability"
	AbilityTypeTriggerCommand   AbilityType = "trigger-command"
	AbilityTypeItemAbility      AbilityType = "item-ability"
)

func (e *AbilityType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AbilityType(s)
	case string:
		*e = AbilityType(s)
	default:
		return fmt.Errorf("unsupported scan type for AbilityType: %T", src)
	}
	return nil
}

type NullAbilityType struct {
	AbilityType AbilityType
	Valid       bool // Valid is true if AbilityType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAbilityType) Scan(value interface{}) error {
	if value == nil {
		ns.AbilityType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AbilityType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAbilityType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AbilityType), nil
}

type AccSourceType string

const (
	AccSourceTypeAccuracy AccSourceType = "accuracy"
	AccSourceTypeRate     AccSourceType = "rate"
)

func (e *AccSourceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AccSourceType(s)
	case string:
		*e = AccSourceType(s)
	default:
		return fmt.Errorf("unsupported scan type for AccSourceType: %T", src)
	}
	return nil
}

type NullAccSourceType struct {
	AccSourceType AccSourceType
	Valid         bool // Valid is true if AccSourceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAccSourceType) Scan(value interface{}) error {
	if value == nil {
		ns.AccSourceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AccSourceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAccSourceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AccSourceType), nil
}

type AccuracySource string

const (
	AccuracySourceAccuracy AccuracySource = "accuracy"
	AccuracySourceRate     AccuracySource = "rate"
)

func (e *AccuracySource) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AccuracySource(s)
	case string:
		*e = AccuracySource(s)
	default:
		return fmt.Errorf("unsupported scan type for AccuracySource: %T", src)
	}
	return nil
}

type NullAccuracySource struct {
	AccuracySource AccuracySource
	Valid          bool // Valid is true if AccuracySource is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAccuracySource) Scan(value interface{}) error {
	if value == nil {
		ns.AccuracySource, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AccuracySource.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAccuracySource) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AccuracySource), nil
}

type AlterationType string

const (
	AlterationTypeChange AlterationType = "change"
	AlterationTypeGain   AlterationType = "gain"
	AlterationTypeLoss   AlterationType = "loss"
)

func (e *AlterationType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AlterationType(s)
	case string:
		*e = AlterationType(s)
	default:
		return fmt.Errorf("unsupported scan type for AlterationType: %T", src)
	}
	return nil
}

type NullAlterationType struct {
	AlterationType AlterationType
	Valid          bool // Valid is true if AlterationType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAlterationType) Scan(value interface{}) error {
	if value == nil {
		ns.AlterationType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AlterationType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAlterationType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AlterationType), nil
}

type AreaConnectionType string

const (
	AreaConnectionTypeBothDirections AreaConnectionType = "both-directions"
	AreaConnectionTypeOneDirection   AreaConnectionType = "one-direction"
	AreaConnectionTypeWarp           AreaConnectionType = "warp"
)

func (e *AreaConnectionType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AreaConnectionType(s)
	case string:
		*e = AreaConnectionType(s)
	default:
		return fmt.Errorf("unsupported scan type for AreaConnectionType: %T", src)
	}
	return nil
}

type NullAreaConnectionType struct {
	AreaConnectionType AreaConnectionType
	Valid              bool // Valid is true if AreaConnectionType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAreaConnectionType) Scan(value interface{}) error {
	if value == nil {
		ns.AreaConnectionType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AreaConnectionType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAreaConnectionType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AreaConnectionType), nil
}

type ArmorType string

const (
	ArmorTypeShield       ArmorType = "shield"
	ArmorTypeRing         ArmorType = "ring"
	ArmorTypeArmguard     ArmorType = "armguard"
	ArmorTypeBangle       ArmorType = "bangle"
	ArmorTypeArmlet       ArmorType = "armlet"
	ArmorTypeBracer       ArmorType = "bracer"
	ArmorTypeTarge        ArmorType = "targe"
	ArmorTypeSeymourArmor ArmorType = "seymour-armor"
)

func (e *ArmorType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ArmorType(s)
	case string:
		*e = ArmorType(s)
	default:
		return fmt.Errorf("unsupported scan type for ArmorType: %T", src)
	}
	return nil
}

type NullArmorType struct {
	ArmorType ArmorType
	Valid     bool // Valid is true if ArmorType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullArmorType) Scan(value interface{}) error {
	if value == nil {
		ns.ArmorType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ArmorType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullArmorType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ArmorType), nil
}

type AttackType string

const (
	AttackTypeAttack AttackType = "attack"
	AttackTypeHeal   AttackType = "heal"
	AttackTypeAbsorb AttackType = "absorb"
)

func (e *AttackType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AttackType(s)
	case string:
		*e = AttackType(s)
	default:
		return fmt.Errorf("unsupported scan type for AttackType: %T", src)
	}
	return nil
}

type NullAttackType struct {
	AttackType AttackType
	Valid      bool // Valid is true if AttackType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAttackType) Scan(value interface{}) error {
	if value == nil {
		ns.AttackType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AttackType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAttackType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AttackType), nil
}

type AutoAbilityCategory string

const (
	AutoAbilityCategoryApOverdrive         AutoAbilityCategory = "ap-overdrive"
	AutoAbilityCategoryAutoCure            AutoAbilityCategory = "auto-cure"
	AutoAbilityCategoryAutoStatus          AutoAbilityCategory = "auto-status"
	AutoAbilityCategoryBreakLimit          AutoAbilityCategory = "break-limit"
	AutoAbilityCategoryCounter             AutoAbilityCategory = "counter"
	AutoAbilityCategoryElementalProtection AutoAbilityCategory = "elemental-protection"
	AutoAbilityCategoryElementalStrike     AutoAbilityCategory = "elemental-strike"
	AutoAbilityCategoryOther               AutoAbilityCategory = "other"
	AutoAbilityCategorySosStatus           AutoAbilityCategory = "sos-status"
	AutoAbilityCategoryStatX               AutoAbilityCategory = "stat-+x%"
	AutoAbilityCategoryStatusInfliction    AutoAbilityCategory = "status-infliction"
	AutoAbilityCategoryStatusProtection    AutoAbilityCategory = "status-protection"
)

func (e *AutoAbilityCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AutoAbilityCategory(s)
	case string:
		*e = AutoAbilityCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for AutoAbilityCategory: %T", src)
	}
	return nil
}

type NullAutoAbilityCategory struct {
	AutoAbilityCategory AutoAbilityCategory
	Valid               bool // Valid is true if AutoAbilityCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAutoAbilityCategory) Scan(value interface{}) error {
	if value == nil {
		ns.AutoAbilityCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AutoAbilityCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAutoAbilityCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AutoAbilityCategory), nil
}

type AutoAbilityPool string

const (
	AutoAbilityPoolRequired AutoAbilityPool = "required"
	AutoAbilityPoolOne      AutoAbilityPool = "one"
	AutoAbilityPoolTwo      AutoAbilityPool = "two"
)

func (e *AutoAbilityPool) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AutoAbilityPool(s)
	case string:
		*e = AutoAbilityPool(s)
	default:
		return fmt.Errorf("unsupported scan type for AutoAbilityPool: %T", src)
	}
	return nil
}

type NullAutoAbilityPool struct {
	AutoAbilityPool AutoAbilityPool
	Valid           bool // Valid is true if AutoAbilityPool is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAutoAbilityPool) Scan(value interface{}) error {
	if value == nil {
		ns.AutoAbilityPool, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AutoAbilityPool.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAutoAbilityPool) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AutoAbilityPool), nil
}

type BgReplacementType string

const (
	BgReplacementTypeUntilTrigger    BgReplacementType = "until-trigger"
	BgReplacementTypeUntilZoneChange BgReplacementType = "until-zone-change"
)

func (e *BgReplacementType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BgReplacementType(s)
	case string:
		*e = BgReplacementType(s)
	default:
		return fmt.Errorf("unsupported scan type for BgReplacementType: %T", src)
	}
	return nil
}

type NullBgReplacementType struct {
	BgReplacementType BgReplacementType
	Valid             bool // Valid is true if BgReplacementType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBgReplacementType) Scan(value interface{}) error {
	if value == nil {
		ns.BgReplacementType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BgReplacementType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBgReplacementType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BgReplacementType), nil
}

type BlitzballPositionSlot string

const (
	BlitzballPositionSlot1st       BlitzballPositionSlot = "1st"
	BlitzballPositionSlot2nd       BlitzballPositionSlot = "2nd"
	BlitzballPositionSlot3rd       BlitzballPositionSlot = "3rd"
	BlitzballPositionSlotTopScorer BlitzballPositionSlot = "top-scorer"
)

func (e *BlitzballPositionSlot) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BlitzballPositionSlot(s)
	case string:
		*e = BlitzballPositionSlot(s)
	default:
		return fmt.Errorf("unsupported scan type for BlitzballPositionSlot: %T", src)
	}
	return nil
}

type NullBlitzballPositionSlot struct {
	BlitzballPositionSlot BlitzballPositionSlot
	Valid                 bool // Valid is true if BlitzballPositionSlot is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBlitzballPositionSlot) Scan(value interface{}) error {
	if value == nil {
		ns.BlitzballPositionSlot, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BlitzballPositionSlot.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBlitzballPositionSlot) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BlitzballPositionSlot), nil
}

type BlitzballTournamentCategory string

const (
	BlitzballTournamentCategoryLeague     BlitzballTournamentCategory = "league"
	BlitzballTournamentCategoryTournament BlitzballTournamentCategory = "tournament"
)

func (e *BlitzballTournamentCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BlitzballTournamentCategory(s)
	case string:
		*e = BlitzballTournamentCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for BlitzballTournamentCategory: %T", src)
	}
	return nil
}

type NullBlitzballTournamentCategory struct {
	BlitzballTournamentCategory BlitzballTournamentCategory
	Valid                       bool // Valid is true if BlitzballTournamentCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBlitzballTournamentCategory) Scan(value interface{}) error {
	if value == nil {
		ns.BlitzballTournamentCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BlitzballTournamentCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBlitzballTournamentCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BlitzballTournamentCategory), nil
}

type BreakDmgLmtType string

const (
	BreakDmgLmtTypeAlways      BreakDmgLmtType = "always"
	BreakDmgLmtTypeAutoAbility BreakDmgLmtType = "auto-ability"
)

func (e *BreakDmgLmtType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BreakDmgLmtType(s)
	case string:
		*e = BreakDmgLmtType(s)
	default:
		return fmt.Errorf("unsupported scan type for BreakDmgLmtType: %T", src)
	}
	return nil
}

type NullBreakDmgLmtType struct {
	BreakDmgLmtType BreakDmgLmtType
	Valid           bool // Valid is true if BreakDmgLmtType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBreakDmgLmtType) Scan(value interface{}) error {
	if value == nil {
		ns.BreakDmgLmtType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BreakDmgLmtType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBreakDmgLmtType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BreakDmgLmtType), nil
}

type CalculationType string

const (
	CalculationTypeAddedPercentage CalculationType = "added-percentage"
	CalculationTypeAddedValue      CalculationType = "added-value"
	CalculationTypeMultiply        CalculationType = "multiply"
	CalculationTypeMultiplyHighest CalculationType = "multiply-highest"
	CalculationTypeSetValue        CalculationType = "set-value"
)

func (e *CalculationType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CalculationType(s)
	case string:
		*e = CalculationType(s)
	default:
		return fmt.Errorf("unsupported scan type for CalculationType: %T", src)
	}
	return nil
}

type NullCalculationType struct {
	CalculationType CalculationType
	Valid           bool // Valid is true if CalculationType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCalculationType) Scan(value interface{}) error {
	if value == nil {
		ns.CalculationType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CalculationType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCalculationType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CalculationType), nil
}

type CelestialFormula string

const (
	CelestialFormulaHpHigh CelestialFormula = "hp-high"
	CelestialFormulaHpLow  CelestialFormula = "hp-low"
	CelestialFormulaMpHigh CelestialFormula = "mp-high"
)

func (e *CelestialFormula) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CelestialFormula(s)
	case string:
		*e = CelestialFormula(s)
	default:
		return fmt.Errorf("unsupported scan type for CelestialFormula: %T", src)
	}
	return nil
}

type NullCelestialFormula struct {
	CelestialFormula CelestialFormula
	Valid            bool // Valid is true if CelestialFormula is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCelestialFormula) Scan(value interface{}) error {
	if value == nil {
		ns.CelestialFormula, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CelestialFormula.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCelestialFormula) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CelestialFormula), nil
}

type CounterType string

const (
	CounterTypePhysical CounterType = "physical"
	CounterTypeMagical  CounterType = "magical"
)

func (e *CounterType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CounterType(s)
	case string:
		*e = CounterType(s)
	default:
		return fmt.Errorf("unsupported scan type for CounterType: %T", src)
	}
	return nil
}

type NullCounterType struct {
	CounterType CounterType
	Valid       bool // Valid is true if CounterType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCounterType) Scan(value interface{}) error {
	if value == nil {
		ns.CounterType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CounterType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCounterType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CounterType), nil
}

type CreationsUnlockedCategory string

const (
	CreationsUnlockedCategoryArea    CreationsUnlockedCategory = "area"
	CreationsUnlockedCategorySpecies CreationsUnlockedCategory = "species"
)

func (e *CreationsUnlockedCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CreationsUnlockedCategory(s)
	case string:
		*e = CreationsUnlockedCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for CreationsUnlockedCategory: %T", src)
	}
	return nil
}

type NullCreationsUnlockedCategory struct {
	CreationsUnlockedCategory CreationsUnlockedCategory
	Valid                     bool // Valid is true if CreationsUnlockedCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCreationsUnlockedCategory) Scan(value interface{}) error {
	if value == nil {
		ns.CreationsUnlockedCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CreationsUnlockedCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCreationsUnlockedCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CreationsUnlockedCategory), nil
}

type CriticalType string

const (
	CriticalTypeCrit        CriticalType = "crit"
	CriticalTypeCritability CriticalType = "crit+ability%"
	CriticalTypeCritweapon  CriticalType = "crit+weapon%"
)

func (e *CriticalType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CriticalType(s)
	case string:
		*e = CriticalType(s)
	default:
		return fmt.Errorf("unsupported scan type for CriticalType: %T", src)
	}
	return nil
}

type NullCriticalType struct {
	CriticalType CriticalType
	Valid        bool // Valid is true if CriticalType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCriticalType) Scan(value interface{}) error {
	if value == nil {
		ns.CriticalType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CriticalType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCriticalType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CriticalType), nil
}

type CtbAttackType string

const (
	CtbAttackTypeAttack CtbAttackType = "attack"
	CtbAttackTypeHeal   CtbAttackType = "heal"
)

func (e *CtbAttackType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CtbAttackType(s)
	case string:
		*e = CtbAttackType(s)
	default:
		return fmt.Errorf("unsupported scan type for CtbAttackType: %T", src)
	}
	return nil
}

type NullCtbAttackType struct {
	CtbAttackType CtbAttackType
	Valid         bool // Valid is true if CtbAttackType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCtbAttackType) Scan(value interface{}) error {
	if value == nil {
		ns.CtbAttackType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CtbAttackType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCtbAttackType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CtbAttackType), nil
}

type CtbIconType string

const (
	CtbIconTypeMonster      CtbIconType = "monster"
	CtbIconTypeBoss         CtbIconType = "boss"
	CtbIconTypeBossNumbered CtbIconType = "boss-numbered"
	CtbIconTypeSummon       CtbIconType = "summon"
)

func (e *CtbIconType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CtbIconType(s)
	case string:
		*e = CtbIconType(s)
	default:
		return fmt.Errorf("unsupported scan type for CtbIconType: %T", src)
	}
	return nil
}

type NullCtbIconType struct {
	CtbIconType CtbIconType
	Valid       bool // Valid is true if CtbIconType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCtbIconType) Scan(value interface{}) error {
	if value == nil {
		ns.CtbIconType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CtbIconType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCtbIconType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CtbIconType), nil
}

type DamageFormula string

const (
	DamageFormulaStrVsDef          DamageFormula = "str-vs-def"
	DamageFormulaStrIgnDef         DamageFormula = "str-ign-def"
	DamageFormulaMagVsMdf          DamageFormula = "mag-vs-mdf"
	DamageFormulaMagIgnMdf         DamageFormula = "mag-ign-mdf"
	DamageFormulaPercentageCurrent DamageFormula = "percentage-current"
	DamageFormulaPercentageMax     DamageFormula = "percentage-max"
	DamageFormulaHealing           DamageFormula = "healing"
	DamageFormulaSpecialNoVar      DamageFormula = "special-no-var"
	DamageFormulaSpecialVar        DamageFormula = "special-var"
	DamageFormulaSpecialMagic      DamageFormula = "special-magic"
	DamageFormulaSpecialGil        DamageFormula = "special-gil"
	DamageFormulaSpecialKills      DamageFormula = "special-kills"
	DamageFormulaSpecial9999       DamageFormula = "special-9999"
	DamageFormulaFixed9999         DamageFormula = "fixed-9999"
	DamageFormulaUserMaxHp         DamageFormula = "user-max-hp"
	DamageFormulaSwallowedA        DamageFormula = "swallowed-a"
	DamageFormulaSwallowedB        DamageFormula = "swallowed-b"
)

func (e *DamageFormula) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DamageFormula(s)
	case string:
		*e = DamageFormula(s)
	default:
		return fmt.Errorf("unsupported scan type for DamageFormula: %T", src)
	}
	return nil
}

type NullDamageFormula struct {
	DamageFormula DamageFormula
	Valid         bool // Valid is true if DamageFormula is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDamageFormula) Scan(value interface{}) error {
	if value == nil {
		ns.DamageFormula, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DamageFormula.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDamageFormula) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DamageFormula), nil
}

type DamageType string

const (
	DamageTypePhysical DamageType = "physical"
	DamageTypeMagical  DamageType = "magical"
	DamageTypeSpecial  DamageType = "special"
)

func (e *DamageType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DamageType(s)
	case string:
		*e = DamageType(s)
	default:
		return fmt.Errorf("unsupported scan type for DamageType: %T", src)
	}
	return nil
}

type NullDamageType struct {
	DamageType DamageType
	Valid      bool // Valid is true if DamageType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDamageType) Scan(value interface{}) error {
	if value == nil {
		ns.DamageType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DamageType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDamageType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DamageType), nil
}

type DelayType string

const (
	DelayTypeCtbBased       DelayType = "ctb-based"
	DelayTypeTickSpeedBased DelayType = "tick-speed-based"
)

func (e *DelayType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DelayType(s)
	case string:
		*e = DelayType(s)
	default:
		return fmt.Errorf("unsupported scan type for DelayType: %T", src)
	}
	return nil
}

type NullDelayType struct {
	DelayType DelayType
	Valid     bool // Valid is true if DelayType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDelayType) Scan(value interface{}) error {
	if value == nil {
		ns.DelayType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DelayType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDelayType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DelayType), nil
}

type DurationType string

const (
	DurationTypeBlocks    DurationType = "blocks"
	DurationTypeEndless   DurationType = "endless"
	DurationTypeInstant   DurationType = "instant"
	DurationTypeTurns     DurationType = "turns"
	DurationTypeUserTurns DurationType = "user-turns"
	DurationTypeAuto      DurationType = "auto"
)

func (e *DurationType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = DurationType(s)
	case string:
		*e = DurationType(s)
	default:
		return fmt.Errorf("unsupported scan type for DurationType: %T", src)
	}
	return nil
}

type NullDurationType struct {
	DurationType DurationType
	Valid        bool // Valid is true if DurationType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullDurationType) Scan(value interface{}) error {
	if value == nil {
		ns.DurationType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.DurationType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullDurationType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.DurationType), nil
}

type EquipClass string

const (
	EquipClassStandard        EquipClass = "standard"
	EquipClassUnique          EquipClass = "unique"
	EquipClassCelestialWeapon EquipClass = "celestial-weapon"
)

func (e *EquipClass) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EquipClass(s)
	case string:
		*e = EquipClass(s)
	default:
		return fmt.Errorf("unsupported scan type for EquipClass: %T", src)
	}
	return nil
}

type NullEquipClass struct {
	EquipClass EquipClass
	Valid      bool // Valid is true if EquipClass is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEquipClass) Scan(value interface{}) error {
	if value == nil {
		ns.EquipClass, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EquipClass.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEquipClass) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EquipClass), nil
}

type EquipType string

const (
	EquipTypeWeapon EquipType = "weapon"
	EquipTypeArmor  EquipType = "armor"
)

func (e *EquipType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EquipType(s)
	case string:
		*e = EquipType(s)
	default:
		return fmt.Errorf("unsupported scan type for EquipType: %T", src)
	}
	return nil
}

type NullEquipType struct {
	EquipType EquipType
	Valid     bool // Valid is true if EquipType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEquipType) Scan(value interface{}) error {
	if value == nil {
		ns.EquipType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EquipType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEquipType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EquipType), nil
}

type ItemCategory string

const (
	ItemCategoryDistiller ItemCategory = "distiller"
	ItemCategoryHealing   ItemCategory = "healing"
	ItemCategoryOffensive ItemCategory = "offensive"
	ItemCategoryOther     ItemCategory = "other"
	ItemCategorySphere    ItemCategory = "sphere"
	ItemCategorySupport   ItemCategory = "support"
)

func (e *ItemCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ItemCategory(s)
	case string:
		*e = ItemCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for ItemCategory: %T", src)
	}
	return nil
}

type NullItemCategory struct {
	ItemCategory ItemCategory
	Valid        bool // Valid is true if ItemCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullItemCategory) Scan(value interface{}) error {
	if value == nil {
		ns.ItemCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ItemCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullItemCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ItemCategory), nil
}

type ItemType string

const (
	ItemTypeItem    ItemType = "item"
	ItemTypeKeyItem ItemType = "key-item"
)

func (e *ItemType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ItemType(s)
	case string:
		*e = ItemType(s)
	default:
		return fmt.Errorf("unsupported scan type for ItemType: %T", src)
	}
	return nil
}

type NullItemType struct {
	ItemType ItemType
	Valid    bool // Valid is true if ItemType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullItemType) Scan(value interface{}) error {
	if value == nil {
		ns.ItemType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ItemType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullItemType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ItemType), nil
}

type ItemUsability string

const (
	ItemUsabilityAlways        ItemUsability = "always"
	ItemUsabilityInBattle      ItemUsability = "in-battle"
	ItemUsabilityOutsideBattle ItemUsability = "outside-battle"
)

func (e *ItemUsability) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ItemUsability(s)
	case string:
		*e = ItemUsability(s)
	default:
		return fmt.Errorf("unsupported scan type for ItemUsability: %T", src)
	}
	return nil
}

type NullItemUsability struct {
	ItemUsability ItemUsability
	Valid         bool // Valid is true if ItemUsability is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullItemUsability) Scan(value interface{}) error {
	if value == nil {
		ns.ItemUsability, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ItemUsability.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullItemUsability) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ItemUsability), nil
}

type KeyItemBase string

const (
	KeyItemBaseSun     KeyItemBase = "sun"
	KeyItemBaseMoon    KeyItemBase = "moon"
	KeyItemBaseJupiter KeyItemBase = "jupiter"
	KeyItemBaseVenus   KeyItemBase = "venus"
	KeyItemBaseSaturn  KeyItemBase = "saturn"
	KeyItemBaseMars    KeyItemBase = "mars"
	KeyItemBaseMercury KeyItemBase = "mercury"
)

func (e *KeyItemBase) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = KeyItemBase(s)
	case string:
		*e = KeyItemBase(s)
	default:
		return fmt.Errorf("unsupported scan type for KeyItemBase: %T", src)
	}
	return nil
}

type NullKeyItemBase struct {
	KeyItemBase KeyItemBase
	Valid       bool // Valid is true if KeyItemBase is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullKeyItemBase) Scan(value interface{}) error {
	if value == nil {
		ns.KeyItemBase, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.KeyItemBase.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullKeyItemBase) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.KeyItemBase), nil
}

type KeyItemCategory string

const (
	KeyItemCategoryCelestial   KeyItemCategory = "celestial"
	KeyItemCategoryJechtSphere KeyItemCategory = "jecht-sphere"
	KeyItemCategoryOther       KeyItemCategory = "other"
	KeyItemCategoryPrimer      KeyItemCategory = "primer"
	KeyItemCategoryStory       KeyItemCategory = "story"
)

func (e *KeyItemCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = KeyItemCategory(s)
	case string:
		*e = KeyItemCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for KeyItemCategory: %T", src)
	}
	return nil
}

type NullKeyItemCategory struct {
	KeyItemCategory KeyItemCategory
	Valid           bool // Valid is true if KeyItemCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullKeyItemCategory) Scan(value interface{}) error {
	if value == nil {
		ns.KeyItemCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.KeyItemCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullKeyItemCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.KeyItemCategory), nil
}

type LootType string

const (
	LootTypeItem      LootType = "item"
	LootTypeEquipment LootType = "equipment"
	LootTypeGil       LootType = "gil"
)

func (e *LootType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = LootType(s)
	case string:
		*e = LootType(s)
	default:
		return fmt.Errorf("unsupported scan type for LootType: %T", src)
	}
	return nil
}

type NullLootType struct {
	LootType LootType
	Valid    bool // Valid is true if LootType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullLootType) Scan(value interface{}) error {
	if value == nil {
		ns.LootType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.LootType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullLootType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.LootType), nil
}

type MaCreationArea string

const (
	MaCreationAreaBesaid                 MaCreationArea = "besaid"
	MaCreationAreaKilika                 MaCreationArea = "kilika"
	MaCreationAreaMiihenHighroad         MaCreationArea = "mi'ihen-highroad"
	MaCreationAreaMushroomRockRoad       MaCreationArea = "mushroom-rock-road"
	MaCreationAreaDjose                  MaCreationArea = "djose"
	MaCreationAreaThunderPlains          MaCreationArea = "thunder-plains"
	MaCreationAreaMacalania              MaCreationArea = "macalania"
	MaCreationAreaBikanel                MaCreationArea = "bikanel"
	MaCreationAreaCalmLands              MaCreationArea = "calm-lands"
	MaCreationAreaCavernOfTheStolenFayth MaCreationArea = "cavern-of-the-stolen-fayth"
	MaCreationAreaMountGagazet           MaCreationArea = "mount-gagazet"
	MaCreationAreaSin                    MaCreationArea = "sin"
	MaCreationAreaOmegaRuins             MaCreationArea = "omega-ruins"
)

func (e *MaCreationArea) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MaCreationArea(s)
	case string:
		*e = MaCreationArea(s)
	default:
		return fmt.Errorf("unsupported scan type for MaCreationArea: %T", src)
	}
	return nil
}

type NullMaCreationArea struct {
	MaCreationArea MaCreationArea
	Valid          bool // Valid is true if MaCreationArea is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMaCreationArea) Scan(value interface{}) error {
	if value == nil {
		ns.MaCreationArea, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MaCreationArea.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMaCreationArea) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MaCreationArea), nil
}

type MaCreationCategory string

const (
	MaCreationCategoryArea     MaCreationCategory = "area"
	MaCreationCategorySpecies  MaCreationCategory = "species"
	MaCreationCategoryOriginal MaCreationCategory = "original"
)

func (e *MaCreationCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MaCreationCategory(s)
	case string:
		*e = MaCreationCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for MaCreationCategory: %T", src)
	}
	return nil
}

type NullMaCreationCategory struct {
	MaCreationCategory MaCreationCategory
	Valid              bool // Valid is true if MaCreationCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMaCreationCategory) Scan(value interface{}) error {
	if value == nil {
		ns.MaCreationCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MaCreationCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMaCreationCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MaCreationCategory), nil
}

type MaCreationSpecies string

const (
	MaCreationSpeciesBird      MaCreationSpecies = "bird"
	MaCreationSpeciesBomb      MaCreationSpecies = "bomb"
	MaCreationSpeciesDrake     MaCreationSpecies = "drake"
	MaCreationSpeciesElemental MaCreationSpecies = "elemental"
	MaCreationSpeciesEvilEye   MaCreationSpecies = "evil-eye"
	MaCreationSpeciesFlan      MaCreationSpecies = "flan"
	MaCreationSpeciesFungus    MaCreationSpecies = "fungus"
	MaCreationSpeciesHelm      MaCreationSpecies = "helm"
	MaCreationSpeciesImp       MaCreationSpecies = "imp"
	MaCreationSpeciesIronGiant MaCreationSpecies = "iron-giant"
	MaCreationSpeciesLupine    MaCreationSpecies = "lupine"
	MaCreationSpeciesReptile   MaCreationSpecies = "reptile"
	MaCreationSpeciesRuminant  MaCreationSpecies = "ruminant"
	MaCreationSpeciesWasp      MaCreationSpecies = "wasp"
)

func (e *MaCreationSpecies) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MaCreationSpecies(s)
	case string:
		*e = MaCreationSpecies(s)
	default:
		return fmt.Errorf("unsupported scan type for MaCreationSpecies: %T", src)
	}
	return nil
}

type NullMaCreationSpecies struct {
	MaCreationSpecies MaCreationSpecies
	Valid             bool // Valid is true if MaCreationSpecies is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMaCreationSpecies) Scan(value interface{}) error {
	if value == nil {
		ns.MaCreationSpecies, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MaCreationSpecies.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMaCreationSpecies) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MaCreationSpecies), nil
}

type MixCategory string

const (
	MixCategory9999Damage         MixCategory = "9999-damage"
	MixCategoryCriticalHits       MixCategory = "critical-hits"
	MixCategoryFireElemental      MixCategory = "fire-elemental"
	MixCategoryGravityBased       MixCategory = "gravity-based"
	MixCategoryHpMp               MixCategory = "hp-mp"
	MixCategoryIceElemental       MixCategory = "ice-elemental"
	MixCategoryLightningElemental MixCategory = "lightning-elemental"
	MixCategoryNonElemental       MixCategory = "non-elemental"
	MixCategoryOverdriveSpeed     MixCategory = "overdrive-speed"
	MixCategoryPositiveStatus     MixCategory = "positive-status"
	MixCategoryRecovery           MixCategory = "recovery"
	MixCategoryWaterElemental     MixCategory = "water-elemental"
)

func (e *MixCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MixCategory(s)
	case string:
		*e = MixCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for MixCategory: %T", src)
	}
	return nil
}

type NullMixCategory struct {
	MixCategory MixCategory
	Valid       bool // Valid is true if MixCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMixCategory) Scan(value interface{}) error {
	if value == nil {
		ns.MixCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MixCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMixCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MixCategory), nil
}

type ModifierType string

const (
	ModifierTypeBattleDependent ModifierType = "battle-dependent"
	ModifierTypeFactor          ModifierType = "factor"
	ModifierTypeFixedValue      ModifierType = "fixed-value"
	ModifierTypePercentage      ModifierType = "percentage"
)

func (e *ModifierType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ModifierType(s)
	case string:
		*e = ModifierType(s)
	default:
		return fmt.Errorf("unsupported scan type for ModifierType: %T", src)
	}
	return nil
}

type NullModifierType struct {
	ModifierType ModifierType
	Valid        bool // Valid is true if ModifierType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullModifierType) Scan(value interface{}) error {
	if value == nil {
		ns.ModifierType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ModifierType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullModifierType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ModifierType), nil
}

type MonsterFormationCategory string

const (
	MonsterFormationCategoryBossFight       MonsterFormationCategory = "boss-fight"
	MonsterFormationCategoryOnDemandFight   MonsterFormationCategory = "on-demand-fight"
	MonsterFormationCategoryRandomEncounter MonsterFormationCategory = "random-encounter"
	MonsterFormationCategoryStaticEncounter MonsterFormationCategory = "static-encounter"
	MonsterFormationCategoryStoryFight      MonsterFormationCategory = "story-fight"
	MonsterFormationCategoryTutorial        MonsterFormationCategory = "tutorial"
)

func (e *MonsterFormationCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MonsterFormationCategory(s)
	case string:
		*e = MonsterFormationCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for MonsterFormationCategory: %T", src)
	}
	return nil
}

type NullMonsterFormationCategory struct {
	MonsterFormationCategory MonsterFormationCategory
	Valid                    bool // Valid is true if MonsterFormationCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMonsterFormationCategory) Scan(value interface{}) error {
	if value == nil {
		ns.MonsterFormationCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MonsterFormationCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMonsterFormationCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MonsterFormationCategory), nil
}

type MonsterSpecies string

const (
	MonsterSpeciesAdamantoise  MonsterSpecies = "adamantoise"
	MonsterSpeciesAeon         MonsterSpecies = "aeon"
	MonsterSpeciesArmor        MonsterSpecies = "armor"
	MonsterSpeciesBasilisk     MonsterSpecies = "basilisk"
	MonsterSpeciesBlade        MonsterSpecies = "blade"
	MonsterSpeciesBehemoth     MonsterSpecies = "behemoth"
	MonsterSpeciesBird         MonsterSpecies = "bird"
	MonsterSpeciesBomb         MonsterSpecies = "bomb"
	MonsterSpeciesCactuar      MonsterSpecies = "cactuar"
	MonsterSpeciesCephalopod   MonsterSpecies = "cephalopod"
	MonsterSpeciesChest        MonsterSpecies = "chest"
	MonsterSpeciesChimera      MonsterSpecies = "chimera"
	MonsterSpeciesCoeurl       MonsterSpecies = "coeurl"
	MonsterSpeciesDefender     MonsterSpecies = "defender"
	MonsterSpeciesDinofish     MonsterSpecies = "dinofish"
	MonsterSpeciesDoomstone    MonsterSpecies = "doomstone"
	MonsterSpeciesDrake        MonsterSpecies = "drake"
	MonsterSpeciesEater        MonsterSpecies = "eater"
	MonsterSpeciesElemental    MonsterSpecies = "elemental"
	MonsterSpeciesEvilEye      MonsterSpecies = "evil-eye"
	MonsterSpeciesFlan         MonsterSpecies = "flan"
	MonsterSpeciesFungus       MonsterSpecies = "fungus"
	MonsterSpeciesGel          MonsterSpecies = "gel"
	MonsterSpeciesGeo          MonsterSpecies = "geo"
	MonsterSpeciesHaizhe       MonsterSpecies = "haizhe"
	MonsterSpeciesHelm         MonsterSpecies = "helm"
	MonsterSpeciesHermit       MonsterSpecies = "hermit"
	MonsterSpeciesHumanoid     MonsterSpecies = "humanoid"
	MonsterSpeciesImp          MonsterSpecies = "imp"
	MonsterSpeciesIronGiant    MonsterSpecies = "iron-giant"
	MonsterSpeciesLarva        MonsterSpecies = "larva"
	MonsterSpeciesLupine       MonsterSpecies = "lupine"
	MonsterSpeciesMachina      MonsterSpecies = "machina"
	MonsterSpeciesMalboro      MonsterSpecies = "malboro"
	MonsterSpeciesMech         MonsterSpecies = "mech"
	MonsterSpeciesMimic        MonsterSpecies = "mimic"
	MonsterSpeciesOchu         MonsterSpecies = "ochu"
	MonsterSpeciesOgre         MonsterSpecies = "ogre"
	MonsterSpeciesPhantom      MonsterSpecies = "phantom"
	MonsterSpeciesPiranha      MonsterSpecies = "piranha"
	MonsterSpeciesPlant        MonsterSpecies = "plant"
	MonsterSpeciesReptile      MonsterSpecies = "reptile"
	MonsterSpeciesRoc          MonsterSpecies = "roc"
	MonsterSpeciesRuminant     MonsterSpecies = "ruminant"
	MonsterSpeciesSacredBeast  MonsterSpecies = "sacred-beast"
	MonsterSpeciesSahagin      MonsterSpecies = "sahagin"
	MonsterSpeciesSin          MonsterSpecies = "sin"
	MonsterSpeciesSinspawn     MonsterSpecies = "sinspawn"
	MonsterSpeciesSpellspinner MonsterSpecies = "spellspinner"
	MonsterSpeciesSpiritBeast  MonsterSpecies = "spirit-beast"
	MonsterSpeciesTonberry     MonsterSpecies = "tonberry"
	MonsterSpeciesUnspecified  MonsterSpecies = "unspecified"
	MonsterSpeciesWasp         MonsterSpecies = "wasp"
	MonsterSpeciesWeapon       MonsterSpecies = "weapon"
	MonsterSpeciesWorm         MonsterSpecies = "worm"
	MonsterSpeciesWyrm         MonsterSpecies = "wyrm"
)

func (e *MonsterSpecies) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MonsterSpecies(s)
	case string:
		*e = MonsterSpecies(s)
	default:
		return fmt.Errorf("unsupported scan type for MonsterSpecies: %T", src)
	}
	return nil
}

type NullMonsterSpecies struct {
	MonsterSpecies MonsterSpecies
	Valid          bool // Valid is true if MonsterSpecies is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMonsterSpecies) Scan(value interface{}) error {
	if value == nil {
		ns.MonsterSpecies, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MonsterSpecies.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMonsterSpecies) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MonsterSpecies), nil
}

type MusicUseCase string

const (
	MusicUseCaseBlitzballGame          MusicUseCase = "blitzball-game"
	MusicUseCaseBlitzballMenu          MusicUseCase = "blitzball-menu"
	MusicUseCaseBossBattleDefault      MusicUseCase = "boss-battle-default"
	MusicUseCaseChocobo                MusicUseCase = "chocobo"
	MusicUseCaseGameOver               MusicUseCase = "game-over"
	MusicUseCaseMainMenu               MusicUseCase = "main-menu"
	MusicUseCaseRandomEncounterDefault MusicUseCase = "random-encounter-default"
	MusicUseCaseVictory                MusicUseCase = "victory"
)

func (e *MusicUseCase) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MusicUseCase(s)
	case string:
		*e = MusicUseCase(s)
	default:
		return fmt.Errorf("unsupported scan type for MusicUseCase: %T", src)
	}
	return nil
}

type NullMusicUseCase struct {
	MusicUseCase MusicUseCase
	Valid        bool // Valid is true if MusicUseCase is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMusicUseCase) Scan(value interface{}) error {
	if value == nil {
		ns.MusicUseCase, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MusicUseCase.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMusicUseCase) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MusicUseCase), nil
}

type NullifyArmored string

const (
	NullifyArmoredTarget NullifyArmored = "target"
	NullifyArmoredBearer NullifyArmored = "bearer"
)

func (e *NullifyArmored) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = NullifyArmored(s)
	case string:
		*e = NullifyArmored(s)
	default:
		return fmt.Errorf("unsupported scan type for NullifyArmored: %T", src)
	}
	return nil
}

type NullNullifyArmored struct {
	NullifyArmored NullifyArmored
	Valid          bool // Valid is true if NullifyArmored is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullNullifyArmored) Scan(value interface{}) error {
	if value == nil {
		ns.NullifyArmored, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.NullifyArmored.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullNullifyArmored) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.NullifyArmored), nil
}

type OverdriveModeType string

const (
	OverdriveModeTypeFormula   OverdriveModeType = "formula"
	OverdriveModeTypePerAction OverdriveModeType = "per-action"
)

func (e *OverdriveModeType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = OverdriveModeType(s)
	case string:
		*e = OverdriveModeType(s)
	default:
		return fmt.Errorf("unsupported scan type for OverdriveModeType: %T", src)
	}
	return nil
}

type NullOverdriveModeType struct {
	OverdriveModeType OverdriveModeType
	Valid             bool // Valid is true if OverdriveModeType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullOverdriveModeType) Scan(value interface{}) error {
	if value == nil {
		ns.OverdriveModeType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.OverdriveModeType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullOverdriveModeType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.OverdriveModeType), nil
}

type QuestType string

const (
	QuestTypeSidequest QuestType = "sidequest"
	QuestTypeSubquest  QuestType = "subquest"
)

func (e *QuestType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = QuestType(s)
	case string:
		*e = QuestType(s)
	default:
		return fmt.Errorf("unsupported scan type for QuestType: %T", src)
	}
	return nil
}

type NullQuestType struct {
	QuestType QuestType
	Valid     bool // Valid is true if QuestType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullQuestType) Scan(value interface{}) error {
	if value == nil {
		ns.QuestType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.QuestType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullQuestType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.QuestType), nil
}

type ShopCategory string

const (
	ShopCategoryStandard     ShopCategory = "standard"
	ShopCategoryOaka         ShopCategory = "oaka"
	ShopCategoryTravelAgency ShopCategory = "travel-agency"
	ShopCategoryWantz        ShopCategory = "wantz"
)

func (e *ShopCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ShopCategory(s)
	case string:
		*e = ShopCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for ShopCategory: %T", src)
	}
	return nil
}

type NullShopCategory struct {
	ShopCategory ShopCategory
	Valid        bool // Valid is true if ShopCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullShopCategory) Scan(value interface{}) error {
	if value == nil {
		ns.ShopCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ShopCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullShopCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ShopCategory), nil
}

type ShopType string

const (
	ShopTypePreAirship  ShopType = "pre-airship"
	ShopTypePostAirship ShopType = "post-airship"
)

func (e *ShopType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ShopType(s)
	case string:
		*e = ShopType(s)
	default:
		return fmt.Errorf("unsupported scan type for ShopType: %T", src)
	}
	return nil
}

type NullShopType struct {
	ShopType ShopType
	Valid    bool // Valid is true if ShopType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullShopType) Scan(value interface{}) error {
	if value == nil {
		ns.ShopType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ShopType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullShopType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ShopType), nil
}

type SpecialActionType string

const (
	SpecialActionTypeBribe             SpecialActionType = "bribe"
	SpecialActionTypeStealGil          SpecialActionType = "steal-gil"
	SpecialActionTypeStealItem         SpecialActionType = "steal-item"
	SpecialActionTypeTransferOverdrive SpecialActionType = "transfer-overdrive"
)

func (e *SpecialActionType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SpecialActionType(s)
	case string:
		*e = SpecialActionType(s)
	default:
		return fmt.Errorf("unsupported scan type for SpecialActionType: %T", src)
	}
	return nil
}

type NullSpecialActionType struct {
	SpecialActionType SpecialActionType
	Valid             bool // Valid is true if SpecialActionType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSpecialActionType) Scan(value interface{}) error {
	if value == nil {
		ns.SpecialActionType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SpecialActionType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSpecialActionType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SpecialActionType), nil
}

type TargetType string

const (
	TargetTypeSelf            TargetType = "self"
	TargetTypeSingleCharacter TargetType = "single-character"
	TargetTypeSingleEnemy     TargetType = "single-enemy"
	TargetTypeSingleTarget    TargetType = "single-target"
	TargetTypeRandomCharacter TargetType = "random-character"
	TargetTypeRandomEnemy     TargetType = "random-enemy"
	TargetTypeAllCharacters   TargetType = "all-characters"
	TargetTypeAllEnemies      TargetType = "all-enemies"
	TargetTypeTargetParty     TargetType = "target-party"
	TargetTypeNTargets        TargetType = "n-targets"
	TargetTypeEveryone        TargetType = "everyone"
)

func (e *TargetType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TargetType(s)
	case string:
		*e = TargetType(s)
	default:
		return fmt.Errorf("unsupported scan type for TargetType: %T", src)
	}
	return nil
}

type NullTargetType struct {
	TargetType TargetType
	Valid      bool // Valid is true if TargetType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTargetType) Scan(value interface{}) error {
	if value == nil {
		ns.TargetType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TargetType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTargetType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TargetType), nil
}

type TopmenuType string

const (
	TopmenuTypeMain   TopmenuType = "main"
	TopmenuTypeLeft   TopmenuType = "left"
	TopmenuTypeRight  TopmenuType = "right"
	TopmenuTypeHidden TopmenuType = "hidden"
)

func (e *TopmenuType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TopmenuType(s)
	case string:
		*e = TopmenuType(s)
	default:
		return fmt.Errorf("unsupported scan type for TopmenuType: %T", src)
	}
	return nil
}

type NullTopmenuType struct {
	TopmenuType TopmenuType
	Valid       bool // Valid is true if TopmenuType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTopmenuType) Scan(value interface{}) error {
	if value == nil {
		ns.TopmenuType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TopmenuType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTopmenuType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TopmenuType), nil
}

type TreasureType string

const (
	TreasureTypeChest  TreasureType = "chest"
	TreasureTypeGift   TreasureType = "gift"
	TreasureTypeObject TreasureType = "object"
)

func (e *TreasureType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TreasureType(s)
	case string:
		*e = TreasureType(s)
	default:
		return fmt.Errorf("unsupported scan type for TreasureType: %T", src)
	}
	return nil
}

type NullTreasureType struct {
	TreasureType TreasureType
	Valid        bool // Valid is true if TreasureType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTreasureType) Scan(value interface{}) error {
	if value == nil {
		ns.TreasureType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TreasureType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTreasureType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TreasureType), nil
}

type UnitType string

const (
	UnitTypeAeon      UnitType = "aeon"
	UnitTypeCharacter UnitType = "character"
)

func (e *UnitType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UnitType(s)
	case string:
		*e = UnitType(s)
	default:
		return fmt.Errorf("unsupported scan type for UnitType: %T", src)
	}
	return nil
}

type NullUnitType struct {
	UnitType UnitType
	Valid    bool // Valid is true if UnitType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUnitType) Scan(value interface{}) error {
	if value == nil {
		ns.UnitType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UnitType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUnitType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UnitType), nil
}

type WeaponType string

const (
	WeaponTypeSword        WeaponType = "sword"
	WeaponTypeStaff        WeaponType = "staff"
	WeaponTypeBlitzball    WeaponType = "blitzball"
	WeaponTypeDoll         WeaponType = "doll"
	WeaponTypeSpear        WeaponType = "spear"
	WeaponTypeBlade        WeaponType = "blade"
	WeaponTypeClaw         WeaponType = "claw"
	WeaponTypeSeymourStaff WeaponType = "seymour-staff"
)

func (e *WeaponType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = WeaponType(s)
	case string:
		*e = WeaponType(s)
	default:
		return fmt.Errorf("unsupported scan type for WeaponType: %T", src)
	}
	return nil
}

type NullWeaponType struct {
	WeaponType WeaponType
	Valid      bool // Valid is true if WeaponType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullWeaponType) Scan(value interface{}) error {
	if value == nil {
		ns.WeaponType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.WeaponType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullWeaponType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.WeaponType), nil
}

type Ability struct {
	ID            int32
	DataHash      string
	Name          string
	Version       sql.NullInt32
	Specification sql.NullString
	AttributesID  sql.NullInt32
	Type          AbilityType
}

type AbilityAccuracy struct {
	ID          int32
	DataHash    string
	AccSource   AccSourceType
	HitChance   interface{}
	AccModifier sql.NullFloat64
}

type AbilityAttribute struct {
	ID               int32
	DataHash         string
	Rank             sql.NullInt32
	AppearsInHelpBar bool
	CanCopycat       bool
}

type AbilityDamage struct {
	ID             int32
	DataHash       string
	Condition      sql.NullString
	AttackType     AttackType
	StatID         int32
	DamageType     DamageType
	DamageFormula  DamageFormula
	DamageConstant interface{}
}

type Aeon struct {
	ID                    int32
	DataHash              string
	UnitID                int32
	UnlockCondition       string
	IsOptional            bool
	BattlesToRegenerate   int32
	PhysAtkDamageConstant sql.NullInt32
	PhysAtkRange          interface{}
	PhysAtkShatterRate    interface{}
	AreaID                sql.NullInt32
	AccuracyID            sql.NullInt32
}

type AeonCommand struct {
	ID          int32
	DataHash    string
	Name        string
	Description string
	Effect      string
	Topmenu     TopmenuType
	Cursor      NullTargetType
	SubmenuID   sql.NullInt32
}

type AeonEquipment struct {
	ID            int32
	DataHash      string
	AutoAbilityID int32
	CelestialWpn  bool
	EquipType     EquipType
}

type Affinity struct {
	ID           int32
	DataHash     string
	Name         string
	DamageFactor sql.NullFloat64
}

type AgilitySubtier struct {
	ID                int32
	DataHash          string
	AgilityTierID     int32
	SubtierMinAgility interface{}
	SubtierMaxAgility interface{}
	CharacterMinIcv   sql.NullInt32
}

type AgilityTier struct {
	ID              int32
	DataHash        string
	MinAgility      interface{}
	MaxAgility      interface{}
	TickSpeed       int32
	MonsterMinIcv   sql.NullInt32
	MonsterMaxIcv   sql.NullInt32
	CharacterMaxIcv sql.NullInt32
}

type AltStateChange struct {
	ID             int32
	DataHash       string
	AlteredStateID int32
	AlterationType AlterationType
	Distance       interface{}
}

type AlteredState struct {
	ID          int32
	DataHash    string
	MonsterID   int32
	Condition   string
	IsTemporary bool
}

type Area struct {
	ID                   int32
	DataHash             string
	SubLocationID        int32
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	StoryOnly            bool
	HasSaveSphere        bool
	AirshipDropOff       bool
	HasCompilationSphere bool
	CanRideChocobo       bool
}

type AreaConnection struct {
	ID             int32
	DataHash       string
	AreaID         int32
	ConnectionType AreaConnectionType
	StoryOnly      bool
	Notes          sql.NullString
}

type AutoAbility struct {
	ID                   int32
	DataHash             string
	Name                 string
	Description          sql.NullString
	Effect               string
	Type                 NullEquipType
	Category             AutoAbilityCategory
	AbilityValue         sql.NullInt32
	ActivationCondition  NullAaActivationCondition
	Counter              NullCounterType
	RequiredItemAmountID sql.NullInt32
	GradRcvryStatID      sql.NullInt32
	OnHitElementID       sql.NullInt32
	AddedElemResistID    sql.NullInt32
	OnHitStatusID        sql.NullInt32
	AddedPropertyID      sql.NullInt32
	CnvrsnFromModID      sql.NullInt32
	CnvrsnToModID        sql.NullInt32
}

type BackgroundMusic struct {
	ID                     int32
	DataHash               string
	Condition              sql.NullString
	ReplacesEncounterMusic bool
}

type BaseStat struct {
	ID       int32
	DataHash string
	StatID   int32
	Value    int32
}

type BattleInteraction struct {
	ID                int32
	DataHash          string
	Target            TargetType
	BasedOnPhysAttack bool
	Range             interface{}
	ShatterRate       interface{}
	AccuracyID        int32
	HitAmount         int32
	SpecialAction     NullSpecialActionType
	DamageID          sql.NullInt32
}

type BlitzballItem struct {
	ID             int32
	DataHash       string
	PositionID     int32
	PossibleItemID int32
}

type BlitzballPosition struct {
	ID       int32
	DataHash string
	Category BlitzballTournamentCategory
	Slot     BlitzballPositionSlot
}

type CelestialWeapon struct {
	ID          int32
	DataHash    string
	Name        string
	KeyItemBase KeyItemBase
	Formula     CelestialFormula
	CharacterID sql.NullInt32
	AeonID      sql.NullInt32
}

type Character struct {
	ID                  int32
	DataHash            string
	UnitID              int32
	StoryOnly           bool
	WeaponType          WeaponType
	ArmorType           ArmorType
	PhysicalAttackRange interface{}
	CanFightUnderwater  bool
}

type CharacterClass struct {
	ID       int32
	DataHash string
	Name     string
}

type CompletionLocation struct {
	ID           int32
	DataHash     string
	CompletionID int32
	AreaID       int32
	Notes        sql.NullString
}

type Cue struct {
	ID                     int32
	DataHash               string
	SceneDescription       string
	AreaID                 sql.NullInt32
	ReplacesBgMusic        NullBgReplacementType
	EndTrigger             sql.NullString
	ReplacesEncounterMusic bool
}

type Damage struct {
	ID              int32
	DataHash        string
	Critical        NullCriticalType
	CriticalPlusVal sql.NullInt32
	IsPiercing      bool
	BreakDmgLimit   NullBreakDmgLmtType
	ElementID       sql.NullInt32
}

type DefaultAbility struct {
	ID        int32
	DataHash  string
	ClassID   int32
	AbilityID int32
}

type DefaultOverdriveAbility struct {
	ID        int32
	DataHash  string
	ClassID   int32
	AbilityID int32
}

type Element struct {
	ID                int32
	DataHash          string
	Name              string
	OppositeElementID sql.NullInt32
}

type ElementalResist struct {
	ID         int32
	DataHash   string
	ElementID  int32
	AffinityID int32
}

type EncounterLocation struct {
	ID       int32
	DataHash string
	Version  sql.NullInt32
	AreaID   int32
	Notes    sql.NullString
}

type EnemyAbility struct {
	ID        int32
	DataHash  string
	AbilityID int32
	Effect    sql.NullString
}

type EquipmentDrop struct {
	ID            int32
	DataHash      string
	AutoAbilityID int32
	IsForced      bool
	Probability   interface{}
}

type EquipmentName struct {
	ID          int32
	DataHash    string
	CharacterID int32
	Name        string
}

type EquipmentSlotsChance struct {
	ID       int32
	DataHash string
	Amount   interface{}
	Chance   interface{}
}

type EquipmentTable struct {
	ID                  int32
	DataHash            string
	Type                EquipType
	Classification      EquipClass
	SpecificCharacterID sql.NullInt32
	Version             sql.NullInt32
	Priority            sql.NullInt32
	Pool1Amt            sql.NullInt32
	Pool2Amt            sql.NullInt32
	EmptySlotsAmt       interface{}
}

type Fmv struct {
	ID                  int32
	DataHash            string
	Name                string
	Translation         sql.NullString
	CutsceneDescription string
	SongID              sql.NullInt32
	AreaID              int32
}

type FormationBossSong struct {
	ID               int32
	DataHash         string
	SongID           int32
	CelebrateVictory bool
}

type FoundEquipmentPiece struct {
	ID               int32
	DataHash         string
	EquipmentNameID  int32
	EmptySlotsAmount interface{}
}

type InflictedDelay struct {
	ID             int32
	DataHash       string
	Condition      sql.NullString
	CtbAttackType  CtbAttackType
	DelayType      DelayType
	DamageConstant interface{}
}

type InflictedStatuss struct {
	ID                int32
	DataHash          string
	StatusConditionID int32
	Probability       interface{}
	DurationType      DurationType
	Amount            sql.NullInt32
}

type Item struct {
	ID                    int32
	DataHash              string
	MasterItemID          int32
	Description           string
	Effect                string
	SphereGridDescription sql.NullString
	Category              ItemCategory
	Usability             NullItemUsability
	BasePrice             sql.NullInt32
	SellValue             int32
}

type ItemAbility struct {
	ID        int32
	DataHash  string
	ItemID    int32
	AbilityID int32
	Cursor    TargetType
}

type ItemAmount struct {
	ID           int32
	DataHash     string
	MasterItemID int32
	Amount       int32
}

type JAbilitiesBattleInteraction struct {
	ID                  int32
	DataHash            string
	AbilityID           int32
	BattleInteractionID int32
}

type JAeonCommandsPossibleAbility struct {
	ID               int32
	DataHash         string
	AeonCommandID    int32
	AbilityID        int32
	CharacterClassID int32
}

type JAeonsBaseStat struct {
	ID         int32
	DataHash   string
	AeonID     int32
	BaseStatID int32
}

type JAeonsWeaponArmor struct {
	ID              int32
	DataHash        string
	AeonID          int32
	AeonEquipmentID int32
}

type JAltStateChangesAddedStatuss struct {
	ID                int32
	DataHash          string
	AltStateChangeID  int32
	InflictedStatusID int32
}

type JAltStateChangesAutoAbility struct {
	ID               int32
	DataHash         string
	AltStateChangeID int32
	AutoAbilityID    int32
}

type JAltStateChangesElemResist struct {
	ID               int32
	DataHash         string
	AltStateChangeID int32
	ElemResistID     int32
}

type JAltStateChangesProperty struct {
	ID               int32
	DataHash         string
	AltStateChangeID int32
	PropertyID       int32
}

type JAltStateChangesStat struct {
	ID               int32
	DataHash         string
	AltStateChangeID int32
	BaseStatID       int32
}

type JAltStateChangesStatusImmunity struct {
	ID                int32
	DataHash          string
	AltStateChangeID  int32
	StatusConditionID int32
}

type JAreaConnectedArea struct {
	ID           int32
	DataHash     string
	AreaID       int32
	ConnectionID int32
}

type JAutoAbilitiesAddedStatusResist struct {
	ID             int32
	DataHash       string
	AutoAbilityID  int32
	StatusResistID int32
}

type JAutoAbilitiesAddedStatuss struct {
	ID                int32
	DataHash          string
	AutoAbilityID     int32
	StatusConditionID int32
}

type JAutoAbilitiesLockedOut struct {
	ID              int32
	DataHash        string
	ParentAbilityID int32
	ChildAbilityID  int32
}

type JAutoAbilitiesModifierChange struct {
	ID               int32
	DataHash         string
	AutoAbilityID    int32
	ModifierChangeID int32
}

type JAutoAbilitiesRelatedStat struct {
	ID            int32
	DataHash      string
	AutoAbilityID int32
	StatID        int32
}

type JAutoAbilitiesRequiredItem struct {
	ID            int32
	DataHash      string
	AutoAbilityID int32
	ItemID        int32
}

type JAutoAbilitiesStatChange struct {
	ID            int32
	DataHash      string
	AutoAbilityID int32
	StatChangeID  int32
}

type JBattleInteractionsAffectedBy struct {
	ID                  int32
	DataHash            string
	AbilityID           int32
	BattleInteractionID int32
	StatusConditionID   int32
}

type JBattleInteractionsCopiedStatusCondition struct {
	ID                  int32
	DataHash            string
	AbilityID           int32
	BattleInteractionID int32
	InflictedStatusID   int32
}

type JBattleInteractionsDamage struct {
	ID                  int32
	DataHash            string
	AbilityID           int32
	BattleInteractionID int32
	DamageID            int32
}

type JBattleInteractionsInflictedDelay struct {
	ID                  int32
	DataHash            string
	AbilityID           int32
	BattleInteractionID int32
	InflictedDelayID    int32
}

type JBattleInteractionsInflictedStatusCondition struct {
	ID                  int32
	DataHash            string
	AbilityID           int32
	BattleInteractionID int32
	InflictedStatusID   int32
}

type JBattleInteractionsModifierChange struct {
	ID                  int32
	DataHash            string
	AbilityID           int32
	BattleInteractionID int32
	ModifierChangeID    int32
}

type JBattleInteractionsRemovedStatusCondition struct {
	ID                  int32
	DataHash            string
	AbilityID           int32
	BattleInteractionID int32
	StatusConditionID   int32
}

type JBattleInteractionsStatChange struct {
	ID                  int32
	DataHash            string
	AbilityID           int32
	BattleInteractionID int32
	StatChangeID        int32
}

type JCharactersBaseStat struct {
	ID          int32
	DataHash    string
	CharacterID int32
	BaseStatID  int32
}

type JDamagesDamageCalc struct {
	ID                  int32
	DataHash            string
	AbilityID           int32
	BattleInteractionID int32
	DamageID            int32
	AbilityDamageID     int32
}

type JEncounterLocationFormation struct {
	ID                  int32
	DataHash            string
	EncounterLocationID int32
	MonsterFormationID  int32
}

type JEquipmentDropsCharacter struct {
	ID                 int32
	DataHash           string
	MonsterEquipmentID int32
	EquipmentDropID    int32
	CharacterID        int32
}

type JEquipmentTablesAbilityPool struct {
	ID               int32
	DataHash         string
	EquipmentTableID int32
	AutoAbilityID    int32
	AbilityPool      AutoAbilityPool
}

type JEquipmentTablesName struct {
	ID                int32
	DataHash          string
	EquipmentTableID  int32
	EquipmentNameID   int32
	CelestialWeaponID sql.NullInt32
}

type JFoundEquipmentAbility struct {
	ID               int32
	DataHash         string
	FoundEquipmentID int32
	AutoAbilityID    int32
}

type JItemsAvailableMenu struct {
	ID        int32
	DataHash  string
	ItemID    int32
	SubmenuID int32
}

type JItemsRelatedStat struct {
	ID       int32
	DataHash string
	ItemID   int32
	StatID   int32
}

type JMixesCombination struct {
	ID          int32
	DataHash    string
	MixID       int32
	ComboID     int32
	IsBestCombo bool
}

type JMonsterEquipmentSlotsChance struct {
	ID                 int32
	DataHash           string
	MonsterEquipmentID int32
	EquipmentSlotsID   int32
	SlotsChanceID      int32
}

type JMonsterFormationsMonster struct {
	ID                 int32
	DataHash           string
	MonsterFormationID int32
	MonsterAmountID    int32
}

type JMonsterFormationsTriggerCommand struct {
	ID                 int32
	DataHash           string
	MonsterFormationID int32
	TriggerCommandID   int32
}

type JMonsterItemsOtherItem struct {
	ID             int32
	DataHash       string
	MonsterItemsID int32
	PossibleItemID int32
}

type JMonstersAbility struct {
	ID               int32
	DataHash         string
	MonsterID        int32
	MonsterAbilityID int32
}

type JMonstersAutoAbility struct {
	ID            int32
	DataHash      string
	MonsterID     int32
	AutoAbilityID int32
}

type JMonstersElemResist struct {
	ID           int32
	DataHash     string
	MonsterID    int32
	ElemResistID int32
}

type JMonstersImmunity struct {
	ID                int32
	DataHash          string
	MonsterID         int32
	StatusConditionID int32
}

type JMonstersProperty struct {
	ID         int32
	DataHash   string
	MonsterID  int32
	PropertyID int32
}

type JMonstersRonsoRage struct {
	ID          int32
	DataHash    string
	MonsterID   int32
	RonsoRageID int32
}

type JMonstersStat struct {
	ID         int32
	DataHash   string
	MonsterID  int32
	BaseStatID int32
}

type JMonstersStatusResistance struct {
	ID             int32
	DataHash       string
	MonsterID      int32
	StatusResistID int32
}

type JOverdriveAbilitiesRelatedStat struct {
	ID                 int32
	DataHash           string
	OverdriveAbilityID int32
	StatID             int32
}

type JOverdriveModesActionsToLearn struct {
	ID              int32
	DataHash        string
	OverdriveModeID int32
	ActionID        int32
}

type JOverdrivesOverdriveAbility struct {
	ID                 int32
	DataHash           string
	OverdriveID        int32
	OverdriveAbilityID int32
}

type JPlayerAbilitiesLearnedBy struct {
	ID               int32
	DataHash         string
	PlayerAbilityID  int32
	CharacterClassID int32
}

type JPlayerAbilitiesRelatedStat struct {
	ID              int32
	DataHash        string
	PlayerAbilityID int32
	StatID          int32
}

type JPlayerUnitsCharacterClass struct {
	ID       int32
	DataHash string
	UnitID   int32
	ClassID  int32
}

type JPropertiesModifierChange struct {
	ID               int32
	DataHash         string
	PropertyID       int32
	ModifierChangeID int32
}

type JPropertiesRelatedStat struct {
	ID         int32
	DataHash   string
	PropertyID int32
	StatID     int32
}

type JPropertiesRemovedStatusCondition struct {
	ID                int32
	DataHash          string
	PropertyID        int32
	StatusConditionID int32
}

type JPropertiesStatChange struct {
	ID           int32
	DataHash     string
	PropertyID   int32
	StatChangeID int32
}

type JShopsEquipment struct {
	ID              int32
	DataHash        string
	ShopID          int32
	ShopEquipmentID int32
	ShopType        ShopType
}

type JShopsItem struct {
	ID         int32
	DataHash   string
	ShopID     int32
	ShopItemID int32
	ShopType   ShopType
}

type JSongsBackgroundMusic struct {
	ID       int32
	DataHash string
	SongID   int32
	BmID     int32
	AreaID   int32
}

type JSongsCue struct {
	ID       int32
	DataHash string
	SongID   int32
	CueID    int32
	AreaID   int32
}

type JStatusConditionsModifierChange struct {
	ID                int32
	DataHash          string
	StatusConditionID int32
	ModifierChangeID  int32
}

type JStatusConditionsRelatedStat struct {
	ID                int32
	DataHash          string
	StatusConditionID int32
	StatID            int32
}

type JStatusConditionsRemovedStatusCondition struct {
	ID                int32
	DataHash          string
	ParentConditionID int32
	ChildConditionID  int32
}

type JStatusConditionsStatChange struct {
	ID                int32
	DataHash          string
	StatusConditionID int32
	StatChangeID      int32
}

type JSubmenusUser struct {
	ID               int32
	DataHash         string
	SubmenuID        int32
	CharacterClassID int32
}

type JTreasuresItem struct {
	ID           int32
	DataHash     string
	TreasureID   int32
	ItemAmountID int32
}

type JTriggerCommandsRelatedStat struct {
	ID               int32
	DataHash         string
	TriggerCommandID int32
	StatID           int32
}

type KeyItem struct {
	ID           int32
	DataHash     string
	MasterItemID int32
	Category     KeyItemCategory
	Description  string
	Effect       string
}

type Location struct {
	ID       int32
	DataHash string
	Name     string
}

type MasterItem struct {
	ID       int32
	DataHash string
	Name     string
	Type     ItemType
}

type Mix struct {
	ID          int32
	DataHash    string
	OverdriveID int32
	Category    MixCategory
}

type MixCombination struct {
	ID           int32
	DataHash     string
	FirstItemID  int32
	SecondItemID int32
}

type Modifier struct {
	ID           int32
	DataHash     string
	Name         string
	Effect       string
	Type         ModifierType
	DefaultValue sql.NullFloat64
}

type ModifierChange struct {
	ID              int32
	DataHash        string
	ModifierID      int32
	CalculationType CalculationType
	Value           float32
}

type Monster struct {
	ID                   int32
	DataHash             string
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	Notes                sql.NullString
	Species              MonsterSpecies
	IsStoryBased         bool
	CanBeCaptured        bool
	AreaConquestLocation NullMaCreationArea
	CtbIconType          CtbIconType
	HasOverdrive         bool
	IsUnderwater         bool
	IsZombie             bool
	Distance             interface{}
	Ap                   int32
	ApOverkill           int32
	OverkillDamage       int32
	Gil                  int32
	StealGil             sql.NullInt32
	DoomCountdown        interface{}
	PoisonRate           interface{}
	ThreatenChance       interface{}
	ZanmatoLevel         interface{}
	MonsterArenaPrice    sql.NullInt32
	SensorText           string
	ScanText             sql.NullString
}

type MonsterAbility struct {
	ID        int32
	DataHash  string
	AbilityID int32
	IsForced  bool
	IsUnused  bool
}

type MonsterAmount struct {
	ID        int32
	DataHash  string
	MonsterID int32
	Amount    int32
}

type MonsterArenaCreation struct {
	ID                        int32
	DataHash                  string
	SubquestID                int32
	Category                  MaCreationCategory
	RequiredArea              NullMaCreationArea
	RequiredSpecies           NullMaCreationSpecies
	UnderwaterOnly            bool
	CreationsUnlockedCategory NullCreationsUnlockedCategory
	Amount                    int32
}

type MonsterEquipment struct {
	ID                  int32
	DataHash            string
	MonsterID           int32
	DropChance          interface{}
	Power               interface{}
	CriticalPlus        int32
	AbilitySlotsID      int32
	AttachedAbilitiesID int32
}

type MonsterEquipmentSlot struct {
	ID        int32
	DataHash  string
	MinAmount interface{}
	MaxAmount interface{}
}

type MonsterFormation struct {
	ID                  int32
	DataHash            string
	EncounterLocationID int32
	Category            MonsterFormationCategory
	IsForcedAmbush      bool
	CanEscape           bool
	BossSongID          sql.NullInt32
	Notes               sql.NullString
}

type MonsterItem struct {
	ID                    int32
	DataHash              string
	MonsterID             int32
	DropChance            interface{}
	DropCondition         sql.NullString
	OtherItemsCondition   sql.NullString
	StealCommonID         sql.NullInt32
	StealRareID           sql.NullInt32
	DropCommonID          sql.NullInt32
	DropRareID            sql.NullInt32
	SecondaryDropCommonID sql.NullInt32
	SecondaryDropRareID   sql.NullInt32
	BribeID               sql.NullInt32
}

type OdModeAction struct {
	ID       int32
	DataHash string
	UserID   int32
	Amount   int32
}

type Overdrife struct {
	ID               int32
	DataHash         string
	Name             string
	Version          sql.NullInt32
	Description      string
	Effect           string
	Topmenu          NullTopmenuType
	AttributesID     int32
	UnlockCondition  sql.NullString
	CountdownInSec   sql.NullInt32
	Cursor           NullTargetType
	OdCommandID      sql.NullInt32
	CharacterClassID sql.NullInt32
}

type OverdriveAbility struct {
	ID        int32
	DataHash  string
	AbilityID int32
}

type OverdriveCommand struct {
	ID               int32
	DataHash         string
	Name             string
	Description      string
	Rank             int32
	Topmenu          TopmenuType
	CharacterClassID sql.NullInt32
	SubmenuID        sql.NullInt32
}

type OverdriveMode struct {
	ID          int32
	DataHash    string
	Name        string
	Description string
	Effect      string
	Type        OverdriveModeType
	FillRate    interface{}
}

type PlayerAbility struct {
	ID                  int32
	DataHash            string
	AbilityID           int32
	Description         sql.NullString
	Effect              string
	Topmenu             NullTopmenuType
	CanUseOutsideBattle bool
	MpCost              sql.NullInt32
	Cursor              NullTargetType
	SubmenuID           sql.NullInt32
	OpenSubmenuID       sql.NullInt32
	StandardGridCharID  sql.NullInt32
	ExpertGridCharID    sql.NullInt32
	AeonLearnItemID     sql.NullInt32
}

type PlayerUnit struct {
	ID       int32
	DataHash string
	Name     string
	Type     UnitType
}

type PossibleItem struct {
	ID           int32
	DataHash     string
	ItemAmountID int32
	Chance       interface{}
}

type Primer struct {
	ID            int32
	DataHash      string
	KeyItemID     int32
	AlBhedLetter  string
	EnglishLetter string
}

type Property struct {
	ID             int32
	DataHash       string
	Name           string
	Effect         string
	NullifyArmored NullNullifyArmored
}

type Quest struct {
	ID       int32
	DataHash string
	Name     string
	Type     QuestType
}

type QuestCompletion struct {
	ID           int32
	DataHash     string
	QuestID      int32
	Condition    string
	ItemAmountID int32
}

type Shop struct {
	ID       int32
	DataHash string
	Version  sql.NullInt32
	AreaID   int32
	Notes    sql.NullString
	Category ShopCategory
}

type ShopEquipmentPiece struct {
	ID               int32
	DataHash         string
	FoundEquipmentID int32
	Price            int32
}

type ShopItem struct {
	ID       int32
	DataHash string
	ItemID   int32
	Price    int32
}

type Sidequest struct {
	ID       int32
	DataHash string
	QuestID  int32
}

type Song struct {
	ID                   int32
	DataHash             string
	Name                 string
	StreamingName        sql.NullString
	InGameName           sql.NullString
	OstName              sql.NullString
	Translation          sql.NullString
	StreamingTrackNumber sql.NullInt32
	MusicSphereID        sql.NullInt32
	OstDisc              interface{}
	OstTrackNumber       sql.NullInt32
	DurationInSeconds    int32
	CanLoop              bool
	SpecialUseCase       NullMusicUseCase
	CreditsID            sql.NullInt32
}

type SongCredit struct {
	ID        int32
	DataHash  string
	Composer  sql.NullString
	Arranger  sql.NullString
	Performer sql.NullString
	Lyricist  sql.NullString
}

type Stat struct {
	ID       int32
	DataHash string
	Name     string
	Effect   string
	MinVal   int32
	MaxVal   int32
	MaxVal2  sql.NullInt32
	SphereID sql.NullInt32
}

type StatChange struct {
	ID              int32
	DataHash        string
	StatID          int32
	CalculationType CalculationType
	Value           float32
}

type StatusCondition struct {
	ID             int32
	DataHash       string
	Name           string
	Effect         string
	Visualization  sql.NullString
	NullifyArmored NullNullifyArmored
}

type StatusResist struct {
	ID                int32
	DataHash          string
	StatusConditionID int32
	Resistance        interface{}
}

type SubLocation struct {
	ID            int32
	DataHash      string
	LocationID    int32
	Name          string
	Specification sql.NullString
}

type Submenu struct {
	ID          int32
	DataHash    string
	Name        string
	Description string
	Effect      string
	Topmenu     NullTopmenuType
}

type Subquest struct {
	ID                int32
	DataHash          string
	QuestID           int32
	ParentSidequestID int32
}

type Treasure struct {
	ID               int32
	DataHash         string
	AreaID           int32
	Version          int32
	TreasureType     TreasureType
	LootType         LootType
	IsPostAirship    bool
	IsAnimaTreasure  bool
	Notes            sql.NullString
	GilAmount        sql.NullInt32
	FoundEquipmentID sql.NullInt32
}

type TriggerCommand struct {
	ID          int32
	DataHash    string
	AbilityID   int32
	Description string
	Effect      string
	Topmenu     TopmenuType
	Cursor      TargetType
}

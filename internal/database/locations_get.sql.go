// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: locations_get.sql

package database

import (
	"context"
	"database/sql"
)

const getAreaAeonIDs = `-- name: GetAreaAeonIDs :many
SELECT ae.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN aeons ae ON ae.area_id = a.id
JOIN player_units pu ON ae.unit_id = pu.id
WHERE a.id = $1
ORDER BY ae.id
`

func (q *Queries) GetAreaAeonIDs(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaAeonIDs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaBackgroundMusic = `-- name: GetAreaBackgroundMusic :many
SELECT so.id, bm.replaces_encounter_music
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN j_songs_background_music j ON j.area_id = a.id 
JOIN background_music bm ON j.bm_id = bm.id
JOIN songs so ON j.song_id = so.id
WHERE a.id = $1
ORDER BY so.id
`

type GetAreaBackgroundMusicRow struct {
	ID                     int32
	ReplacesEncounterMusic bool
}

func (q *Queries) GetAreaBackgroundMusic(ctx context.Context, id int32) ([]GetAreaBackgroundMusicRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreaBackgroundMusic, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreaBackgroundMusicRow
	for rows.Next() {
		var i GetAreaBackgroundMusicRow
		if err := rows.Scan(&i.ID, &i.ReplacesEncounterMusic); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaBossSongIDs = `-- name: GetAreaBossSongIDs :many
SELECT DISTINCT so.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN encounter_locations el ON el.area_id = a.id
JOIN j_encounter_location_formations j ON j.encounter_location_id = el.id
JOIN monster_formations mf ON j.monster_formation_id = mf.id
JOIN formation_boss_songs bs ON mf.boss_song_id = bs.id
JOIN songs so ON bs.song_id = so.id
WHERE a.id = $1
ORDER BY so.id
`

func (q *Queries) GetAreaBossSongIDs(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaBossSongIDs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaCharacterIDs = `-- name: GetAreaCharacterIDs :many
SELECT c.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN characters c ON c.area_id = a.id
JOIN player_units pu ON c.unit_id = pu.id
WHERE a.id = $1
ORDER BY c.id
`

func (q *Queries) GetAreaCharacterIDs(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaCharacterIDs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaConnectionIDs = `-- name: GetAreaConnectionIDs :many
SELECT a.id
FROM area_connections ac
JOIN j_area_connected_areas j ON j.connection_id = ac.id
JOIN areas a ON ac.area_id = a.id
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN areas a2 ON j.area_id = a2.id
WHERE a2.id = $1
ORDER BY a.id
`

func (q *Queries) GetAreaConnectionIDs(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaConnectionIDs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaCues = `-- name: GetAreaCues :many
SELECT DISTINCT so.id, c.replaces_encounter_music
FROM cues c
JOIN songs so ON c.song_id = so.id
JOIN j_songs_cues j ON j.cue_id = c.id
JOIN areas a ON COALESCE(c.trigger_area_id, j.included_area_id) = a.id
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
WHERE j.included_area_id = $1 OR c.trigger_area_id = $1
ORDER BY so.id
`

type GetAreaCuesRow struct {
	ID                     int32
	ReplacesEncounterMusic bool
}

func (q *Queries) GetAreaCues(ctx context.Context, includedAreaID int32) ([]GetAreaCuesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreaCues, includedAreaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreaCuesRow
	for rows.Next() {
		var i GetAreaCuesRow
		if err := rows.Scan(&i.ID, &i.ReplacesEncounterMusic); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaFMVSongIDs = `-- name: GetAreaFMVSongIDs :many
SELECT DISTINCT so.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN fmvs f ON f.area_id = a.id
JOIN songs so ON f.song_id = so.id
WHERE a.id = $1
ORDER BY so.id
`

func (q *Queries) GetAreaFMVSongIDs(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaFMVSongIDs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaFmvIDs = `-- name: GetAreaFmvIDs :many
SELECT f.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN fmvs f ON f.area_id = a.id
WHERE a.id = $1
ORDER BY f.id
`

func (q *Queries) GetAreaFmvIDs(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaFmvIDs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDs = `-- name: GetAreaIDs :many
SELECT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id 
JOIN locations l ON s.location_id = l.id
`

func (q *Queries) GetAreaIDs(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsAeons = `-- name: GetAreaIDsAeons :many
SELECT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN aeons ae ON ae.area_id = a.id
JOIN player_units pu ON ae.unit_id = pu.id
ORDER BY a.id
`

func (q *Queries) GetAreaIDsAeons(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsAeons)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsBosses = `-- name: GetAreaIDsBosses :many
SELECT DISTINCT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN encounter_locations el ON el.area_id = a.id
JOIN j_encounter_location_formations j ON j.encounter_location_id = el.id
JOIN monster_formations mf ON j.monster_formation_id = mf.id
JOIN formation_boss_songs bs ON mf.boss_song_id = bs.id
JOIN songs so ON bs.song_id = so.id
ORDER BY a.id
`

func (q *Queries) GetAreaIDsBosses(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsBosses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsCharacters = `-- name: GetAreaIDsCharacters :many
SELECT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN characters c ON c.area_id = a.id
JOIN player_units pu ON c.unit_id = pu.id
ORDER BY a.id
`

func (q *Queries) GetAreaIDsCharacters(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsCharacters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsChocobo = `-- name: GetAreaIDsChocobo :many
SELECT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
WHERE a.can_ride_chocobo = $1
ORDER BY a.id
`

func (q *Queries) GetAreaIDsChocobo(ctx context.Context, canRideChocobo bool) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsChocobo, canRideChocobo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsFMVs = `-- name: GetAreaIDsFMVs :many
SELECT DISTINCT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN fmvs f ON f.area_id = a.id
ORDER BY a.id
`

func (q *Queries) GetAreaIDsFMVs(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsFMVs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsItemMonster = `-- name: GetAreaIDsItemMonster :many
SELECT DISTINCT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN encounter_locations el ON el.area_id = a.id
JOIN j_encounter_location_formations j1 ON j1.encounter_location_id = el.id
JOIN monster_formations mf ON j1.monster_formation_id = mf.id
JOIN j_monster_formations_monsters j2 ON j2.monster_formation_id = mf.id
JOIN monster_amounts ma ON j2.monster_amount_id = ma.id
JOIN monsters m ON ma.monster_id = m.id
JOIN monster_items mi ON mi.monster_id = m.id
LEFT JOIN j_monster_items_other_items jmio
  ON jmio.monster_items_id = mi.id
LEFT JOIN possible_items pi
  ON pi.id = jmio.possible_item_id
JOIN item_amounts ia
  ON ia.id IN (
      mi.steal_common_id,
      mi.steal_rare_id,
      mi.drop_common_id,
      mi.drop_rare_id,
      mi.secondary_drop_common_id,
      mi.secondary_drop_rare_id,
      mi.bribe_id,
      pi.item_amount_id
  )
JOIN master_items mit ON ia.master_item_id = mit.id
JOIN items i ON i.master_item_id = mit.id
WHERE i.id = $1
ORDER BY a.id
`

func (q *Queries) GetAreaIDsItemMonster(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsItemMonster, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsItemQuest = `-- name: GetAreaIDsItemQuest :many
SELECT DISTINCT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN completion_locations cl ON cl.area_id = a.id
JOIN quest_completions qc ON cl.completion_id = qc.id
JOIN item_amounts ia ON qc.item_amount_id = ia.id
JOIN master_items mi ON ia.master_item_id = mi.id
JOIN items i ON i.master_item_id = mi.id
WHERE i.id = $1
ORDER BY a.id
`

func (q *Queries) GetAreaIDsItemQuest(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsItemQuest, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsItemShop = `-- name: GetAreaIDsItemShop :many
SELECT DISTINCT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN shops sh ON sh.area_id = a.id
JOIN j_shops_items j ON j.shop_id = sh.id
JOIN shop_items si ON j.shop_item_id = si.id
JOIN items i ON si.item_id = i.id
WHERE i.id = $1
ORDER BY a.id
`

func (q *Queries) GetAreaIDsItemShop(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsItemShop, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsItemTreasure = `-- name: GetAreaIDsItemTreasure :many
SELECT DISTINCT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN treasures t ON t.area_id = a.id
JOIN j_treasures_items j ON j.treasure_id = t.id
JOIN item_amounts ia ON j.item_amount_id = ia.id
JOIN master_items mi ON ia.master_item_id = mi.id
JOIN items i ON i.master_item_id = mi.id
WHERE i.id = $1
ORDER BY a.id
`

func (q *Queries) GetAreaIDsItemTreasure(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsItemTreasure, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsKeyItemQuest = `-- name: GetAreaIDsKeyItemQuest :many
SELECT DISTINCT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN completion_locations cl ON cl.area_id = a.id
JOIN quest_completions qc ON cl.completion_id = qc.id
JOIN item_amounts ia ON qc.item_amount_id = ia.id
JOIN master_items mi ON ia.master_item_id = mi.id
JOIN key_items ki ON ki.master_item_id = mi.id
WHERE ki.id = $1
ORDER BY a.id
`

func (q *Queries) GetAreaIDsKeyItemQuest(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsKeyItemQuest, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsKeyItemTreasure = `-- name: GetAreaIDsKeyItemTreasure :many
SELECT DISTINCT a.id
FROM areas a
JOIN treasures t ON t.area_id = a.id
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN j_treasures_items j ON j.treasure_id = t.id
JOIN item_amounts ia ON j.item_amount_id = ia.id
JOIN master_items mi ON ia.master_item_id = mi.id
JOIN key_items ki ON ki.master_item_id = mi.id
WHERE ki.id = $1
ORDER BY a.id
`

func (q *Queries) GetAreaIDsKeyItemTreasure(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsKeyItemTreasure, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsMonsters = `-- name: GetAreaIDsMonsters :many
SELECT DISTINCT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN encounter_locations el ON el.area_id = a.id
JOIN j_encounter_location_formations j1 ON j1.encounter_location_id = el.id
JOIN monster_formations mf ON j1.monster_formation_id = mf.id
JOIN j_monster_formations_monsters j2 ON j2.monster_formation_id = mf.id
JOIN monster_amounts ma ON j2.monster_amount_id = ma.id
JOIN monsters m ON ma.monster_id = m.id
ORDER BY a.id
`

func (q *Queries) GetAreaIDsMonsters(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsMonsters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsShops = `-- name: GetAreaIDsShops :many
SELECT DISTINCT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN shops sh ON sh.area_id = a.id
ORDER BY a.id
`

func (q *Queries) GetAreaIDsShops(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsShops)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsSidequests = `-- name: GetAreaIDsSidequests :many
SELECT DISTINCT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN completion_locations cl ON cl.area_id = a.id
JOIN quest_completions qc ON cl.completion_id = qc.id
JOIN quests q ON qc.quest_id = q.id
ORDER BY a.id
`

func (q *Queries) GetAreaIDsSidequests(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsSidequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsStoryOnly = `-- name: GetAreaIDsStoryOnly :many
SELECT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
WHERE a.story_only = $1
ORDER BY a.id
`

func (q *Queries) GetAreaIDsStoryOnly(ctx context.Context, storyOnly bool) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsStoryOnly, storyOnly)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsTreasures = `-- name: GetAreaIDsTreasures :many
SELECT DISTINCT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN treasures t ON t.area_id = a.id
ORDER BY a.id
`

func (q *Queries) GetAreaIDsTreasures(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsTreasures)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsWithCompSphere = `-- name: GetAreaIDsWithCompSphere :many
SELECT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
WHERE a.has_compilation_sphere = $1
ORDER BY a.id
`

func (q *Queries) GetAreaIDsWithCompSphere(ctx context.Context, hasCompilationSphere bool) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsWithCompSphere, hasCompilationSphere)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsWithDropOff = `-- name: GetAreaIDsWithDropOff :many
SELECT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
WHERE a.airship_drop_off = $1
ORDER BY a.id
`

func (q *Queries) GetAreaIDsWithDropOff(ctx context.Context, airshipDropOff bool) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsWithDropOff, airshipDropOff)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsWithSaveSphere = `-- name: GetAreaIDsWithSaveSphere :many
SELECT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
WHERE a.has_save_sphere = $1
ORDER BY a.id
`

func (q *Queries) GetAreaIDsWithSaveSphere(ctx context.Context, hasSaveSphere bool) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsWithSaveSphere, hasSaveSphere)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaMonsterFormationIDs = `-- name: GetAreaMonsterFormationIDs :many
SELECT DISTINCT mf.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN encounter_locations el ON el.area_id = a.id
JOIN j_encounter_location_formations j ON j.encounter_location_id = el.id
JOIN monster_formations mf ON j.monster_formation_id = mf.id
WHERE a.id = $1
ORDER BY mf.id
`

func (q *Queries) GetAreaMonsterFormationIDs(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaMonsterFormationIDs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaMonsterIDs = `-- name: GetAreaMonsterIDs :many
SELECT DISTINCT m.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN encounter_locations el ON el.area_id = a.id
JOIN j_encounter_location_formations j1 ON j1.encounter_location_id = el.id
JOIN monster_formations mf ON j1.monster_formation_id = mf.id
JOIN j_monster_formations_monsters j2 ON j2.monster_formation_id = mf.id
JOIN monster_amounts ma ON j2.monster_amount_id = ma.id
JOIN monsters m ON ma.monster_id = m.id
WHERE a.id = $1
ORDER BY m.id
`

func (q *Queries) GetAreaMonsterIDs(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaMonsterIDs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaQuestIDs = `-- name: GetAreaQuestIDs :many
SELECT DISTINCT q.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN completion_locations cl ON cl.area_id = a.id
JOIN quest_completions qc ON cl.completion_id = qc.id
JOIN quests q ON qc.quest_id = q.id
WHERE a.id = $1
ORDER BY q.id
`

func (q *Queries) GetAreaQuestIDs(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaQuestIDs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaShopIDs = `-- name: GetAreaShopIDs :many
SELECT id FROM shops WHERE area_id = $1 ORDER BY id
`

func (q *Queries) GetAreaShopIDs(ctx context.Context, areaID int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaShopIDs, areaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaTreasureIDs = `-- name: GetAreaTreasureIDs :many
SELECT id FROM treasures WHERE area_id = $1 ORDER BY id
`

func (q *Queries) GetAreaTreasureIDs(ctx context.Context, areaID int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaTreasureIDs, areaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocationAreaIDs = `-- name: GetLocationAreaIDs :many
SELECT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id 
JOIN locations l ON s.location_id = l.id
WHERE l.id = $1
ORDER BY a.id
`

func (q *Queries) GetLocationAreaIDs(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getLocationAreaIDs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocationConnections = `-- name: GetLocationConnections :many
SELECT
    ac.id, ac.data_hash, ac.area_id, ac.connection_type, ac.story_only, ac.notes,
    l.id AS location_id,
    l.name AS location,
    s.id AS sublocation_id,
    s.name AS sublocation,
    a.name AS area,
    a.version AS version,
    a.specification AS specification
FROM area_connections ac
JOIN j_area_connected_areas j ON j.connection_id = ac.id
JOIN areas a ON ac.area_id = a.id
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN areas a2 ON j.area_id = a2.id
JOIN sublocations s2 ON a2.sublocation_id = s2.id
JOIN locations l2 ON s2.location_id = l2.id
WHERE l2.id = $1 AND l2.id != l.id
ORDER BY ac.id
`

type GetLocationConnectionsRow struct {
	ID             int32
	DataHash       string
	AreaID         int32
	ConnectionType AreaConnectionType
	StoryOnly      bool
	Notes          sql.NullString
	LocationID     int32
	Location       string
	SublocationID  int32
	Sublocation    string
	Area           string
	Version        sql.NullInt32
	Specification  sql.NullString
}

func (q *Queries) GetLocationConnections(ctx context.Context, id int32) ([]GetLocationConnectionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLocationConnections, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLocationConnectionsRow
	for rows.Next() {
		var i GetLocationConnectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.AreaID,
			&i.ConnectionType,
			&i.StoryOnly,
			&i.Notes,
			&i.LocationID,
			&i.Location,
			&i.SublocationID,
			&i.Sublocation,
			&i.Area,
			&i.Version,
			&i.Specification,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocationMonsterIDs = `-- name: GetLocationMonsterIDs :many
SELECT DISTINCT m.id
FROM monsters m
LEFT JOIN monster_amounts ma ON ma.monster_id = m.id
LEFT JOIN j_monster_formations_monsters j1 ON j1.monster_amount_id = ma.id
LEFT JOIN monster_formations mf ON j1.monster_formation_id = mf.id
LEFT JOIN j_encounter_location_formations j2 ON j2.monster_formation_id = mf.id
LEFT JOIN encounter_locations el ON j2.encounter_location_id = el.id
LEFT JOIN areas a ON el.area_id = a.id
LEFT JOIN sublocations s ON a.sublocation_id = s.id
LEFT JOIN locations l ON s.location_id = l.id
WHERE location_id = $1
ORDER BY m.id
`

func (q *Queries) GetLocationMonsterIDs(ctx context.Context, locationID int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getLocationMonsterIDs, locationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSublocationAreaIDs = `-- name: GetSublocationAreaIDs :many
SELECT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id 
JOIN locations l ON s.location_id = l.id
WHERE s.id = $1
ORDER BY a.id
`

func (q *Queries) GetSublocationAreaIDs(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getSublocationAreaIDs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSublocationConnections = `-- name: GetSublocationConnections :many
SELECT
    ac.id, ac.data_hash, ac.area_id, ac.connection_type, ac.story_only, ac.notes,
    l.id AS location_id,
    l.name AS location,
    s.id AS sublocation_id,
    s.name AS sublocation,
    a.name AS area,
    a.version AS version,
    a.specification AS specification
FROM area_connections ac
JOIN j_area_connected_areas j ON j.connection_id = ac.id
JOIN areas a ON ac.area_id = a.id
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN areas a2 ON j.area_id = a2.id
JOIN sublocations s2 ON a2.sublocation_id = s2.id
WHERE s2.id = $1 AND s2.id != s.id
ORDER BY ac.id
`

type GetSublocationConnectionsRow struct {
	ID             int32
	DataHash       string
	AreaID         int32
	ConnectionType AreaConnectionType
	StoryOnly      bool
	Notes          sql.NullString
	LocationID     int32
	Location       string
	SublocationID  int32
	Sublocation    string
	Area           string
	Version        sql.NullInt32
	Specification  sql.NullString
}

func (q *Queries) GetSublocationConnections(ctx context.Context, id int32) ([]GetSublocationConnectionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSublocationConnections, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSublocationConnectionsRow
	for rows.Next() {
		var i GetSublocationConnectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.AreaID,
			&i.ConnectionType,
			&i.StoryOnly,
			&i.Notes,
			&i.LocationID,
			&i.Location,
			&i.SublocationID,
			&i.Sublocation,
			&i.Area,
			&i.Version,
			&i.Specification,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSublocationMonsterIDs = `-- name: GetSublocationMonsterIDs :many
SELECT DISTINCT m.id
FROM monsters m
LEFT JOIN monster_amounts ma ON ma.monster_id = m.id
LEFT JOIN j_monster_formations_monsters j1 ON j1.monster_amount_id = ma.id
LEFT JOIN monster_formations mf ON j1.monster_formation_id = mf.id
LEFT JOIN j_encounter_location_formations j2 ON j2.monster_formation_id = mf.id
LEFT JOIN encounter_locations el ON j2.encounter_location_id = el.id
LEFT JOIN areas a ON el.area_id = a.id
LEFT JOIN sublocations s ON a.sublocation_id = s.id
LEFT JOIN locations l ON s.location_id = l.id
WHERE sublocation_id = $1
ORDER BY m.id
`

func (q *Queries) GetSublocationMonsterIDs(ctx context.Context, sublocationID int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getSublocationMonsterIDs, sublocationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

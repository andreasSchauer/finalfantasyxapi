// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sidequests.sql

package database

import (
	"context"
	"database/sql"
)

const createBlitzballItem = `-- name: CreateBlitzballItem :exec
INSERT INTO blitzball_items (data_hash, position_id, item_amount_id, chance)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateBlitzballItemParams struct {
	DataHash     string
	PositionID   int32
	ItemAmountID int32
	Chance       interface{}
}

func (q *Queries) CreateBlitzballItem(ctx context.Context, arg CreateBlitzballItemParams) error {
	_, err := q.db.ExecContext(ctx, createBlitzballItem,
		arg.DataHash,
		arg.PositionID,
		arg.ItemAmountID,
		arg.Chance,
	)
	return err
}

const createBlitzballPosition = `-- name: CreateBlitzballPosition :one
INSERT INTO blitzball_positions (data_hash, category, slot)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = blitzball_positions.data_hash
RETURNING id, data_hash, category, slot
`

type CreateBlitzballPositionParams struct {
	DataHash string
	Category BlitzballTournamentCategory
	Slot     BlitzballPositionSlot
}

func (q *Queries) CreateBlitzballPosition(ctx context.Context, arg CreateBlitzballPositionParams) (BlitzballPosition, error) {
	row := q.db.QueryRowContext(ctx, createBlitzballPosition, arg.DataHash, arg.Category, arg.Slot)
	var i BlitzballPosition
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Category,
		&i.Slot,
	)
	return i, err
}

const createCompletionLocation = `-- name: CreateCompletionLocation :exec
INSERT INTO completion_locations (data_hash, completion_id, area_id, notes)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateCompletionLocationParams struct {
	DataHash     string
	CompletionID int32
	AreaID       int32
	Notes        sql.NullString
}

func (q *Queries) CreateCompletionLocation(ctx context.Context, arg CreateCompletionLocationParams) error {
	_, err := q.db.ExecContext(ctx, createCompletionLocation,
		arg.DataHash,
		arg.CompletionID,
		arg.AreaID,
		arg.Notes,
	)
	return err
}

const createMonsterArenaCreation = `-- name: CreateMonsterArenaCreation :exec
INSERT INTO monster_arena_creations (data_hash, subquest_id, category, required_area, required_species, underwater_only, creations_unlocked_category, amount)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterArenaCreationParams struct {
	DataHash                  string
	SubquestID                int32
	Category                  MaCreationCategory
	RequiredArea              NullMaCreationArea
	RequiredSpecies           NullMaCreationSpecies
	UnderwaterOnly            bool
	CreationsUnlockedCategory NullCreationsUnlockedCategory
	Amount                    int32
}

func (q *Queries) CreateMonsterArenaCreation(ctx context.Context, arg CreateMonsterArenaCreationParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterArenaCreation,
		arg.DataHash,
		arg.SubquestID,
		arg.Category,
		arg.RequiredArea,
		arg.RequiredSpecies,
		arg.UnderwaterOnly,
		arg.CreationsUnlockedCategory,
		arg.Amount,
	)
	return err
}

const createQuest = `-- name: CreateQuest :one
INSERT INTO quests (data_hash, name, type)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = quests.data_hash
RETURNING id, data_hash, name, type
`

type CreateQuestParams struct {
	DataHash string
	Name     string
	Type     QuestType
}

func (q *Queries) CreateQuest(ctx context.Context, arg CreateQuestParams) (Quest, error) {
	row := q.db.QueryRowContext(ctx, createQuest, arg.DataHash, arg.Name, arg.Type)
	var i Quest
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Name,
		&i.Type,
	)
	return i, err
}

const createQuestCompletion = `-- name: CreateQuestCompletion :one
INSERT INTO quest_completions (data_hash, quest_id, condition, item_amount_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = quest_completions.data_hash
RETURNING id, data_hash, quest_id, condition, item_amount_id
`

type CreateQuestCompletionParams struct {
	DataHash     string
	QuestID      int32
	Condition    string
	ItemAmountID int32
}

func (q *Queries) CreateQuestCompletion(ctx context.Context, arg CreateQuestCompletionParams) (QuestCompletion, error) {
	row := q.db.QueryRowContext(ctx, createQuestCompletion,
		arg.DataHash,
		arg.QuestID,
		arg.Condition,
		arg.ItemAmountID,
	)
	var i QuestCompletion
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.QuestID,
		&i.Condition,
		&i.ItemAmountID,
	)
	return i, err
}

const createSidequest = `-- name: CreateSidequest :one
INSERT INTO sidequests (data_hash, quest_id)
VALUES ($1, $2)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = sidequests.data_hash
RETURNING id, data_hash, quest_id
`

type CreateSidequestParams struct {
	DataHash string
	QuestID  int32
}

func (q *Queries) CreateSidequest(ctx context.Context, arg CreateSidequestParams) (Sidequest, error) {
	row := q.db.QueryRowContext(ctx, createSidequest, arg.DataHash, arg.QuestID)
	var i Sidequest
	err := row.Scan(&i.ID, &i.DataHash, &i.QuestID)
	return i, err
}

const createSubquest = `-- name: CreateSubquest :one
INSERT INTO subquests (data_hash, quest_id, parent_sidequest_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = subquests.data_hash
RETURNING id, data_hash, quest_id, parent_sidequest_id
`

type CreateSubquestParams struct {
	DataHash          string
	QuestID           int32
	ParentSidequestID int32
}

func (q *Queries) CreateSubquest(ctx context.Context, arg CreateSubquestParams) (Subquest, error) {
	row := q.db.QueryRowContext(ctx, createSubquest, arg.DataHash, arg.QuestID, arg.ParentSidequestID)
	var i Subquest
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.QuestID,
		&i.ParentSidequestID,
	)
	return i, err
}

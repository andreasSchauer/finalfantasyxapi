// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: commands_menus_create.sql

package database

import (
	"context"
	"database/sql"
)

const createAeonCommand = `-- name: CreateAeonCommand :one
INSERT INTO aeon_commands (data_hash, name, description, effect, cursor)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = aeon_commands.data_hash
RETURNING id, data_hash, name, description, effect, cursor, topmenu_id, submenu_id
`

type CreateAeonCommandParams struct {
	DataHash    string
	Name        string
	Description string
	Effect      string
	Cursor      NullTargetType
}

func (q *Queries) CreateAeonCommand(ctx context.Context, arg CreateAeonCommandParams) (AeonCommand, error) {
	row := q.db.QueryRowContext(ctx, createAeonCommand,
		arg.DataHash,
		arg.Name,
		arg.Description,
		arg.Effect,
		arg.Cursor,
	)
	var i AeonCommand
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Name,
		&i.Description,
		&i.Effect,
		&i.Cursor,
		&i.TopmenuID,
		&i.SubmenuID,
	)
	return i, err
}

const createAeonCommandsPossibleAbilitiesJunction = `-- name: CreateAeonCommandsPossibleAbilitiesJunction :exec
INSERT INTO j_aeon_commands_possible_abilities (data_hash, aeon_command_id, character_class_id, ability_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAeonCommandsPossibleAbilitiesJunctionParams struct {
	DataHash         string
	AeonCommandID    int32
	CharacterClassID int32
	AbilityID        int32
}

func (q *Queries) CreateAeonCommandsPossibleAbilitiesJunction(ctx context.Context, arg CreateAeonCommandsPossibleAbilitiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAeonCommandsPossibleAbilitiesJunction,
		arg.DataHash,
		arg.AeonCommandID,
		arg.CharacterClassID,
		arg.AbilityID,
	)
	return err
}

const createOverdriveCommand = `-- name: CreateOverdriveCommand :one
INSERT INTO overdrive_commands (data_hash, name, description, rank)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = overdrive_commands.data_hash
RETURNING id, data_hash, name, description, rank, character_class_id, topmenu_id, submenu_id
`

type CreateOverdriveCommandParams struct {
	DataHash    string
	Name        string
	Description string
	Rank        int32
}

func (q *Queries) CreateOverdriveCommand(ctx context.Context, arg CreateOverdriveCommandParams) (OverdriveCommand, error) {
	row := q.db.QueryRowContext(ctx, createOverdriveCommand,
		arg.DataHash,
		arg.Name,
		arg.Description,
		arg.Rank,
	)
	var i OverdriveCommand
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Name,
		&i.Description,
		&i.Rank,
		&i.CharacterClassID,
		&i.TopmenuID,
		&i.SubmenuID,
	)
	return i, err
}

const createSubmenu = `-- name: CreateSubmenu :one
INSERT INTO submenus (data_hash, name, description, effect)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = submenus.data_hash
RETURNING id, data_hash, name, description, effect, topmenu_id
`

type CreateSubmenuParams struct {
	DataHash    string
	Name        string
	Description string
	Effect      string
}

func (q *Queries) CreateSubmenu(ctx context.Context, arg CreateSubmenuParams) (Submenu, error) {
	row := q.db.QueryRowContext(ctx, createSubmenu,
		arg.DataHash,
		arg.Name,
		arg.Description,
		arg.Effect,
	)
	var i Submenu
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Name,
		&i.Description,
		&i.Effect,
		&i.TopmenuID,
	)
	return i, err
}

const createSubmenusUsersJunction = `-- name: CreateSubmenusUsersJunction :exec
INSERT INTO j_submenus_users (data_hash, submenu_id, character_class_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateSubmenusUsersJunctionParams struct {
	DataHash         string
	SubmenuID        int32
	CharacterClassID int32
}

func (q *Queries) CreateSubmenusUsersJunction(ctx context.Context, arg CreateSubmenusUsersJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createSubmenusUsersJunction, arg.DataHash, arg.SubmenuID, arg.CharacterClassID)
	return err
}

const createTopmenu = `-- name: CreateTopmenu :one
INSERT INTO topmenus (data_hash, name)
VALUES ($1, $2)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = topmenus.data_hash
RETURNING id, data_hash, name
`

type CreateTopmenuParams struct {
	DataHash string
	Name     string
}

func (q *Queries) CreateTopmenu(ctx context.Context, arg CreateTopmenuParams) (Topmenu, error) {
	row := q.db.QueryRowContext(ctx, createTopmenu, arg.DataHash, arg.Name)
	var i Topmenu
	err := row.Scan(&i.ID, &i.DataHash, &i.Name)
	return i, err
}

const updateAeonCommand = `-- name: UpdateAeonCommand :exec
UPDATE aeon_commands
SET data_hash = $1,
    topmenu_id = $2,
    submenu_id = $3
WHERE id = $4
`

type UpdateAeonCommandParams struct {
	DataHash  string
	TopmenuID sql.NullInt32
	SubmenuID sql.NullInt32
	ID        int32
}

func (q *Queries) UpdateAeonCommand(ctx context.Context, arg UpdateAeonCommandParams) error {
	_, err := q.db.ExecContext(ctx, updateAeonCommand,
		arg.DataHash,
		arg.TopmenuID,
		arg.SubmenuID,
		arg.ID,
	)
	return err
}

const updateOverdriveCommand = `-- name: UpdateOverdriveCommand :exec
UPDATE overdrive_commands
SET data_hash = $1,
    character_class_id = $2,
    topmenu_id = $3,
    submenu_id = $4
WHERE id = $5
`

type UpdateOverdriveCommandParams struct {
	DataHash         string
	CharacterClassID sql.NullInt32
	TopmenuID        sql.NullInt32
	SubmenuID        sql.NullInt32
	ID               int32
}

func (q *Queries) UpdateOverdriveCommand(ctx context.Context, arg UpdateOverdriveCommandParams) error {
	_, err := q.db.ExecContext(ctx, updateOverdriveCommand,
		arg.DataHash,
		arg.CharacterClassID,
		arg.TopmenuID,
		arg.SubmenuID,
		arg.ID,
	)
	return err
}

const updateSubmenu = `-- name: UpdateSubmenu :exec
UPDATE submenus
SET data_hash = $1,
    topmenu_id = $2
WHERE id = $3
`

type UpdateSubmenuParams struct {
	DataHash  string
	TopmenuID sql.NullInt32
	ID        int32
}

func (q *Queries) UpdateSubmenu(ctx context.Context, arg UpdateSubmenuParams) error {
	_, err := q.db.ExecContext(ctx, updateSubmenu, arg.DataHash, arg.TopmenuID, arg.ID)
	return err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: monsters_create.sql

package database

import (
	"context"
	"database/sql"
)

const createAltStateChange = `-- name: CreateAltStateChange :one
INSERT INTO alt_state_changes (data_hash, altered_state_id, alteration_type, distance, added_status_id)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = alt_state_changes.data_hash
RETURNING id, data_hash, altered_state_id, alteration_type, distance, added_status_id
`

type CreateAltStateChangeParams struct {
	DataHash       string
	AlteredStateID int32
	AlterationType AlterationType
	Distance       interface{}
	AddedStatusID  sql.NullInt32
}

func (q *Queries) CreateAltStateChange(ctx context.Context, arg CreateAltStateChangeParams) (AltStateChange, error) {
	row := q.db.QueryRowContext(ctx, createAltStateChange,
		arg.DataHash,
		arg.AlteredStateID,
		arg.AlterationType,
		arg.Distance,
		arg.AddedStatusID,
	)
	var i AltStateChange
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.AlteredStateID,
		&i.AlterationType,
		&i.Distance,
		&i.AddedStatusID,
	)
	return i, err
}

const createAltStateChangesAutoAbilitiesJunction = `-- name: CreateAltStateChangesAutoAbilitiesJunction :exec
INSERT INTO j_alt_state_changes_auto_abilities (data_hash, alt_state_change_id, auto_ability_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAltStateChangesAutoAbilitiesJunctionParams struct {
	DataHash         string
	AltStateChangeID int32
	AutoAbilityID    int32
}

func (q *Queries) CreateAltStateChangesAutoAbilitiesJunction(ctx context.Context, arg CreateAltStateChangesAutoAbilitiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAltStateChangesAutoAbilitiesJunction, arg.DataHash, arg.AltStateChangeID, arg.AutoAbilityID)
	return err
}

const createAltStateChangesBaseStatsJunction = `-- name: CreateAltStateChangesBaseStatsJunction :exec
INSERT INTO j_alt_state_changes_base_stats (data_hash, alt_state_change_id, base_stat_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAltStateChangesBaseStatsJunctionParams struct {
	DataHash         string
	AltStateChangeID int32
	BaseStatID       int32
}

func (q *Queries) CreateAltStateChangesBaseStatsJunction(ctx context.Context, arg CreateAltStateChangesBaseStatsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAltStateChangesBaseStatsJunction, arg.DataHash, arg.AltStateChangeID, arg.BaseStatID)
	return err
}

const createAltStateChangesElemResistsJunction = `-- name: CreateAltStateChangesElemResistsJunction :exec
INSERT INTO j_alt_state_changes_elem_resists (data_hash, alt_state_change_id, elem_resist_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAltStateChangesElemResistsJunctionParams struct {
	DataHash         string
	AltStateChangeID int32
	ElemResistID     int32
}

func (q *Queries) CreateAltStateChangesElemResistsJunction(ctx context.Context, arg CreateAltStateChangesElemResistsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAltStateChangesElemResistsJunction, arg.DataHash, arg.AltStateChangeID, arg.ElemResistID)
	return err
}

const createAltStateChangesPropertiesJunction = `-- name: CreateAltStateChangesPropertiesJunction :exec
INSERT INTO j_alt_state_changes_properties (data_hash, alt_state_change_id, property_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAltStateChangesPropertiesJunctionParams struct {
	DataHash         string
	AltStateChangeID int32
	PropertyID       int32
}

func (q *Queries) CreateAltStateChangesPropertiesJunction(ctx context.Context, arg CreateAltStateChangesPropertiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAltStateChangesPropertiesJunction, arg.DataHash, arg.AltStateChangeID, arg.PropertyID)
	return err
}

const createAltStateChangesStatusImmunitiesJunction = `-- name: CreateAltStateChangesStatusImmunitiesJunction :exec
INSERT INTO j_alt_state_changes_status_immunities (data_hash, alt_state_change_id, status_condition_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAltStateChangesStatusImmunitiesJunctionParams struct {
	DataHash          string
	AltStateChangeID  int32
	StatusConditionID int32
}

func (q *Queries) CreateAltStateChangesStatusImmunitiesJunction(ctx context.Context, arg CreateAltStateChangesStatusImmunitiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAltStateChangesStatusImmunitiesJunction, arg.DataHash, arg.AltStateChangeID, arg.StatusConditionID)
	return err
}

const createAlteredState = `-- name: CreateAlteredState :one
INSERT INTO altered_states (data_hash, monster_id, condition, is_temporary)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = altered_states.data_hash
RETURNING id, data_hash, monster_id, condition, is_temporary
`

type CreateAlteredStateParams struct {
	DataHash    string
	MonsterID   int32
	Condition   string
	IsTemporary bool
}

func (q *Queries) CreateAlteredState(ctx context.Context, arg CreateAlteredStateParams) (AlteredState, error) {
	row := q.db.QueryRowContext(ctx, createAlteredState,
		arg.DataHash,
		arg.MonsterID,
		arg.Condition,
		arg.IsTemporary,
	)
	var i AlteredState
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.MonsterID,
		&i.Condition,
		&i.IsTemporary,
	)
	return i, err
}

const createEncounterArea = `-- name: CreateEncounterArea :one
INSERT INTO encounter_areas (data_hash, area_id, specification)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = encounter_areas.data_hash
RETURNING id, data_hash, area_id, specification
`

type CreateEncounterAreaParams struct {
	DataHash      string
	AreaID        int32
	Specification sql.NullString
}

func (q *Queries) CreateEncounterArea(ctx context.Context, arg CreateEncounterAreaParams) (EncounterArea, error) {
	row := q.db.QueryRowContext(ctx, createEncounterArea, arg.DataHash, arg.AreaID, arg.Specification)
	var i EncounterArea
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.AreaID,
		&i.Specification,
	)
	return i, err
}

const createEquipmentDrop = `-- name: CreateEquipmentDrop :one
INSERT INTO equipment_drops (data_hash, auto_ability_id, is_forced, probability, type)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = equipment_drops.data_hash
RETURNING id, data_hash, auto_ability_id, is_forced, probability, type
`

type CreateEquipmentDropParams struct {
	DataHash      string
	AutoAbilityID int32
	IsForced      bool
	Probability   interface{}
	Type          EquipType
}

func (q *Queries) CreateEquipmentDrop(ctx context.Context, arg CreateEquipmentDropParams) (EquipmentDrop, error) {
	row := q.db.QueryRowContext(ctx, createEquipmentDrop,
		arg.DataHash,
		arg.AutoAbilityID,
		arg.IsForced,
		arg.Probability,
		arg.Type,
	)
	var i EquipmentDrop
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.AutoAbilityID,
		&i.IsForced,
		&i.Probability,
		&i.Type,
	)
	return i, err
}

const createEquipmentDropsCharactersJunction = `-- name: CreateEquipmentDropsCharactersJunction :exec
INSERT INTO j_equipment_drops_characters (data_hash, monster_equipment_id, equipment_drop_id, character_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateEquipmentDropsCharactersJunctionParams struct {
	DataHash           string
	MonsterEquipmentID int32
	EquipmentDropID    int32
	CharacterID        int32
}

func (q *Queries) CreateEquipmentDropsCharactersJunction(ctx context.Context, arg CreateEquipmentDropsCharactersJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createEquipmentDropsCharactersJunction,
		arg.DataHash,
		arg.MonsterEquipmentID,
		arg.EquipmentDropID,
		arg.CharacterID,
	)
	return err
}

const createEquipmentSlotsChance = `-- name: CreateEquipmentSlotsChance :one
INSERT INTO equipment_slots_chances (data_hash, amount, chance)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = equipment_slots_chances.data_hash
RETURNING id, data_hash, amount, chance
`

type CreateEquipmentSlotsChanceParams struct {
	DataHash string
	Amount   interface{}
	Chance   interface{}
}

func (q *Queries) CreateEquipmentSlotsChance(ctx context.Context, arg CreateEquipmentSlotsChanceParams) (EquipmentSlotsChance, error) {
	row := q.db.QueryRowContext(ctx, createEquipmentSlotsChance, arg.DataHash, arg.Amount, arg.Chance)
	var i EquipmentSlotsChance
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Amount,
		&i.Chance,
	)
	return i, err
}

const createFormationBossSong = `-- name: CreateFormationBossSong :one
INSERT INTO formation_boss_songs (data_hash, song_id, celebrate_victory)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = formation_boss_songs.data_hash
RETURNING id, data_hash, song_id, celebrate_victory
`

type CreateFormationBossSongParams struct {
	DataHash         string
	SongID           int32
	CelebrateVictory bool
}

func (q *Queries) CreateFormationBossSong(ctx context.Context, arg CreateFormationBossSongParams) (FormationBossSong, error) {
	row := q.db.QueryRowContext(ctx, createFormationBossSong, arg.DataHash, arg.SongID, arg.CelebrateVictory)
	var i FormationBossSong
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.SongID,
		&i.CelebrateVictory,
	)
	return i, err
}

const createFormationData = `-- name: CreateFormationData :one
INSERT INTO formation_data (data_hash, category, is_forced_ambush, can_escape, boss_song_id, notes)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = formation_data.data_hash
RETURNING id, data_hash, category, is_forced_ambush, can_escape, boss_song_id, notes
`

type CreateFormationDataParams struct {
	DataHash       string
	Category       MonsterFormationCategory
	IsForcedAmbush bool
	CanEscape      bool
	BossSongID     sql.NullInt32
	Notes          sql.NullString
}

func (q *Queries) CreateFormationData(ctx context.Context, arg CreateFormationDataParams) (FormationDatum, error) {
	row := q.db.QueryRowContext(ctx, createFormationData,
		arg.DataHash,
		arg.Category,
		arg.IsForcedAmbush,
		arg.CanEscape,
		arg.BossSongID,
		arg.Notes,
	)
	var i FormationDatum
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Category,
		&i.IsForcedAmbush,
		&i.CanEscape,
		&i.BossSongID,
		&i.Notes,
	)
	return i, err
}

const createFormationTriggerCommand = `-- name: CreateFormationTriggerCommand :one
INSERT INTO formation_trigger_commands (data_hash, trigger_command_id, condition, use_amount)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = formation_trigger_commands.data_hash
RETURNING id, data_hash, trigger_command_id, condition, use_amount
`

type CreateFormationTriggerCommandParams struct {
	DataHash         string
	TriggerCommandID int32
	Condition        sql.NullString
	UseAmount        sql.NullInt32
}

func (q *Queries) CreateFormationTriggerCommand(ctx context.Context, arg CreateFormationTriggerCommandParams) (FormationTriggerCommand, error) {
	row := q.db.QueryRowContext(ctx, createFormationTriggerCommand,
		arg.DataHash,
		arg.TriggerCommandID,
		arg.Condition,
		arg.UseAmount,
	)
	var i FormationTriggerCommand
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.TriggerCommandID,
		&i.Condition,
		&i.UseAmount,
	)
	return i, err
}

const createFormationTriggerCommandsUsersJunction = `-- name: CreateFormationTriggerCommandsUsersJunction :exec
INSERT INTO j_formation_trigger_commands_users (data_hash, trigger_command_id, character_class_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateFormationTriggerCommandsUsersJunctionParams struct {
	DataHash         string
	TriggerCommandID int32
	CharacterClassID int32
}

func (q *Queries) CreateFormationTriggerCommandsUsersJunction(ctx context.Context, arg CreateFormationTriggerCommandsUsersJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createFormationTriggerCommandsUsersJunction, arg.DataHash, arg.TriggerCommandID, arg.CharacterClassID)
	return err
}

const createMonster = `-- name: CreateMonster :one
INSERT INTO monsters (data_hash, name, version, specification, notes, species, is_story_based, is_repeatable, can_be_captured, area_conquest_location, ctb_icon_type, has_overdrive, is_underwater, is_zombie, distance, ap, ap_overkill, overkill_damage, gil, steal_gil, doom_countdown, poison_rate, threaten_chance, zanmato_level, monster_arena_price, sensor_text, scan_text)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monsters.data_hash
RETURNING id, data_hash, name, version, specification, notes, species, is_story_based, is_repeatable, can_be_captured, area_conquest_location, ctb_icon_type, has_overdrive, is_underwater, is_zombie, distance, ap, ap_overkill, overkill_damage, gil, steal_gil, doom_countdown, poison_rate, threaten_chance, zanmato_level, monster_arena_price, sensor_text, scan_text
`

type CreateMonsterParams struct {
	DataHash             string
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	Notes                sql.NullString
	Species              MonsterSpecies
	IsStoryBased         bool
	IsRepeatable         bool
	CanBeCaptured        bool
	AreaConquestLocation NullMaCreationArea
	CtbIconType          CtbIconType
	HasOverdrive         bool
	IsUnderwater         bool
	IsZombie             bool
	Distance             interface{}
	Ap                   int32
	ApOverkill           int32
	OverkillDamage       int32
	Gil                  int32
	StealGil             sql.NullInt32
	DoomCountdown        interface{}
	PoisonRate           interface{}
	ThreatenChance       interface{}
	ZanmatoLevel         interface{}
	MonsterArenaPrice    sql.NullInt32
	SensorText           sql.NullString
	ScanText             sql.NullString
}

func (q *Queries) CreateMonster(ctx context.Context, arg CreateMonsterParams) (Monster, error) {
	row := q.db.QueryRowContext(ctx, createMonster,
		arg.DataHash,
		arg.Name,
		arg.Version,
		arg.Specification,
		arg.Notes,
		arg.Species,
		arg.IsStoryBased,
		arg.IsRepeatable,
		arg.CanBeCaptured,
		arg.AreaConquestLocation,
		arg.CtbIconType,
		arg.HasOverdrive,
		arg.IsUnderwater,
		arg.IsZombie,
		arg.Distance,
		arg.Ap,
		arg.ApOverkill,
		arg.OverkillDamage,
		arg.Gil,
		arg.StealGil,
		arg.DoomCountdown,
		arg.PoisonRate,
		arg.ThreatenChance,
		arg.ZanmatoLevel,
		arg.MonsterArenaPrice,
		arg.SensorText,
		arg.ScanText,
	)
	var i Monster
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Name,
		&i.Version,
		&i.Specification,
		&i.Notes,
		&i.Species,
		&i.IsStoryBased,
		&i.IsRepeatable,
		&i.CanBeCaptured,
		&i.AreaConquestLocation,
		&i.CtbIconType,
		&i.HasOverdrive,
		&i.IsUnderwater,
		&i.IsZombie,
		&i.Distance,
		&i.Ap,
		&i.ApOverkill,
		&i.OverkillDamage,
		&i.Gil,
		&i.StealGil,
		&i.DoomCountdown,
		&i.PoisonRate,
		&i.ThreatenChance,
		&i.ZanmatoLevel,
		&i.MonsterArenaPrice,
		&i.SensorText,
		&i.ScanText,
	)
	return i, err
}

const createMonsterAbility = `-- name: CreateMonsterAbility :one
INSERT INTO monster_abilities (data_hash, ability_id, is_forced, is_unused)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monster_abilities.data_hash
RETURNING id, data_hash, ability_id, is_forced, is_unused
`

type CreateMonsterAbilityParams struct {
	DataHash  string
	AbilityID int32
	IsForced  bool
	IsUnused  bool
}

func (q *Queries) CreateMonsterAbility(ctx context.Context, arg CreateMonsterAbilityParams) (MonsterAbility, error) {
	row := q.db.QueryRowContext(ctx, createMonsterAbility,
		arg.DataHash,
		arg.AbilityID,
		arg.IsForced,
		arg.IsUnused,
	)
	var i MonsterAbility
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.AbilityID,
		&i.IsForced,
		&i.IsUnused,
	)
	return i, err
}

const createMonsterAmount = `-- name: CreateMonsterAmount :one
INSERT INTO monster_amounts (data_hash, monster_id, amount)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monster_amounts.data_hash
RETURNING id, data_hash, monster_id, amount
`

type CreateMonsterAmountParams struct {
	DataHash  string
	MonsterID int32
	Amount    int32
}

func (q *Queries) CreateMonsterAmount(ctx context.Context, arg CreateMonsterAmountParams) (MonsterAmount, error) {
	row := q.db.QueryRowContext(ctx, createMonsterAmount, arg.DataHash, arg.MonsterID, arg.Amount)
	var i MonsterAmount
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.MonsterID,
		&i.Amount,
	)
	return i, err
}

const createMonsterEquipment = `-- name: CreateMonsterEquipment :one
INSERT INTO monster_equipment (data_hash, monster_id, drop_chance, power, critical_plus)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monster_equipment.data_hash
RETURNING id, data_hash, monster_id, drop_chance, power, critical_plus
`

type CreateMonsterEquipmentParams struct {
	DataHash     string
	MonsterID    int32
	DropChance   interface{}
	Power        interface{}
	CriticalPlus int32
}

func (q *Queries) CreateMonsterEquipment(ctx context.Context, arg CreateMonsterEquipmentParams) (MonsterEquipment, error) {
	row := q.db.QueryRowContext(ctx, createMonsterEquipment,
		arg.DataHash,
		arg.MonsterID,
		arg.DropChance,
		arg.Power,
		arg.CriticalPlus,
	)
	var i MonsterEquipment
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.MonsterID,
		&i.DropChance,
		&i.Power,
		&i.CriticalPlus,
	)
	return i, err
}

const createMonsterEquipmentAbilitiesJunction = `-- name: CreateMonsterEquipmentAbilitiesJunction :exec
INSERT INTO j_monster_equipment_abilities (data_hash, monster_equipment_id, equipment_drop_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterEquipmentAbilitiesJunctionParams struct {
	DataHash           string
	MonsterEquipmentID int32
	EquipmentDropID    int32
}

func (q *Queries) CreateMonsterEquipmentAbilitiesJunction(ctx context.Context, arg CreateMonsterEquipmentAbilitiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterEquipmentAbilitiesJunction, arg.DataHash, arg.MonsterEquipmentID, arg.EquipmentDropID)
	return err
}

const createMonsterEquipmentSlots = `-- name: CreateMonsterEquipmentSlots :one
INSERT INTO monster_equipment_slots (data_hash, monster_equipment_id, min_amount, max_amount, type)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monster_equipment_slots.data_hash
RETURNING id, data_hash, monster_equipment_id, min_amount, max_amount, type
`

type CreateMonsterEquipmentSlotsParams struct {
	DataHash           string
	MonsterEquipmentID int32
	MinAmount          interface{}
	MaxAmount          interface{}
	Type               EquipmentSlotsType
}

func (q *Queries) CreateMonsterEquipmentSlots(ctx context.Context, arg CreateMonsterEquipmentSlotsParams) (MonsterEquipmentSlot, error) {
	row := q.db.QueryRowContext(ctx, createMonsterEquipmentSlots,
		arg.DataHash,
		arg.MonsterEquipmentID,
		arg.MinAmount,
		arg.MaxAmount,
		arg.Type,
	)
	var i MonsterEquipmentSlot
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.MonsterEquipmentID,
		&i.MinAmount,
		&i.MaxAmount,
		&i.Type,
	)
	return i, err
}

const createMonsterEquipmentSlotsChancesJunction = `-- name: CreateMonsterEquipmentSlotsChancesJunction :exec
INSERT INTO j_monster_equipment_slots_chances(data_hash, monster_equipment_id, equipment_slots_id, slots_chance_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterEquipmentSlotsChancesJunctionParams struct {
	DataHash           string
	MonsterEquipmentID int32
	EquipmentSlotsID   int32
	SlotsChanceID      int32
}

func (q *Queries) CreateMonsterEquipmentSlotsChancesJunction(ctx context.Context, arg CreateMonsterEquipmentSlotsChancesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterEquipmentSlotsChancesJunction,
		arg.DataHash,
		arg.MonsterEquipmentID,
		arg.EquipmentSlotsID,
		arg.SlotsChanceID,
	)
	return err
}

const createMonsterFormation = `-- name: CreateMonsterFormation :one
INSERT INTO monster_formations (data_hash, version, monster_selection_id, formation_data_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monster_formations.data_hash
RETURNING id, data_hash, version, monster_selection_id, formation_data_id
`

type CreateMonsterFormationParams struct {
	DataHash           string
	Version            sql.NullInt32
	MonsterSelectionID int32
	FormationDataID    int32
}

func (q *Queries) CreateMonsterFormation(ctx context.Context, arg CreateMonsterFormationParams) (MonsterFormation, error) {
	row := q.db.QueryRowContext(ctx, createMonsterFormation,
		arg.DataHash,
		arg.Version,
		arg.MonsterSelectionID,
		arg.FormationDataID,
	)
	var i MonsterFormation
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Version,
		&i.MonsterSelectionID,
		&i.FormationDataID,
	)
	return i, err
}

const createMonsterFormationsEncounterAreasJunction = `-- name: CreateMonsterFormationsEncounterAreasJunction :exec
INSERT INTO j_monster_formations_encounter_areas (data_hash, monster_formation_id, encounter_area_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterFormationsEncounterAreasJunctionParams struct {
	DataHash           string
	MonsterFormationID int32
	EncounterAreaID    int32
}

func (q *Queries) CreateMonsterFormationsEncounterAreasJunction(ctx context.Context, arg CreateMonsterFormationsEncounterAreasJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterFormationsEncounterAreasJunction, arg.DataHash, arg.MonsterFormationID, arg.EncounterAreaID)
	return err
}

const createMonsterFormationsTriggerCommandsJunction = `-- name: CreateMonsterFormationsTriggerCommandsJunction :exec
INSERT INTO j_monster_formations_trigger_commands (data_hash, monster_formation_id, trigger_command_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterFormationsTriggerCommandsJunctionParams struct {
	DataHash           string
	MonsterFormationID int32
	TriggerCommandID   int32
}

func (q *Queries) CreateMonsterFormationsTriggerCommandsJunction(ctx context.Context, arg CreateMonsterFormationsTriggerCommandsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterFormationsTriggerCommandsJunction, arg.DataHash, arg.MonsterFormationID, arg.TriggerCommandID)
	return err
}

const createMonsterItem = `-- name: CreateMonsterItem :one
INSERT INTO monster_items (data_hash, monster_id, drop_chance, drop_condition, other_items_condition, steal_common_id, steal_rare_id, drop_common_id, drop_rare_id, secondary_drop_common_id, secondary_drop_rare_id, bribe_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monster_items.data_hash
RETURNING id, data_hash, monster_id, drop_chance, drop_condition, other_items_condition, steal_common_id, steal_rare_id, drop_common_id, drop_rare_id, secondary_drop_common_id, secondary_drop_rare_id, bribe_id
`

type CreateMonsterItemParams struct {
	DataHash              string
	MonsterID             int32
	DropChance            interface{}
	DropCondition         sql.NullString
	OtherItemsCondition   sql.NullString
	StealCommonID         sql.NullInt32
	StealRareID           sql.NullInt32
	DropCommonID          sql.NullInt32
	DropRareID            sql.NullInt32
	SecondaryDropCommonID sql.NullInt32
	SecondaryDropRareID   sql.NullInt32
	BribeID               sql.NullInt32
}

func (q *Queries) CreateMonsterItem(ctx context.Context, arg CreateMonsterItemParams) (MonsterItem, error) {
	row := q.db.QueryRowContext(ctx, createMonsterItem,
		arg.DataHash,
		arg.MonsterID,
		arg.DropChance,
		arg.DropCondition,
		arg.OtherItemsCondition,
		arg.StealCommonID,
		arg.StealRareID,
		arg.DropCommonID,
		arg.DropRareID,
		arg.SecondaryDropCommonID,
		arg.SecondaryDropRareID,
		arg.BribeID,
	)
	var i MonsterItem
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.MonsterID,
		&i.DropChance,
		&i.DropCondition,
		&i.OtherItemsCondition,
		&i.StealCommonID,
		&i.StealRareID,
		&i.DropCommonID,
		&i.DropRareID,
		&i.SecondaryDropCommonID,
		&i.SecondaryDropRareID,
		&i.BribeID,
	)
	return i, err
}

const createMonsterItemsOtherItemsJunction = `-- name: CreateMonsterItemsOtherItemsJunction :exec
INSERT INTO j_monster_items_other_items (data_hash, monster_items_id, possible_item_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterItemsOtherItemsJunctionParams struct {
	DataHash       string
	MonsterItemsID int32
	PossibleItemID int32
}

func (q *Queries) CreateMonsterItemsOtherItemsJunction(ctx context.Context, arg CreateMonsterItemsOtherItemsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterItemsOtherItemsJunction, arg.DataHash, arg.MonsterItemsID, arg.PossibleItemID)
	return err
}

const createMonsterSelection = `-- name: CreateMonsterSelection :one
INSERT INTO monster_selections (data_hash)
VALUES ($1)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monster_selections.data_hash
RETURNING id, data_hash
`

func (q *Queries) CreateMonsterSelection(ctx context.Context, dataHash string) (MonsterSelection, error) {
	row := q.db.QueryRowContext(ctx, createMonsterSelection, dataHash)
	var i MonsterSelection
	err := row.Scan(&i.ID, &i.DataHash)
	return i, err
}

const createMonsterSelectionsMonstersJunction = `-- name: CreateMonsterSelectionsMonstersJunction :exec
INSERT INTO j_monster_selections_monsters (data_hash, monster_selection_id, monster_amount_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterSelectionsMonstersJunctionParams struct {
	DataHash           string
	MonsterSelectionID int32
	MonsterAmountID    int32
}

func (q *Queries) CreateMonsterSelectionsMonstersJunction(ctx context.Context, arg CreateMonsterSelectionsMonstersJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterSelectionsMonstersJunction, arg.DataHash, arg.MonsterSelectionID, arg.MonsterAmountID)
	return err
}

const createMonstersAbilitiesJunction = `-- name: CreateMonstersAbilitiesJunction :exec
INSERT INTO j_monsters_abilities (data_hash, monster_id, monster_ability_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersAbilitiesJunctionParams struct {
	DataHash         string
	MonsterID        int32
	MonsterAbilityID int32
}

func (q *Queries) CreateMonstersAbilitiesJunction(ctx context.Context, arg CreateMonstersAbilitiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersAbilitiesJunction, arg.DataHash, arg.MonsterID, arg.MonsterAbilityID)
	return err
}

const createMonstersAutoAbilitiesJunction = `-- name: CreateMonstersAutoAbilitiesJunction :exec
INSERT INTO j_monsters_auto_abilities (data_hash, monster_id, auto_ability_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersAutoAbilitiesJunctionParams struct {
	DataHash      string
	MonsterID     int32
	AutoAbilityID int32
}

func (q *Queries) CreateMonstersAutoAbilitiesJunction(ctx context.Context, arg CreateMonstersAutoAbilitiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersAutoAbilitiesJunction, arg.DataHash, arg.MonsterID, arg.AutoAbilityID)
	return err
}

const createMonstersBaseStatsJunction = `-- name: CreateMonstersBaseStatsJunction :exec
INSERT INTO j_monsters_base_stats (data_hash, monster_id, base_stat_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersBaseStatsJunctionParams struct {
	DataHash   string
	MonsterID  int32
	BaseStatID int32
}

func (q *Queries) CreateMonstersBaseStatsJunction(ctx context.Context, arg CreateMonstersBaseStatsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersBaseStatsJunction, arg.DataHash, arg.MonsterID, arg.BaseStatID)
	return err
}

const createMonstersElemResistsJunction = `-- name: CreateMonstersElemResistsJunction :exec
INSERT INTO j_monsters_elem_resists (data_hash, monster_id, elem_resist_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersElemResistsJunctionParams struct {
	DataHash     string
	MonsterID    int32
	ElemResistID int32
}

func (q *Queries) CreateMonstersElemResistsJunction(ctx context.Context, arg CreateMonstersElemResistsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersElemResistsJunction, arg.DataHash, arg.MonsterID, arg.ElemResistID)
	return err
}

const createMonstersImmunitiesJunction = `-- name: CreateMonstersImmunitiesJunction :exec
INSERT INTO j_monsters_immunities (data_hash, monster_id, status_condition_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersImmunitiesJunctionParams struct {
	DataHash          string
	MonsterID         int32
	StatusConditionID int32
}

func (q *Queries) CreateMonstersImmunitiesJunction(ctx context.Context, arg CreateMonstersImmunitiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersImmunitiesJunction, arg.DataHash, arg.MonsterID, arg.StatusConditionID)
	return err
}

const createMonstersPropertiesJunction = `-- name: CreateMonstersPropertiesJunction :exec
INSERT INTO j_monsters_properties (data_hash, monster_id, property_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersPropertiesJunctionParams struct {
	DataHash   string
	MonsterID  int32
	PropertyID int32
}

func (q *Queries) CreateMonstersPropertiesJunction(ctx context.Context, arg CreateMonstersPropertiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersPropertiesJunction, arg.DataHash, arg.MonsterID, arg.PropertyID)
	return err
}

const createMonstersRonsoRagesJunction = `-- name: CreateMonstersRonsoRagesJunction :exec
INSERT INTO j_monsters_ronso_rages (data_hash, monster_id, ronso_rage_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersRonsoRagesJunctionParams struct {
	DataHash    string
	MonsterID   int32
	RonsoRageID int32
}

func (q *Queries) CreateMonstersRonsoRagesJunction(ctx context.Context, arg CreateMonstersRonsoRagesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersRonsoRagesJunction, arg.DataHash, arg.MonsterID, arg.RonsoRageID)
	return err
}

const createMonstersStatusResistsJunction = `-- name: CreateMonstersStatusResistsJunction :exec
INSERT INTO j_monsters_status_resists (data_hash, monster_id, status_resist_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersStatusResistsJunctionParams struct {
	DataHash       string
	MonsterID      int32
	StatusResistID int32
}

func (q *Queries) CreateMonstersStatusResistsJunction(ctx context.Context, arg CreateMonstersStatusResistsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersStatusResistsJunction, arg.DataHash, arg.MonsterID, arg.StatusResistID)
	return err
}

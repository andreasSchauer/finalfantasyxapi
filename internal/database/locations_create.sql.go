// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: locations_create.sql

package database

import (
	"context"
	"database/sql"
)

const createArea = `-- name: CreateArea :one
INSERT INTO areas (data_hash, sublocation_id, name, version, specification, story_only, has_save_sphere, airship_drop_off, has_compilation_sphere, can_ride_chocobo)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = areas.data_hash
RETURNING id, data_hash, sublocation_id, name, version, specification, story_only, has_save_sphere, airship_drop_off, has_compilation_sphere, can_ride_chocobo
`

type CreateAreaParams struct {
	DataHash             string
	SublocationID        int32
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	StoryOnly            bool
	HasSaveSphere        bool
	AirshipDropOff       bool
	HasCompilationSphere bool
	CanRideChocobo       bool
}

func (q *Queries) CreateArea(ctx context.Context, arg CreateAreaParams) (Area, error) {
	row := q.db.QueryRowContext(ctx, createArea,
		arg.DataHash,
		arg.SublocationID,
		arg.Name,
		arg.Version,
		arg.Specification,
		arg.StoryOnly,
		arg.HasSaveSphere,
		arg.AirshipDropOff,
		arg.HasCompilationSphere,
		arg.CanRideChocobo,
	)
	var i Area
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.SublocationID,
		&i.Name,
		&i.Version,
		&i.Specification,
		&i.StoryOnly,
		&i.HasSaveSphere,
		&i.AirshipDropOff,
		&i.HasCompilationSphere,
		&i.CanRideChocobo,
	)
	return i, err
}

const createAreaConnectedAreasJunction = `-- name: CreateAreaConnectedAreasJunction :exec
INSERT INTO j_area_connected_areas (data_hash, area_id, connection_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAreaConnectedAreasJunctionParams struct {
	DataHash     string
	AreaID       int32
	ConnectionID int32
}

func (q *Queries) CreateAreaConnectedAreasJunction(ctx context.Context, arg CreateAreaConnectedAreasJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAreaConnectedAreasJunction, arg.DataHash, arg.AreaID, arg.ConnectionID)
	return err
}

const createAreaConnection = `-- name: CreateAreaConnection :one
INSERT INTO area_connections (data_hash, area_id, connection_type, story_only, notes)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = area_connections.data_hash
RETURNING id, data_hash, area_id, connection_type, story_only, notes
`

type CreateAreaConnectionParams struct {
	DataHash       string
	AreaID         int32
	ConnectionType AreaConnectionType
	StoryOnly      bool
	Notes          sql.NullString
}

func (q *Queries) CreateAreaConnection(ctx context.Context, arg CreateAreaConnectionParams) (AreaConnection, error) {
	row := q.db.QueryRowContext(ctx, createAreaConnection,
		arg.DataHash,
		arg.AreaID,
		arg.ConnectionType,
		arg.StoryOnly,
		arg.Notes,
	)
	var i AreaConnection
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.AreaID,
		&i.ConnectionType,
		&i.StoryOnly,
		&i.Notes,
	)
	return i, err
}

const createEncounterLocation = `-- name: CreateEncounterLocation :one
INSERT INTO encounter_locations (data_hash, version, area_id, notes)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = encounter_locations.data_hash
RETURNING id, data_hash, version, area_id, notes
`

type CreateEncounterLocationParams struct {
	DataHash string
	Version  sql.NullInt32
	AreaID   int32
	Notes    sql.NullString
}

func (q *Queries) CreateEncounterLocation(ctx context.Context, arg CreateEncounterLocationParams) (EncounterLocation, error) {
	row := q.db.QueryRowContext(ctx, createEncounterLocation,
		arg.DataHash,
		arg.Version,
		arg.AreaID,
		arg.Notes,
	)
	var i EncounterLocation
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Version,
		&i.AreaID,
		&i.Notes,
	)
	return i, err
}

const createEncounterLocationFormationsJunction = `-- name: CreateEncounterLocationFormationsJunction :exec
INSERT INTO j_encounter_location_formations (data_hash, encounter_location_id, monster_formation_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateEncounterLocationFormationsJunctionParams struct {
	DataHash            string
	EncounterLocationID int32
	MonsterFormationID  int32
}

func (q *Queries) CreateEncounterLocationFormationsJunction(ctx context.Context, arg CreateEncounterLocationFormationsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createEncounterLocationFormationsJunction, arg.DataHash, arg.EncounterLocationID, arg.MonsterFormationID)
	return err
}

const createFormationBossSong = `-- name: CreateFormationBossSong :one
INSERT INTO formation_boss_songs (data_hash, song_id, celebrate_victory)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = formation_boss_songs.data_hash
RETURNING id, data_hash, song_id, celebrate_victory
`

type CreateFormationBossSongParams struct {
	DataHash         string
	SongID           int32
	CelebrateVictory bool
}

func (q *Queries) CreateFormationBossSong(ctx context.Context, arg CreateFormationBossSongParams) (FormationBossSong, error) {
	row := q.db.QueryRowContext(ctx, createFormationBossSong, arg.DataHash, arg.SongID, arg.CelebrateVictory)
	var i FormationBossSong
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.SongID,
		&i.CelebrateVictory,
	)
	return i, err
}

const createFoundEquipmentAbilitiesJunction = `-- name: CreateFoundEquipmentAbilitiesJunction :exec
INSERT INTO j_found_equipment_abilities (data_hash, found_equipment_id, auto_ability_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateFoundEquipmentAbilitiesJunctionParams struct {
	DataHash         string
	FoundEquipmentID int32
	AutoAbilityID    int32
}

func (q *Queries) CreateFoundEquipmentAbilitiesJunction(ctx context.Context, arg CreateFoundEquipmentAbilitiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createFoundEquipmentAbilitiesJunction, arg.DataHash, arg.FoundEquipmentID, arg.AutoAbilityID)
	return err
}

const createFoundEquipmentPiece = `-- name: CreateFoundEquipmentPiece :one
INSERT INTO found_equipment_pieces (data_hash, equipment_name_id, empty_slots_amount)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = found_equipment_pieces.data_hash
RETURNING id, data_hash, equipment_name_id, empty_slots_amount
`

type CreateFoundEquipmentPieceParams struct {
	DataHash         string
	EquipmentNameID  int32
	EmptySlotsAmount interface{}
}

func (q *Queries) CreateFoundEquipmentPiece(ctx context.Context, arg CreateFoundEquipmentPieceParams) (FoundEquipmentPiece, error) {
	row := q.db.QueryRowContext(ctx, createFoundEquipmentPiece, arg.DataHash, arg.EquipmentNameID, arg.EmptySlotsAmount)
	var i FoundEquipmentPiece
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.EquipmentNameID,
		&i.EmptySlotsAmount,
	)
	return i, err
}

const createLocation = `-- name: CreateLocation :one
INSERT INTO locations (data_hash, name)
VALUES ($1, $2)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = locations.data_hash
RETURNING id, data_hash, name
`

type CreateLocationParams struct {
	DataHash string
	Name     string
}

func (q *Queries) CreateLocation(ctx context.Context, arg CreateLocationParams) (Location, error) {
	row := q.db.QueryRowContext(ctx, createLocation, arg.DataHash, arg.Name)
	var i Location
	err := row.Scan(&i.ID, &i.DataHash, &i.Name)
	return i, err
}

const createMonsterFormation = `-- name: CreateMonsterFormation :one
INSERT INTO monster_formations (data_hash, category, is_forced_ambush, can_escape, boss_song_id, notes)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monster_formations.data_hash
RETURNING id, data_hash, category, is_forced_ambush, can_escape, boss_song_id, notes
`

type CreateMonsterFormationParams struct {
	DataHash       string
	Category       MonsterFormationCategory
	IsForcedAmbush bool
	CanEscape      bool
	BossSongID     sql.NullInt32
	Notes          sql.NullString
}

func (q *Queries) CreateMonsterFormation(ctx context.Context, arg CreateMonsterFormationParams) (MonsterFormation, error) {
	row := q.db.QueryRowContext(ctx, createMonsterFormation,
		arg.DataHash,
		arg.Category,
		arg.IsForcedAmbush,
		arg.CanEscape,
		arg.BossSongID,
		arg.Notes,
	)
	var i MonsterFormation
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Category,
		&i.IsForcedAmbush,
		&i.CanEscape,
		&i.BossSongID,
		&i.Notes,
	)
	return i, err
}

const createMonsterFormationsMonstersJunction = `-- name: CreateMonsterFormationsMonstersJunction :exec
INSERT INTO j_monster_formations_monsters (data_hash, monster_formation_id, monster_amount_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterFormationsMonstersJunctionParams struct {
	DataHash           string
	MonsterFormationID int32
	MonsterAmountID    int32
}

func (q *Queries) CreateMonsterFormationsMonstersJunction(ctx context.Context, arg CreateMonsterFormationsMonstersJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterFormationsMonstersJunction, arg.DataHash, arg.MonsterFormationID, arg.MonsterAmountID)
	return err
}

const createMonsterFormationsTriggerCommandsJunction = `-- name: CreateMonsterFormationsTriggerCommandsJunction :exec
INSERT INTO j_monster_formations_trigger_commands (data_hash, monster_formation_id, trigger_command_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterFormationsTriggerCommandsJunctionParams struct {
	DataHash           string
	MonsterFormationID int32
	TriggerCommandID   int32
}

func (q *Queries) CreateMonsterFormationsTriggerCommandsJunction(ctx context.Context, arg CreateMonsterFormationsTriggerCommandsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterFormationsTriggerCommandsJunction, arg.DataHash, arg.MonsterFormationID, arg.TriggerCommandID)
	return err
}

const createShop = `-- name: CreateShop :one
INSERT INTO shops (data_hash, version, area_id, notes, category)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = shops.data_hash
RETURNING id, data_hash, version, area_id, notes, category
`

type CreateShopParams struct {
	DataHash string
	Version  sql.NullInt32
	AreaID   int32
	Notes    sql.NullString
	Category ShopCategory
}

func (q *Queries) CreateShop(ctx context.Context, arg CreateShopParams) (Shop, error) {
	row := q.db.QueryRowContext(ctx, createShop,
		arg.DataHash,
		arg.Version,
		arg.AreaID,
		arg.Notes,
		arg.Category,
	)
	var i Shop
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Version,
		&i.AreaID,
		&i.Notes,
		&i.Category,
	)
	return i, err
}

const createShopEquipmentPiece = `-- name: CreateShopEquipmentPiece :one
INSERT INTO shop_equipment_pieces (data_hash, found_equipment_id, price)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = shop_equipment_pieces.data_hash
RETURNING id, data_hash, found_equipment_id, price
`

type CreateShopEquipmentPieceParams struct {
	DataHash         string
	FoundEquipmentID int32
	Price            int32
}

func (q *Queries) CreateShopEquipmentPiece(ctx context.Context, arg CreateShopEquipmentPieceParams) (ShopEquipmentPiece, error) {
	row := q.db.QueryRowContext(ctx, createShopEquipmentPiece, arg.DataHash, arg.FoundEquipmentID, arg.Price)
	var i ShopEquipmentPiece
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.FoundEquipmentID,
		&i.Price,
	)
	return i, err
}

const createShopItem = `-- name: CreateShopItem :one
INSERT INTO shop_items (data_hash, item_id, price)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = shop_items.data_hash
RETURNING id, data_hash, item_id, price
`

type CreateShopItemParams struct {
	DataHash string
	ItemID   int32
	Price    int32
}

func (q *Queries) CreateShopItem(ctx context.Context, arg CreateShopItemParams) (ShopItem, error) {
	row := q.db.QueryRowContext(ctx, createShopItem, arg.DataHash, arg.ItemID, arg.Price)
	var i ShopItem
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.ItemID,
		&i.Price,
	)
	return i, err
}

const createShopsEquipmentJunction = `-- name: CreateShopsEquipmentJunction :exec
INSERT INTO j_shops_equipment (data_hash, shop_id, shop_equipment_id, shop_type)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateShopsEquipmentJunctionParams struct {
	DataHash        string
	ShopID          int32
	ShopEquipmentID int32
	ShopType        ShopType
}

func (q *Queries) CreateShopsEquipmentJunction(ctx context.Context, arg CreateShopsEquipmentJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createShopsEquipmentJunction,
		arg.DataHash,
		arg.ShopID,
		arg.ShopEquipmentID,
		arg.ShopType,
	)
	return err
}

const createShopsItemsJunction = `-- name: CreateShopsItemsJunction :exec
INSERT INTO j_shops_items (data_hash, shop_id, shop_item_id, shop_type)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateShopsItemsJunctionParams struct {
	DataHash   string
	ShopID     int32
	ShopItemID int32
	ShopType   ShopType
}

func (q *Queries) CreateShopsItemsJunction(ctx context.Context, arg CreateShopsItemsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createShopsItemsJunction,
		arg.DataHash,
		arg.ShopID,
		arg.ShopItemID,
		arg.ShopType,
	)
	return err
}

const createSubLocation = `-- name: CreateSubLocation :one
INSERT INTO sublocations (data_hash, location_id, name, specification)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = sublocations.data_hash
RETURNING id, data_hash, location_id, name, specification
`

type CreateSubLocationParams struct {
	DataHash      string
	LocationID    int32
	Name          string
	Specification sql.NullString
}

func (q *Queries) CreateSubLocation(ctx context.Context, arg CreateSubLocationParams) (Sublocation, error) {
	row := q.db.QueryRowContext(ctx, createSubLocation,
		arg.DataHash,
		arg.LocationID,
		arg.Name,
		arg.Specification,
	)
	var i Sublocation
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.LocationID,
		&i.Name,
		&i.Specification,
	)
	return i, err
}

const createTreasure = `-- name: CreateTreasure :one
INSERT INTO treasures (data_hash, area_id, version, treasure_type, loot_type, is_post_airship, is_anima_treasure, notes, gil_amount)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = treasures.data_hash
RETURNING id, data_hash, area_id, version, treasure_type, loot_type, is_post_airship, is_anima_treasure, notes, gil_amount, found_equipment_id
`

type CreateTreasureParams struct {
	DataHash        string
	AreaID          int32
	Version         int32
	TreasureType    TreasureType
	LootType        LootType
	IsPostAirship   bool
	IsAnimaTreasure bool
	Notes           sql.NullString
	GilAmount       sql.NullInt32
}

func (q *Queries) CreateTreasure(ctx context.Context, arg CreateTreasureParams) (Treasure, error) {
	row := q.db.QueryRowContext(ctx, createTreasure,
		arg.DataHash,
		arg.AreaID,
		arg.Version,
		arg.TreasureType,
		arg.LootType,
		arg.IsPostAirship,
		arg.IsAnimaTreasure,
		arg.Notes,
		arg.GilAmount,
	)
	var i Treasure
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.AreaID,
		&i.Version,
		&i.TreasureType,
		&i.LootType,
		&i.IsPostAirship,
		&i.IsAnimaTreasure,
		&i.Notes,
		&i.GilAmount,
		&i.FoundEquipmentID,
	)
	return i, err
}

const createTreasuresItemsJunction = `-- name: CreateTreasuresItemsJunction :exec
INSERT INTO j_treasures_items (data_hash, treasure_id, item_amount_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateTreasuresItemsJunctionParams struct {
	DataHash     string
	TreasureID   int32
	ItemAmountID int32
}

func (q *Queries) CreateTreasuresItemsJunction(ctx context.Context, arg CreateTreasuresItemsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createTreasuresItemsJunction, arg.DataHash, arg.TreasureID, arg.ItemAmountID)
	return err
}

const updateTreasure = `-- name: UpdateTreasure :exec
UPDATE treasures
SET data_hash = $1,
    found_equipment_id = $2
WHERE id = $3
`

type UpdateTreasureParams struct {
	DataHash         string
	FoundEquipmentID sql.NullInt32
	ID               int32
}

func (q *Queries) UpdateTreasure(ctx context.Context, arg UpdateTreasureParams) error {
	_, err := q.db.ExecContext(ctx, updateTreasure, arg.DataHash, arg.FoundEquipmentID, arg.ID)
	return err
}

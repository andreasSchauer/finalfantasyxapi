// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: items.sql

package database

import (
	"context"
	"database/sql"
)

const createItem = `-- name: CreateItem :one
INSERT INTO items (data_hash, master_item_id, description, effect, sphere_grid_description, category, usability, base_price, sell_value)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = items.data_hash
RETURNING id, data_hash, master_item_id, description, effect, sphere_grid_description, category, usability, base_price, sell_value
`

type CreateItemParams struct {
	DataHash              string
	MasterItemID          int32
	Description           string
	Effect                string
	SphereGridDescription sql.NullString
	Category              ItemCategory
	Usability             NullItemUsability
	BasePrice             sql.NullInt32
	SellValue             int32
}

func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) (Item, error) {
	row := q.db.QueryRowContext(ctx, createItem,
		arg.DataHash,
		arg.MasterItemID,
		arg.Description,
		arg.Effect,
		arg.SphereGridDescription,
		arg.Category,
		arg.Usability,
		arg.BasePrice,
		arg.SellValue,
	)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.MasterItemID,
		&i.Description,
		&i.Effect,
		&i.SphereGridDescription,
		&i.Category,
		&i.Usability,
		&i.BasePrice,
		&i.SellValue,
	)
	return i, err
}

const createItemAbility = `-- name: CreateItemAbility :one
INSERT INTO item_abilities (data_hash, item_id, ability_id, cursor)
VALUES ($1, $2, $3, $4)
ON CONFLICT (data_hash) DO UPDATE SET data_hash = item_abilities.data_hash
RETURNING id, data_hash, item_id, ability_id, cursor
`

type CreateItemAbilityParams struct {
	DataHash  string
	ItemID    int32
	AbilityID int32
	Cursor    TargetType
}

func (q *Queries) CreateItemAbility(ctx context.Context, arg CreateItemAbilityParams) (ItemAbility, error) {
	row := q.db.QueryRowContext(ctx, createItemAbility,
		arg.DataHash,
		arg.ItemID,
		arg.AbilityID,
		arg.Cursor,
	)
	var i ItemAbility
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.ItemID,
		&i.AbilityID,
		&i.Cursor,
	)
	return i, err
}

const createItemAmount = `-- name: CreateItemAmount :one
INSERT INTO item_amounts (data_hash, master_item_id, amount)
VALUES ( $1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = item_amounts.data_hash
RETURNING id, data_hash, master_item_id, amount
`

type CreateItemAmountParams struct {
	DataHash     string
	MasterItemID int32
	Amount       int32
}

func (q *Queries) CreateItemAmount(ctx context.Context, arg CreateItemAmountParams) (ItemAmount, error) {
	row := q.db.QueryRowContext(ctx, createItemAmount, arg.DataHash, arg.MasterItemID, arg.Amount)
	var i ItemAmount
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.MasterItemID,
		&i.Amount,
	)
	return i, err
}

const createKeyItem = `-- name: CreateKeyItem :one
INSERT INTO key_items (data_hash, master_item_id, category, description, effect)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = key_items.data_hash
RETURNING id, data_hash, master_item_id, category, description, effect
`

type CreateKeyItemParams struct {
	DataHash     string
	MasterItemID int32
	Category     KeyItemCategory
	Description  string
	Effect       string
}

func (q *Queries) CreateKeyItem(ctx context.Context, arg CreateKeyItemParams) (KeyItem, error) {
	row := q.db.QueryRowContext(ctx, createKeyItem,
		arg.DataHash,
		arg.MasterItemID,
		arg.Category,
		arg.Description,
		arg.Effect,
	)
	var i KeyItem
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.MasterItemID,
		&i.Category,
		&i.Description,
		&i.Effect,
	)
	return i, err
}

const createMasterItem = `-- name: CreateMasterItem :one
INSERT INTO master_items (data_hash, name, type)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = master_items.data_hash
RETURNING id, data_hash, name, type
`

type CreateMasterItemParams struct {
	DataHash string
	Name     string
	Type     ItemType
}

func (q *Queries) CreateMasterItem(ctx context.Context, arg CreateMasterItemParams) (MasterItem, error) {
	row := q.db.QueryRowContext(ctx, createMasterItem, arg.DataHash, arg.Name, arg.Type)
	var i MasterItem
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Name,
		&i.Type,
	)
	return i, err
}

const createMix = `-- name: CreateMix :one
INSERT INTO mixes (data_hash, overdrive_id, category)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = mixes.data_hash
RETURNING id, data_hash, overdrive_id, category
`

type CreateMixParams struct {
	DataHash    string
	OverdriveID int32
	Category    MixCategory
}

func (q *Queries) CreateMix(ctx context.Context, arg CreateMixParams) (Mix, error) {
	row := q.db.QueryRowContext(ctx, createMix, arg.DataHash, arg.OverdriveID, arg.Category)
	var i Mix
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.OverdriveID,
		&i.Category,
	)
	return i, err
}

const createMixCombination = `-- name: CreateMixCombination :one
INSERT INTO mix_combinations (data_hash, first_item_id, second_item_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = mix_combinations.data_hash
RETURNING id, data_hash, first_item_id, second_item_id
`

type CreateMixCombinationParams struct {
	DataHash     string
	FirstItemID  int32
	SecondItemID int32
}

func (q *Queries) CreateMixCombination(ctx context.Context, arg CreateMixCombinationParams) (MixCombination, error) {
	row := q.db.QueryRowContext(ctx, createMixCombination, arg.DataHash, arg.FirstItemID, arg.SecondItemID)
	var i MixCombination
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.FirstItemID,
		&i.SecondItemID,
	)
	return i, err
}

const createMixesCombinationsJunction = `-- name: CreateMixesCombinationsJunction :exec
INSERT INTO j_mixes_combinations (data_hash, mix_id, combo_id, is_best_combo)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMixesCombinationsJunctionParams struct {
	DataHash    string
	MixID       int32
	ComboID     int32
	IsBestCombo bool
}

func (q *Queries) CreateMixesCombinationsJunction(ctx context.Context, arg CreateMixesCombinationsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMixesCombinationsJunction,
		arg.DataHash,
		arg.MixID,
		arg.ComboID,
		arg.IsBestCombo,
	)
	return err
}

const createPrimer = `-- name: CreatePrimer :exec
INSERT INTO primers (data_hash, key_item_id, al_bhed_letter, english_letter)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO NOTHING
`

type CreatePrimerParams struct {
	DataHash      string
	KeyItemID     int32
	AlBhedLetter  string
	EnglishLetter string
}

func (q *Queries) CreatePrimer(ctx context.Context, arg CreatePrimerParams) error {
	_, err := q.db.ExecContext(ctx, createPrimer,
		arg.DataHash,
		arg.KeyItemID,
		arg.AlBhedLetter,
		arg.EnglishLetter,
	)
	return err
}

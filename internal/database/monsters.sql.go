// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: monsters.sql

package database

import (
	"context"
	"database/sql"
)

const createAltStateChange = `-- name: CreateAltStateChange :one
INSERT INTO alt_state_changes (data_hash, altered_state_id, alteration_type, distance)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = alt_state_changes.data_hash
RETURNING id, data_hash, altered_state_id, alteration_type, distance
`

type CreateAltStateChangeParams struct {
	DataHash       string
	AlteredStateID int32
	AlterationType AlterationType
	Distance       interface{}
}

func (q *Queries) CreateAltStateChange(ctx context.Context, arg CreateAltStateChangeParams) (AltStateChange, error) {
	row := q.db.QueryRowContext(ctx, createAltStateChange,
		arg.DataHash,
		arg.AlteredStateID,
		arg.AlterationType,
		arg.Distance,
	)
	var i AltStateChange
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.AlteredStateID,
		&i.AlterationType,
		&i.Distance,
	)
	return i, err
}

const createAltStateChangesAddedStatussesJunction = `-- name: CreateAltStateChangesAddedStatussesJunction :exec
INSERT INTO j_alt_state_changes_added_statusses (data_hash, alt_state_change_id, inflicted_status_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAltStateChangesAddedStatussesJunctionParams struct {
	DataHash          string
	AltStateChangeID  int32
	InflictedStatusID int32
}

func (q *Queries) CreateAltStateChangesAddedStatussesJunction(ctx context.Context, arg CreateAltStateChangesAddedStatussesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAltStateChangesAddedStatussesJunction, arg.DataHash, arg.AltStateChangeID, arg.InflictedStatusID)
	return err
}

const createAltStateChangesAutoAbilitiesJunction = `-- name: CreateAltStateChangesAutoAbilitiesJunction :exec
INSERT INTO j_alt_state_changes_auto_abilities (data_hash, alt_state_change_id, auto_ability_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAltStateChangesAutoAbilitiesJunctionParams struct {
	DataHash         string
	AltStateChangeID int32
	AutoAbilityID    int32
}

func (q *Queries) CreateAltStateChangesAutoAbilitiesJunction(ctx context.Context, arg CreateAltStateChangesAutoAbilitiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAltStateChangesAutoAbilitiesJunction, arg.DataHash, arg.AltStateChangeID, arg.AutoAbilityID)
	return err
}

const createAltStateChangesBaseStatsJunction = `-- name: CreateAltStateChangesBaseStatsJunction :exec
INSERT INTO j_alt_state_changes_base_stats (data_hash, alt_state_change_id, base_stat_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAltStateChangesBaseStatsJunctionParams struct {
	DataHash         string
	AltStateChangeID int32
	BaseStatID       int32
}

func (q *Queries) CreateAltStateChangesBaseStatsJunction(ctx context.Context, arg CreateAltStateChangesBaseStatsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAltStateChangesBaseStatsJunction, arg.DataHash, arg.AltStateChangeID, arg.BaseStatID)
	return err
}

const createAltStateChangesElemResistsJunction = `-- name: CreateAltStateChangesElemResistsJunction :exec
INSERT INTO j_alt_state_changes_elem_resists (data_hash, alt_state_change_id, elem_resist_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAltStateChangesElemResistsJunctionParams struct {
	DataHash         string
	AltStateChangeID int32
	ElemResistID     int32
}

func (q *Queries) CreateAltStateChangesElemResistsJunction(ctx context.Context, arg CreateAltStateChangesElemResistsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAltStateChangesElemResistsJunction, arg.DataHash, arg.AltStateChangeID, arg.ElemResistID)
	return err
}

const createAltStateChangesPropertiesJunction = `-- name: CreateAltStateChangesPropertiesJunction :exec
INSERT INTO j_alt_state_changes_properties (data_hash, alt_state_change_id, property_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAltStateChangesPropertiesJunctionParams struct {
	DataHash         string
	AltStateChangeID int32
	PropertyID       int32
}

func (q *Queries) CreateAltStateChangesPropertiesJunction(ctx context.Context, arg CreateAltStateChangesPropertiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAltStateChangesPropertiesJunction, arg.DataHash, arg.AltStateChangeID, arg.PropertyID)
	return err
}

const createAltStateChangesStatusImmunitiesJunction = `-- name: CreateAltStateChangesStatusImmunitiesJunction :exec
INSERT INTO j_alt_state_changes_status_immunities (data_hash, alt_state_change_id, status_condition_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAltStateChangesStatusImmunitiesJunctionParams struct {
	DataHash          string
	AltStateChangeID  int32
	StatusConditionID int32
}

func (q *Queries) CreateAltStateChangesStatusImmunitiesJunction(ctx context.Context, arg CreateAltStateChangesStatusImmunitiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAltStateChangesStatusImmunitiesJunction, arg.DataHash, arg.AltStateChangeID, arg.StatusConditionID)
	return err
}

const createAlteredState = `-- name: CreateAlteredState :one
INSERT INTO altered_states (data_hash, monster_id, condition, is_temporary)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = altered_states.data_hash
RETURNING id, data_hash, monster_id, condition, is_temporary
`

type CreateAlteredStateParams struct {
	DataHash    string
	MonsterID   int32
	Condition   string
	IsTemporary bool
}

func (q *Queries) CreateAlteredState(ctx context.Context, arg CreateAlteredStateParams) (AlteredState, error) {
	row := q.db.QueryRowContext(ctx, createAlteredState,
		arg.DataHash,
		arg.MonsterID,
		arg.Condition,
		arg.IsTemporary,
	)
	var i AlteredState
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.MonsterID,
		&i.Condition,
		&i.IsTemporary,
	)
	return i, err
}

const createEquipmentDrop = `-- name: CreateEquipmentDrop :one
INSERT INTO equipment_drops (data_hash, auto_ability_id, is_forced, probability, type)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = equipment_drops.data_hash
RETURNING id, data_hash, auto_ability_id, is_forced, probability, type
`

type CreateEquipmentDropParams struct {
	DataHash      string
	AutoAbilityID int32
	IsForced      bool
	Probability   interface{}
	Type          EquipType
}

func (q *Queries) CreateEquipmentDrop(ctx context.Context, arg CreateEquipmentDropParams) (EquipmentDrop, error) {
	row := q.db.QueryRowContext(ctx, createEquipmentDrop,
		arg.DataHash,
		arg.AutoAbilityID,
		arg.IsForced,
		arg.Probability,
		arg.Type,
	)
	var i EquipmentDrop
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.AutoAbilityID,
		&i.IsForced,
		&i.Probability,
		&i.Type,
	)
	return i, err
}

const createEquipmentDropsCharactersJunction = `-- name: CreateEquipmentDropsCharactersJunction :exec
INSERT INTO j_equipment_drops_characters (data_hash, monster_equipment_id, equipment_drop_id, character_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateEquipmentDropsCharactersJunctionParams struct {
	DataHash           string
	MonsterEquipmentID int32
	EquipmentDropID    int32
	CharacterID        int32
}

func (q *Queries) CreateEquipmentDropsCharactersJunction(ctx context.Context, arg CreateEquipmentDropsCharactersJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createEquipmentDropsCharactersJunction,
		arg.DataHash,
		arg.MonsterEquipmentID,
		arg.EquipmentDropID,
		arg.CharacterID,
	)
	return err
}

const createEquipmentSlotsChance = `-- name: CreateEquipmentSlotsChance :one
INSERT INTO equipment_slots_chances (data_hash, amount, chance)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = equipment_slots_chances.data_hash
RETURNING id, data_hash, amount, chance
`

type CreateEquipmentSlotsChanceParams struct {
	DataHash string
	Amount   interface{}
	Chance   interface{}
}

func (q *Queries) CreateEquipmentSlotsChance(ctx context.Context, arg CreateEquipmentSlotsChanceParams) (EquipmentSlotsChance, error) {
	row := q.db.QueryRowContext(ctx, createEquipmentSlotsChance, arg.DataHash, arg.Amount, arg.Chance)
	var i EquipmentSlotsChance
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Amount,
		&i.Chance,
	)
	return i, err
}

const createMonster = `-- name: CreateMonster :one
INSERT INTO monsters (data_hash, name, version, specification, notes, species, is_story_based, can_be_captured, area_conquest_location, ctb_icon_type, has_overdrive, is_underwater, is_zombie, distance, ap, ap_overkill, overkill_damage, gil, steal_gil, doom_countdown, poison_rate, threaten_chance, zanmato_level, monster_arena_price, sensor_text, scan_text)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monsters.data_hash
RETURNING id, data_hash, name, version, specification, notes, species, is_story_based, can_be_captured, area_conquest_location, ctb_icon_type, has_overdrive, is_underwater, is_zombie, distance, ap, ap_overkill, overkill_damage, gil, steal_gil, doom_countdown, poison_rate, threaten_chance, zanmato_level, monster_arena_price, sensor_text, scan_text
`

type CreateMonsterParams struct {
	DataHash             string
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	Notes                sql.NullString
	Species              MonsterSpecies
	IsStoryBased         bool
	CanBeCaptured        bool
	AreaConquestLocation NullMaCreationArea
	CtbIconType          CtbIconType
	HasOverdrive         bool
	IsUnderwater         bool
	IsZombie             bool
	Distance             interface{}
	Ap                   int32
	ApOverkill           int32
	OverkillDamage       int32
	Gil                  int32
	StealGil             sql.NullInt32
	DoomCountdown        interface{}
	PoisonRate           interface{}
	ThreatenChance       interface{}
	ZanmatoLevel         interface{}
	MonsterArenaPrice    sql.NullInt32
	SensorText           sql.NullString
	ScanText             sql.NullString
}

func (q *Queries) CreateMonster(ctx context.Context, arg CreateMonsterParams) (Monster, error) {
	row := q.db.QueryRowContext(ctx, createMonster,
		arg.DataHash,
		arg.Name,
		arg.Version,
		arg.Specification,
		arg.Notes,
		arg.Species,
		arg.IsStoryBased,
		arg.CanBeCaptured,
		arg.AreaConquestLocation,
		arg.CtbIconType,
		arg.HasOverdrive,
		arg.IsUnderwater,
		arg.IsZombie,
		arg.Distance,
		arg.Ap,
		arg.ApOverkill,
		arg.OverkillDamage,
		arg.Gil,
		arg.StealGil,
		arg.DoomCountdown,
		arg.PoisonRate,
		arg.ThreatenChance,
		arg.ZanmatoLevel,
		arg.MonsterArenaPrice,
		arg.SensorText,
		arg.ScanText,
	)
	var i Monster
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Name,
		&i.Version,
		&i.Specification,
		&i.Notes,
		&i.Species,
		&i.IsStoryBased,
		&i.CanBeCaptured,
		&i.AreaConquestLocation,
		&i.CtbIconType,
		&i.HasOverdrive,
		&i.IsUnderwater,
		&i.IsZombie,
		&i.Distance,
		&i.Ap,
		&i.ApOverkill,
		&i.OverkillDamage,
		&i.Gil,
		&i.StealGil,
		&i.DoomCountdown,
		&i.PoisonRate,
		&i.ThreatenChance,
		&i.ZanmatoLevel,
		&i.MonsterArenaPrice,
		&i.SensorText,
		&i.ScanText,
	)
	return i, err
}

const createMonsterAbility = `-- name: CreateMonsterAbility :one
INSERT INTO monster_abilities (data_hash, ability_id, is_forced, is_unused)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monster_abilities.data_hash
RETURNING id, data_hash, ability_id, is_forced, is_unused
`

type CreateMonsterAbilityParams struct {
	DataHash  string
	AbilityID int32
	IsForced  bool
	IsUnused  bool
}

func (q *Queries) CreateMonsterAbility(ctx context.Context, arg CreateMonsterAbilityParams) (MonsterAbility, error) {
	row := q.db.QueryRowContext(ctx, createMonsterAbility,
		arg.DataHash,
		arg.AbilityID,
		arg.IsForced,
		arg.IsUnused,
	)
	var i MonsterAbility
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.AbilityID,
		&i.IsForced,
		&i.IsUnused,
	)
	return i, err
}

const createMonsterAmount = `-- name: CreateMonsterAmount :one
INSERT INTO monster_amounts (data_hash, monster_id, amount)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monster_amounts.data_hash
RETURNING id, data_hash, monster_id, amount
`

type CreateMonsterAmountParams struct {
	DataHash  string
	MonsterID int32
	Amount    int32
}

func (q *Queries) CreateMonsterAmount(ctx context.Context, arg CreateMonsterAmountParams) (MonsterAmount, error) {
	row := q.db.QueryRowContext(ctx, createMonsterAmount, arg.DataHash, arg.MonsterID, arg.Amount)
	var i MonsterAmount
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.MonsterID,
		&i.Amount,
	)
	return i, err
}

const createMonsterEquipment = `-- name: CreateMonsterEquipment :one
INSERT INTO monster_equipment (data_hash, monster_id, drop_chance, power, critical_plus)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monster_equipment.data_hash
RETURNING id, data_hash, monster_id, drop_chance, power, critical_plus
`

type CreateMonsterEquipmentParams struct {
	DataHash     string
	MonsterID    int32
	DropChance   interface{}
	Power        interface{}
	CriticalPlus int32
}

func (q *Queries) CreateMonsterEquipment(ctx context.Context, arg CreateMonsterEquipmentParams) (MonsterEquipment, error) {
	row := q.db.QueryRowContext(ctx, createMonsterEquipment,
		arg.DataHash,
		arg.MonsterID,
		arg.DropChance,
		arg.Power,
		arg.CriticalPlus,
	)
	var i MonsterEquipment
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.MonsterID,
		&i.DropChance,
		&i.Power,
		&i.CriticalPlus,
	)
	return i, err
}

const createMonsterEquipmentAbilitiesJunction = `-- name: CreateMonsterEquipmentAbilitiesJunction :exec
INSERT INTO j_monster_equipment_abilities (data_hash, monster_equipment_id, equipment_drop_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterEquipmentAbilitiesJunctionParams struct {
	DataHash           string
	MonsterEquipmentID int32
	EquipmentDropID    int32
}

func (q *Queries) CreateMonsterEquipmentAbilitiesJunction(ctx context.Context, arg CreateMonsterEquipmentAbilitiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterEquipmentAbilitiesJunction, arg.DataHash, arg.MonsterEquipmentID, arg.EquipmentDropID)
	return err
}

const createMonsterEquipmentSlots = `-- name: CreateMonsterEquipmentSlots :one
INSERT INTO monster_equipment_slots (data_hash, monster_equipment_id, min_amount, max_amount, type)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monster_equipment_slots.data_hash
RETURNING id, data_hash, monster_equipment_id, min_amount, max_amount, type
`

type CreateMonsterEquipmentSlotsParams struct {
	DataHash           string
	MonsterEquipmentID int32
	MinAmount          interface{}
	MaxAmount          interface{}
	Type               EquipmentSlotsType
}

func (q *Queries) CreateMonsterEquipmentSlots(ctx context.Context, arg CreateMonsterEquipmentSlotsParams) (MonsterEquipmentSlot, error) {
	row := q.db.QueryRowContext(ctx, createMonsterEquipmentSlots,
		arg.DataHash,
		arg.MonsterEquipmentID,
		arg.MinAmount,
		arg.MaxAmount,
		arg.Type,
	)
	var i MonsterEquipmentSlot
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.MonsterEquipmentID,
		&i.MinAmount,
		&i.MaxAmount,
		&i.Type,
	)
	return i, err
}

const createMonsterEquipmentSlotsChancesJunction = `-- name: CreateMonsterEquipmentSlotsChancesJunction :exec
INSERT INTO j_monster_equipment_slots_chances(data_hash, monster_equipment_id, equipment_slots_id, slots_chance_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterEquipmentSlotsChancesJunctionParams struct {
	DataHash           string
	MonsterEquipmentID int32
	EquipmentSlotsID   int32
	SlotsChanceID      int32
}

func (q *Queries) CreateMonsterEquipmentSlotsChancesJunction(ctx context.Context, arg CreateMonsterEquipmentSlotsChancesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterEquipmentSlotsChancesJunction,
		arg.DataHash,
		arg.MonsterEquipmentID,
		arg.EquipmentSlotsID,
		arg.SlotsChanceID,
	)
	return err
}

const createMonsterItem = `-- name: CreateMonsterItem :one
INSERT INTO monster_items (data_hash, monster_id, drop_chance, drop_condition, other_items_condition, steal_common_id, steal_rare_id, drop_common_id, drop_rare_id, secondary_drop_common_id, secondary_drop_rare_id, bribe_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monster_items.data_hash
RETURNING id, data_hash, monster_id, drop_chance, drop_condition, other_items_condition, steal_common_id, steal_rare_id, drop_common_id, drop_rare_id, secondary_drop_common_id, secondary_drop_rare_id, bribe_id
`

type CreateMonsterItemParams struct {
	DataHash              string
	MonsterID             int32
	DropChance            interface{}
	DropCondition         sql.NullString
	OtherItemsCondition   sql.NullString
	StealCommonID         sql.NullInt32
	StealRareID           sql.NullInt32
	DropCommonID          sql.NullInt32
	DropRareID            sql.NullInt32
	SecondaryDropCommonID sql.NullInt32
	SecondaryDropRareID   sql.NullInt32
	BribeID               sql.NullInt32
}

func (q *Queries) CreateMonsterItem(ctx context.Context, arg CreateMonsterItemParams) (MonsterItem, error) {
	row := q.db.QueryRowContext(ctx, createMonsterItem,
		arg.DataHash,
		arg.MonsterID,
		arg.DropChance,
		arg.DropCondition,
		arg.OtherItemsCondition,
		arg.StealCommonID,
		arg.StealRareID,
		arg.DropCommonID,
		arg.DropRareID,
		arg.SecondaryDropCommonID,
		arg.SecondaryDropRareID,
		arg.BribeID,
	)
	var i MonsterItem
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.MonsterID,
		&i.DropChance,
		&i.DropCondition,
		&i.OtherItemsCondition,
		&i.StealCommonID,
		&i.StealRareID,
		&i.DropCommonID,
		&i.DropRareID,
		&i.SecondaryDropCommonID,
		&i.SecondaryDropRareID,
		&i.BribeID,
	)
	return i, err
}

const createMonsterItemsOtherItemsJunction = `-- name: CreateMonsterItemsOtherItemsJunction :exec
INSERT INTO j_monster_items_other_items (data_hash, monster_items_id, possible_item_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterItemsOtherItemsJunctionParams struct {
	DataHash       string
	MonsterItemsID int32
	PossibleItemID int32
}

func (q *Queries) CreateMonsterItemsOtherItemsJunction(ctx context.Context, arg CreateMonsterItemsOtherItemsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterItemsOtherItemsJunction, arg.DataHash, arg.MonsterItemsID, arg.PossibleItemID)
	return err
}

const createMonstersAbilitiesJunction = `-- name: CreateMonstersAbilitiesJunction :exec
INSERT INTO j_monsters_abilities (data_hash, monster_id, monster_ability_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersAbilitiesJunctionParams struct {
	DataHash         string
	MonsterID        int32
	MonsterAbilityID int32
}

func (q *Queries) CreateMonstersAbilitiesJunction(ctx context.Context, arg CreateMonstersAbilitiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersAbilitiesJunction, arg.DataHash, arg.MonsterID, arg.MonsterAbilityID)
	return err
}

const createMonstersAutoAbilitiesJunction = `-- name: CreateMonstersAutoAbilitiesJunction :exec
INSERT INTO j_monsters_auto_abilities (data_hash, monster_id, auto_ability_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersAutoAbilitiesJunctionParams struct {
	DataHash      string
	MonsterID     int32
	AutoAbilityID int32
}

func (q *Queries) CreateMonstersAutoAbilitiesJunction(ctx context.Context, arg CreateMonstersAutoAbilitiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersAutoAbilitiesJunction, arg.DataHash, arg.MonsterID, arg.AutoAbilityID)
	return err
}

const createMonstersBaseStatsJunction = `-- name: CreateMonstersBaseStatsJunction :exec
INSERT INTO j_monsters_base_stats (data_hash, monster_id, base_stat_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersBaseStatsJunctionParams struct {
	DataHash   string
	MonsterID  int32
	BaseStatID int32
}

func (q *Queries) CreateMonstersBaseStatsJunction(ctx context.Context, arg CreateMonstersBaseStatsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersBaseStatsJunction, arg.DataHash, arg.MonsterID, arg.BaseStatID)
	return err
}

const createMonstersElemResistsJunction = `-- name: CreateMonstersElemResistsJunction :exec
INSERT INTO j_monsters_elem_resists (data_hash, monster_id, elem_resist_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersElemResistsJunctionParams struct {
	DataHash     string
	MonsterID    int32
	ElemResistID int32
}

func (q *Queries) CreateMonstersElemResistsJunction(ctx context.Context, arg CreateMonstersElemResistsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersElemResistsJunction, arg.DataHash, arg.MonsterID, arg.ElemResistID)
	return err
}

const createMonstersImmunitiesJunction = `-- name: CreateMonstersImmunitiesJunction :exec
INSERT INTO j_monsters_immunities (data_hash, monster_id, status_condition_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersImmunitiesJunctionParams struct {
	DataHash          string
	MonsterID         int32
	StatusConditionID int32
}

func (q *Queries) CreateMonstersImmunitiesJunction(ctx context.Context, arg CreateMonstersImmunitiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersImmunitiesJunction, arg.DataHash, arg.MonsterID, arg.StatusConditionID)
	return err
}

const createMonstersPropertiesJunction = `-- name: CreateMonstersPropertiesJunction :exec
INSERT INTO j_monsters_properties (data_hash, monster_id, property_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersPropertiesJunctionParams struct {
	DataHash   string
	MonsterID  int32
	PropertyID int32
}

func (q *Queries) CreateMonstersPropertiesJunction(ctx context.Context, arg CreateMonstersPropertiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersPropertiesJunction, arg.DataHash, arg.MonsterID, arg.PropertyID)
	return err
}

const createMonstersRonsoRagesJunction = `-- name: CreateMonstersRonsoRagesJunction :exec
INSERT INTO j_monsters_ronso_rages (data_hash, monster_id, overdrive_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersRonsoRagesJunctionParams struct {
	DataHash    string
	MonsterID   int32
	OverdriveID int32
}

func (q *Queries) CreateMonstersRonsoRagesJunction(ctx context.Context, arg CreateMonstersRonsoRagesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersRonsoRagesJunction, arg.DataHash, arg.MonsterID, arg.OverdriveID)
	return err
}

const createMonstersStatusResistsJunction = `-- name: CreateMonstersStatusResistsJunction :exec
INSERT INTO j_monsters_status_resists (data_hash, monster_id, status_resist_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersStatusResistsJunctionParams struct {
	DataHash       string
	MonsterID      int32
	StatusResistID int32
}

func (q *Queries) CreateMonstersStatusResistsJunction(ctx context.Context, arg CreateMonstersStatusResistsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersStatusResistsJunction, arg.DataHash, arg.MonsterID, arg.StatusResistID)
	return err
}

const getEquipmentDropCharacters = `-- name: GetEquipmentDropCharacters :many
SELECT
    c.id AS character_id,
    pu.name AS character_name
FROM j_equipment_drops_characters jedc
LEFT JOIN characters c ON jedc.character_id = c.id
LEFT JOIN player_units pu ON c.unit_id = pu.id
WHERE jedc.monster_equipment_id = $1
AND jedc.equipment_drop_id = $2
`

type GetEquipmentDropCharactersParams struct {
	MonsterEquipmentID int32
	EquipmentDropID    int32
}

type GetEquipmentDropCharactersRow struct {
	CharacterID   sql.NullInt32
	CharacterName sql.NullString
}

func (q *Queries) GetEquipmentDropCharacters(ctx context.Context, arg GetEquipmentDropCharactersParams) ([]GetEquipmentDropCharactersRow, error) {
	rows, err := q.db.QueryContext(ctx, getEquipmentDropCharacters, arg.MonsterEquipmentID, arg.EquipmentDropID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEquipmentDropCharactersRow
	for rows.Next() {
		var i GetEquipmentDropCharactersRow
		if err := rows.Scan(&i.CharacterID, &i.CharacterName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonster = `-- name: GetMonster :one
SELECT id, data_hash, name, version, specification, notes, species, is_story_based, can_be_captured, area_conquest_location, ctb_icon_type, has_overdrive, is_underwater, is_zombie, distance, ap, ap_overkill, overkill_damage, gil, steal_gil, doom_countdown, poison_rate, threaten_chance, zanmato_level, monster_arena_price, sensor_text, scan_text FROM monsters WHERE id = $1
`

func (q *Queries) GetMonster(ctx context.Context, id int32) (Monster, error) {
	row := q.db.QueryRowContext(ctx, getMonster, id)
	var i Monster
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Name,
		&i.Version,
		&i.Specification,
		&i.Notes,
		&i.Species,
		&i.IsStoryBased,
		&i.CanBeCaptured,
		&i.AreaConquestLocation,
		&i.CtbIconType,
		&i.HasOverdrive,
		&i.IsUnderwater,
		&i.IsZombie,
		&i.Distance,
		&i.Ap,
		&i.ApOverkill,
		&i.OverkillDamage,
		&i.Gil,
		&i.StealGil,
		&i.DoomCountdown,
		&i.PoisonRate,
		&i.ThreatenChance,
		&i.ZanmatoLevel,
		&i.MonsterArenaPrice,
		&i.SensorText,
		&i.ScanText,
	)
	return i, err
}

const getMonsterEquipment = `-- name: GetMonsterEquipment :one
SELECT id, data_hash, monster_id, drop_chance, power, critical_plus FROM monster_equipment WHERE monster_id = $1
`

func (q *Queries) GetMonsterEquipment(ctx context.Context, monsterID int32) (MonsterEquipment, error) {
	row := q.db.QueryRowContext(ctx, getMonsterEquipment, monsterID)
	var i MonsterEquipment
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.MonsterID,
		&i.DropChance,
		&i.Power,
		&i.CriticalPlus,
	)
	return i, err
}

const getMonsterEquipmentAbilities = `-- name: GetMonsterEquipmentAbilities :many
SELECT
    ed.id AS id,
    aa.name AS auto_ability,
    aa.id AS auto_ability_id,
    ed.is_forced AS is_forced,
    ed.probability AS probability
FROM j_monster_equipment_abilities jmea
LEFT JOIN equipment_drops ed ON jmea.equipment_drop_id = ed.id
LEFT JOIN auto_abilities aa ON ed.auto_ability_id = aa.id
WHERE jmea.monster_equipment_id = $1
AND ed.type = $2
`

type GetMonsterEquipmentAbilitiesParams struct {
	MonsterEquipmentID int32
	Type               EquipType
}

type GetMonsterEquipmentAbilitiesRow struct {
	ID            sql.NullInt32
	AutoAbility   sql.NullString
	AutoAbilityID sql.NullInt32
	IsForced      sql.NullBool
	Probability   interface{}
}

func (q *Queries) GetMonsterEquipmentAbilities(ctx context.Context, arg GetMonsterEquipmentAbilitiesParams) ([]GetMonsterEquipmentAbilitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonsterEquipmentAbilities, arg.MonsterEquipmentID, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonsterEquipmentAbilitiesRow
	for rows.Next() {
		var i GetMonsterEquipmentAbilitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.AutoAbility,
			&i.AutoAbilityID,
			&i.IsForced,
			&i.Probability,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonsterEquipmentSlots = `-- name: GetMonsterEquipmentSlots :many
SELECT id, data_hash, monster_equipment_id, min_amount, max_amount, type FROM monster_equipment_slots
WHERE monster_equipment_id = $1
ORDER BY id
`

func (q *Queries) GetMonsterEquipmentSlots(ctx context.Context, monsterEquipmentID int32) ([]MonsterEquipmentSlot, error) {
	rows, err := q.db.QueryContext(ctx, getMonsterEquipmentSlots, monsterEquipmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MonsterEquipmentSlot
	for rows.Next() {
		var i MonsterEquipmentSlot
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.MonsterEquipmentID,
			&i.MinAmount,
			&i.MaxAmount,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonsterEquipmentSlotsChances = `-- name: GetMonsterEquipmentSlotsChances :many
SELECT
    esc.amount AS amount,
    esc.chance AS chance
FROM equipment_slots_chances esc
LEFT JOIN j_monster_equipment_slots_chances jmesc ON jmesc.slots_chance_id = esc.id
WHERE jmesc.monster_equipment_id = $1
AND jmesc.equipment_slots_id = $2
`

type GetMonsterEquipmentSlotsChancesParams struct {
	MonsterEquipmentID int32
	EquipmentSlotsID   int32
}

type GetMonsterEquipmentSlotsChancesRow struct {
	Amount interface{}
	Chance interface{}
}

func (q *Queries) GetMonsterEquipmentSlotsChances(ctx context.Context, arg GetMonsterEquipmentSlotsChancesParams) ([]GetMonsterEquipmentSlotsChancesRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonsterEquipmentSlotsChances, arg.MonsterEquipmentID, arg.EquipmentSlotsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonsterEquipmentSlotsChancesRow
	for rows.Next() {
		var i GetMonsterEquipmentSlotsChancesRow
		if err := rows.Scan(&i.Amount, &i.Chance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonsterItems = `-- name: GetMonsterItems :one
SELECT
    mi.id, mi.data_hash, mi.monster_id, mi.drop_chance, mi.drop_condition, mi.other_items_condition, mi.steal_common_id, mi.steal_rare_id, mi.drop_common_id, mi.drop_rare_id, mi.secondary_drop_common_id, mi.secondary_drop_rare_id, mi.bribe_id,

    i1.id AS steal_common_item_id,
    mi1.name AS steal_common_item,
    mi1.type AS steal_common_item_type,
    ia1.amount AS steal_common_amount,

    i2.id AS steal_rare_item_id,
    mi2.name AS steal_rare_item,
    mi2.type AS steal_rare_item_type,
    ia2.amount AS steal_rare_amount,

    i3.id AS drop_common_item_id,
    mi3.name AS drop_common_item,
    mi3.type AS drop_common_item_type,
    ia3.amount AS drop_common_amount,

    i4.id AS drop_rare_item_id,
    mi4.name AS drop_rare_item,
    mi4.type AS drop_rare_item_type,
    ia4.amount AS drop_rare_amount,

    i5.id AS sec_drop_common_item_id,
    mi5.name AS sec_drop_common_item,
    mi5.type AS sec_drop_common_item_type,
    ia5.amount AS sec_drop_common_amount,

    i6.id AS sec_drop_rare_item_id,
    mi6.name AS sec_drop_rare_item,
    mi6.type AS sec_drop_rare_item_type,
    ia6.amount AS sec_drop_rare_amount,

    i7.id AS bribe_item_id,
    mi7.name AS bribe_item,
    mi7.type AS bribe_item_type,
    ia7.amount AS bribe_amount

FROM monster_items mi

LEFT JOIN item_amounts ia1 ON mi.steal_common_id = ia1.id
LEFT JOIN master_items mi1 ON ia1.master_item_id = mi1.id
LEFT JOIN items i1 ON i1.master_item_id = mi1.id

LEFT JOIN item_amounts ia2 ON mi.steal_rare_id = ia2.id
LEFT JOIN master_items mi2 ON ia2.master_item_id = mi2.id
LEFT JOIN items i2 ON i2.master_item_id = mi2.id

LEFT JOIN item_amounts ia3 ON mi.drop_common_id = ia3.id
LEFT JOIN master_items mi3 ON ia3.master_item_id = mi3.id
LEFT JOIN items i3 ON i3.master_item_id = mi3.id

LEFT JOIN item_amounts ia4 ON mi.drop_rare_id = ia4.id
LEFT JOIN master_items mi4 ON ia4.master_item_id = mi4.id
LEFT JOIN items i4 ON i4.master_item_id = mi4.id

LEFT JOIN item_amounts ia5 ON mi.secondary_drop_common_id = ia5.id
LEFT JOIN master_items mi5 ON ia5.master_item_id = mi5.id
LEFT JOIN items i5 ON i5.master_item_id = mi5.id

LEFT JOIN item_amounts ia6 ON mi.secondary_drop_rare_id = ia6.id
LEFT JOIN master_items mi6 ON ia6.master_item_id = mi6.id
LEFT JOIN items i6 ON i6.master_item_id = mi6.id

LEFT JOIN item_amounts ia7 ON mi.bribe_id = ia7.id
LEFT JOIN master_items mi7 ON ia7.master_item_id = mi7.id
LEFT JOIN items i7 ON i7.master_item_id = mi7.id

WHERE mi.monster_id = $1
`

type GetMonsterItemsRow struct {
	ID                    int32
	DataHash              string
	MonsterID             int32
	DropChance            interface{}
	DropCondition         sql.NullString
	OtherItemsCondition   sql.NullString
	StealCommonID         sql.NullInt32
	StealRareID           sql.NullInt32
	DropCommonID          sql.NullInt32
	DropRareID            sql.NullInt32
	SecondaryDropCommonID sql.NullInt32
	SecondaryDropRareID   sql.NullInt32
	BribeID               sql.NullInt32
	StealCommonItemID     sql.NullInt32
	StealCommonItem       sql.NullString
	StealCommonItemType   NullItemType
	StealCommonAmount     sql.NullInt32
	StealRareItemID       sql.NullInt32
	StealRareItem         sql.NullString
	StealRareItemType     NullItemType
	StealRareAmount       sql.NullInt32
	DropCommonItemID      sql.NullInt32
	DropCommonItem        sql.NullString
	DropCommonItemType    NullItemType
	DropCommonAmount      sql.NullInt32
	DropRareItemID        sql.NullInt32
	DropRareItem          sql.NullString
	DropRareItemType      NullItemType
	DropRareAmount        sql.NullInt32
	SecDropCommonItemID   sql.NullInt32
	SecDropCommonItem     sql.NullString
	SecDropCommonItemType NullItemType
	SecDropCommonAmount   sql.NullInt32
	SecDropRareItemID     sql.NullInt32
	SecDropRareItem       sql.NullString
	SecDropRareItemType   NullItemType
	SecDropRareAmount     sql.NullInt32
	BribeItemID           sql.NullInt32
	BribeItem             sql.NullString
	BribeItemType         NullItemType
	BribeAmount           sql.NullInt32
}

func (q *Queries) GetMonsterItems(ctx context.Context, monsterID int32) (GetMonsterItemsRow, error) {
	row := q.db.QueryRowContext(ctx, getMonsterItems, monsterID)
	var i GetMonsterItemsRow
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.MonsterID,
		&i.DropChance,
		&i.DropCondition,
		&i.OtherItemsCondition,
		&i.StealCommonID,
		&i.StealRareID,
		&i.DropCommonID,
		&i.DropRareID,
		&i.SecondaryDropCommonID,
		&i.SecondaryDropRareID,
		&i.BribeID,
		&i.StealCommonItemID,
		&i.StealCommonItem,
		&i.StealCommonItemType,
		&i.StealCommonAmount,
		&i.StealRareItemID,
		&i.StealRareItem,
		&i.StealRareItemType,
		&i.StealRareAmount,
		&i.DropCommonItemID,
		&i.DropCommonItem,
		&i.DropCommonItemType,
		&i.DropCommonAmount,
		&i.DropRareItemID,
		&i.DropRareItem,
		&i.DropRareItemType,
		&i.DropRareAmount,
		&i.SecDropCommonItemID,
		&i.SecDropCommonItem,
		&i.SecDropCommonItemType,
		&i.SecDropCommonAmount,
		&i.SecDropRareItemID,
		&i.SecDropRareItem,
		&i.SecDropRareItemType,
		&i.SecDropRareAmount,
		&i.BribeItemID,
		&i.BribeItem,
		&i.BribeItemType,
		&i.BribeAmount,
	)
	return i, err
}

const getMonsterOtherItems = `-- name: GetMonsterOtherItems :many
SELECT
    i.id AS item_id,
    mi.name AS item,
    mi.type AS item_type,
    ia.amount AS amount,
    pi.chance AS chance
FROM j_monster_items_other_items jmoi
LEFT JOIN possible_items pi ON jmoi.possible_item_id = pi.id
LEFT JOIN item_amounts ia ON pi.item_amount_id = ia.id
LEFT JOIN master_items mi ON ia.master_item_id = mi.id
LEFT JOIN items i ON i.master_item_id = mi.id
WHERE jmoi.monster_items_id = $1
ORDER BY chance DESC
`

type GetMonsterOtherItemsRow struct {
	ItemID   sql.NullInt32
	Item     sql.NullString
	ItemType NullItemType
	Amount   sql.NullInt32
	Chance   interface{}
}

func (q *Queries) GetMonsterOtherItems(ctx context.Context, monsterItemsID int32) ([]GetMonsterOtherItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonsterOtherItems, monsterItemsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonsterOtherItemsRow
	for rows.Next() {
		var i GetMonsterOtherItemsRow
		if err := rows.Scan(
			&i.ItemID,
			&i.Item,
			&i.ItemType,
			&i.Amount,
			&i.Chance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonsters = `-- name: GetMonsters :many
SELECT id, data_hash, name, version, specification, notes, species, is_story_based, can_be_captured, area_conquest_location, ctb_icon_type, has_overdrive, is_underwater, is_zombie, distance, ap, ap_overkill, overkill_damage, gil, steal_gil, doom_countdown, poison_rate, threaten_chance, zanmato_level, monster_arena_price, sensor_text, scan_text FROM monsters ORDER BY id
`

func (q *Queries) GetMonsters(ctx context.Context) ([]Monster, error) {
	rows, err := q.db.QueryContext(ctx, getMonsters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Monster
	for rows.Next() {
		var i Monster
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Name,
			&i.Version,
			&i.Specification,
			&i.Notes,
			&i.Species,
			&i.IsStoryBased,
			&i.CanBeCaptured,
			&i.AreaConquestLocation,
			&i.CtbIconType,
			&i.HasOverdrive,
			&i.IsUnderwater,
			&i.IsZombie,
			&i.Distance,
			&i.Ap,
			&i.ApOverkill,
			&i.OverkillDamage,
			&i.Gil,
			&i.StealGil,
			&i.DoomCountdown,
			&i.PoisonRate,
			&i.ThreatenChance,
			&i.ZanmatoLevel,
			&i.MonsterArenaPrice,
			&i.SensorText,
			&i.ScanText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonstersByName = `-- name: GetMonstersByName :many
SELECT id, data_hash, name, version, specification, notes, species, is_story_based, can_be_captured, area_conquest_location, ctb_icon_type, has_overdrive, is_underwater, is_zombie, distance, ap, ap_overkill, overkill_damage, gil, steal_gil, doom_countdown, poison_rate, threaten_chance, zanmato_level, monster_arena_price, sensor_text, scan_text FROM monsters WHERE name = $1
`

func (q *Queries) GetMonstersByName(ctx context.Context, name string) ([]Monster, error) {
	rows, err := q.db.QueryContext(ctx, getMonstersByName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Monster
	for rows.Next() {
		var i Monster
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Name,
			&i.Version,
			&i.Specification,
			&i.Notes,
			&i.Species,
			&i.IsStoryBased,
			&i.CanBeCaptured,
			&i.AreaConquestLocation,
			&i.CtbIconType,
			&i.HasOverdrive,
			&i.IsUnderwater,
			&i.IsZombie,
			&i.Distance,
			&i.Ap,
			&i.ApOverkill,
			&i.OverkillDamage,
			&i.Gil,
			&i.StealGil,
			&i.DoomCountdown,
			&i.PoisonRate,
			&i.ThreatenChance,
			&i.ZanmatoLevel,
			&i.MonsterArenaPrice,
			&i.SensorText,
			&i.ScanText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

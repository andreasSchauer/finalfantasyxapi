// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: monsters.sql

package database

import (
	"context"
	"database/sql"
)

const createAltStateChange = `-- name: CreateAltStateChange :one
INSERT INTO alt_state_changes (data_hash, altered_state_id, alteration_type, distance)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = alt_state_changes.data_hash
RETURNING id, data_hash, altered_state_id, alteration_type, distance
`

type CreateAltStateChangeParams struct {
	DataHash       string
	AlteredStateID int32
	AlterationType AlterationType
	Distance       interface{}
}

func (q *Queries) CreateAltStateChange(ctx context.Context, arg CreateAltStateChangeParams) (AltStateChange, error) {
	row := q.db.QueryRowContext(ctx, createAltStateChange,
		arg.DataHash,
		arg.AlteredStateID,
		arg.AlterationType,
		arg.Distance,
	)
	var i AltStateChange
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.AlteredStateID,
		&i.AlterationType,
		&i.Distance,
	)
	return i, err
}

const createAltStateChangesAutoAbilitiesJunction = `-- name: CreateAltStateChangesAutoAbilitiesJunction :exec
INSERT INTO j_alt_state_changes_auto_abilities (data_hash, alt_state_change_id, auto_ability_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAltStateChangesAutoAbilitiesJunctionParams struct {
	DataHash         string
	AltStateChangeID int32
	AutoAbilityID    int32
}

func (q *Queries) CreateAltStateChangesAutoAbilitiesJunction(ctx context.Context, arg CreateAltStateChangesAutoAbilitiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAltStateChangesAutoAbilitiesJunction, arg.DataHash, arg.AltStateChangeID, arg.AutoAbilityID)
	return err
}

const createAltStateChangesBaseStatsJunction = `-- name: CreateAltStateChangesBaseStatsJunction :exec
INSERT INTO j_alt_state_changes_base_stats (data_hash, alt_state_change_id, base_stat_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAltStateChangesBaseStatsJunctionParams struct {
	DataHash         string
	AltStateChangeID int32
	BaseStatID       int32
}

func (q *Queries) CreateAltStateChangesBaseStatsJunction(ctx context.Context, arg CreateAltStateChangesBaseStatsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAltStateChangesBaseStatsJunction, arg.DataHash, arg.AltStateChangeID, arg.BaseStatID)
	return err
}

const createAltStateChangesElemResistsJunction = `-- name: CreateAltStateChangesElemResistsJunction :exec
INSERT INTO j_alt_state_changes_elem_resists (data_hash, alt_state_change_id, elem_resist_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAltStateChangesElemResistsJunctionParams struct {
	DataHash         string
	AltStateChangeID int32
	ElemResistID     int32
}

func (q *Queries) CreateAltStateChangesElemResistsJunction(ctx context.Context, arg CreateAltStateChangesElemResistsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAltStateChangesElemResistsJunction, arg.DataHash, arg.AltStateChangeID, arg.ElemResistID)
	return err
}

const createAltStateChangesPropertiesJunction = `-- name: CreateAltStateChangesPropertiesJunction :exec
INSERT INTO j_alt_state_changes_properties (data_hash, alt_state_change_id, property_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAltStateChangesPropertiesJunctionParams struct {
	DataHash         string
	AltStateChangeID int32
	PropertyID       int32
}

func (q *Queries) CreateAltStateChangesPropertiesJunction(ctx context.Context, arg CreateAltStateChangesPropertiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAltStateChangesPropertiesJunction, arg.DataHash, arg.AltStateChangeID, arg.PropertyID)
	return err
}

const createAltStateChangesStatusImmunitiesJunction = `-- name: CreateAltStateChangesStatusImmunitiesJunction :exec
INSERT INTO j_alt_state_changes_status_immunities (data_hash, alt_state_change_id, status_condition_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAltStateChangesStatusImmunitiesJunctionParams struct {
	DataHash          string
	AltStateChangeID  int32
	StatusConditionID int32
}

func (q *Queries) CreateAltStateChangesStatusImmunitiesJunction(ctx context.Context, arg CreateAltStateChangesStatusImmunitiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAltStateChangesStatusImmunitiesJunction, arg.DataHash, arg.AltStateChangeID, arg.StatusConditionID)
	return err
}

const createAltStateChangesStatussesJunction = `-- name: CreateAltStateChangesStatussesJunction :exec
INSERT INTO j_alt_state_changes_statusses (data_hash, alt_state_change_id, inflicted_status_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAltStateChangesStatussesJunctionParams struct {
	DataHash          string
	AltStateChangeID  int32
	InflictedStatusID int32
}

func (q *Queries) CreateAltStateChangesStatussesJunction(ctx context.Context, arg CreateAltStateChangesStatussesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAltStateChangesStatussesJunction, arg.DataHash, arg.AltStateChangeID, arg.InflictedStatusID)
	return err
}

const createAlteredState = `-- name: CreateAlteredState :one
INSERT INTO altered_states (data_hash, monster_id, condition, is_temporary)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = altered_states.data_hash
RETURNING id, data_hash, monster_id, condition, is_temporary
`

type CreateAlteredStateParams struct {
	DataHash    string
	MonsterID   int32
	Condition   string
	IsTemporary bool
}

func (q *Queries) CreateAlteredState(ctx context.Context, arg CreateAlteredStateParams) (AlteredState, error) {
	row := q.db.QueryRowContext(ctx, createAlteredState,
		arg.DataHash,
		arg.MonsterID,
		arg.Condition,
		arg.IsTemporary,
	)
	var i AlteredState
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.MonsterID,
		&i.Condition,
		&i.IsTemporary,
	)
	return i, err
}

const createEquipmentDrop = `-- name: CreateEquipmentDrop :one
INSERT INTO equipment_drops (data_hash, auto_ability_id, is_forced, probability, type)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = equipment_drops.data_hash
RETURNING id, data_hash, auto_ability_id, is_forced, probability, type
`

type CreateEquipmentDropParams struct {
	DataHash      string
	AutoAbilityID int32
	IsForced      bool
	Probability   interface{}
	Type          EquipType
}

func (q *Queries) CreateEquipmentDrop(ctx context.Context, arg CreateEquipmentDropParams) (EquipmentDrop, error) {
	row := q.db.QueryRowContext(ctx, createEquipmentDrop,
		arg.DataHash,
		arg.AutoAbilityID,
		arg.IsForced,
		arg.Probability,
		arg.Type,
	)
	var i EquipmentDrop
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.AutoAbilityID,
		&i.IsForced,
		&i.Probability,
		&i.Type,
	)
	return i, err
}

const createEquipmentDropsCharactersJunction = `-- name: CreateEquipmentDropsCharactersJunction :exec
INSERT INTO j_equipment_drops_characters (data_hash, monster_equipment_id, equipment_drop_id, character_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateEquipmentDropsCharactersJunctionParams struct {
	DataHash           string
	MonsterEquipmentID int32
	EquipmentDropID    int32
	CharacterID        int32
}

func (q *Queries) CreateEquipmentDropsCharactersJunction(ctx context.Context, arg CreateEquipmentDropsCharactersJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createEquipmentDropsCharactersJunction,
		arg.DataHash,
		arg.MonsterEquipmentID,
		arg.EquipmentDropID,
		arg.CharacterID,
	)
	return err
}

const createEquipmentSlotsChance = `-- name: CreateEquipmentSlotsChance :one
INSERT INTO equipment_slots_chances (data_hash, amount, chance)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = equipment_slots_chances.data_hash
RETURNING id, data_hash, amount, chance
`

type CreateEquipmentSlotsChanceParams struct {
	DataHash string
	Amount   interface{}
	Chance   interface{}
}

func (q *Queries) CreateEquipmentSlotsChance(ctx context.Context, arg CreateEquipmentSlotsChanceParams) (EquipmentSlotsChance, error) {
	row := q.db.QueryRowContext(ctx, createEquipmentSlotsChance, arg.DataHash, arg.Amount, arg.Chance)
	var i EquipmentSlotsChance
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Amount,
		&i.Chance,
	)
	return i, err
}

const createMonster = `-- name: CreateMonster :one
INSERT INTO monsters (data_hash, name, version, specification, notes, species, is_story_based, can_be_captured, area_conquest_location, ctb_icon_type, has_overdrive, is_underwater, is_zombie, distance, ap, ap_overkill, overkill_damage, gil, steal_gil, doom_countdown, poison_rate, threaten_chance, zanmato_level, monster_arena_price, sensor_text, scan_text)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monsters.data_hash
RETURNING id, data_hash, name, version, specification, notes, species, is_story_based, can_be_captured, area_conquest_location, ctb_icon_type, has_overdrive, is_underwater, is_zombie, distance, ap, ap_overkill, overkill_damage, gil, steal_gil, doom_countdown, poison_rate, threaten_chance, zanmato_level, monster_arena_price, sensor_text, scan_text
`

type CreateMonsterParams struct {
	DataHash             string
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	Notes                sql.NullString
	Species              MonsterSpecies
	IsStoryBased         bool
	CanBeCaptured        bool
	AreaConquestLocation NullMaCreationArea
	CtbIconType          CtbIconType
	HasOverdrive         bool
	IsUnderwater         bool
	IsZombie             bool
	Distance             interface{}
	Ap                   int32
	ApOverkill           int32
	OverkillDamage       int32
	Gil                  int32
	StealGil             sql.NullInt32
	DoomCountdown        interface{}
	PoisonRate           interface{}
	ThreatenChance       interface{}
	ZanmatoLevel         interface{}
	MonsterArenaPrice    sql.NullInt32
	SensorText           sql.NullString
	ScanText             sql.NullString
}

func (q *Queries) CreateMonster(ctx context.Context, arg CreateMonsterParams) (Monster, error) {
	row := q.db.QueryRowContext(ctx, createMonster,
		arg.DataHash,
		arg.Name,
		arg.Version,
		arg.Specification,
		arg.Notes,
		arg.Species,
		arg.IsStoryBased,
		arg.CanBeCaptured,
		arg.AreaConquestLocation,
		arg.CtbIconType,
		arg.HasOverdrive,
		arg.IsUnderwater,
		arg.IsZombie,
		arg.Distance,
		arg.Ap,
		arg.ApOverkill,
		arg.OverkillDamage,
		arg.Gil,
		arg.StealGil,
		arg.DoomCountdown,
		arg.PoisonRate,
		arg.ThreatenChance,
		arg.ZanmatoLevel,
		arg.MonsterArenaPrice,
		arg.SensorText,
		arg.ScanText,
	)
	var i Monster
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Name,
		&i.Version,
		&i.Specification,
		&i.Notes,
		&i.Species,
		&i.IsStoryBased,
		&i.CanBeCaptured,
		&i.AreaConquestLocation,
		&i.CtbIconType,
		&i.HasOverdrive,
		&i.IsUnderwater,
		&i.IsZombie,
		&i.Distance,
		&i.Ap,
		&i.ApOverkill,
		&i.OverkillDamage,
		&i.Gil,
		&i.StealGil,
		&i.DoomCountdown,
		&i.PoisonRate,
		&i.ThreatenChance,
		&i.ZanmatoLevel,
		&i.MonsterArenaPrice,
		&i.SensorText,
		&i.ScanText,
	)
	return i, err
}

const createMonsterAbility = `-- name: CreateMonsterAbility :one
INSERT INTO monster_abilities (data_hash, ability_id, is_forced, is_unused)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monster_abilities.data_hash
RETURNING id, data_hash, ability_id, is_forced, is_unused
`

type CreateMonsterAbilityParams struct {
	DataHash  string
	AbilityID int32
	IsForced  bool
	IsUnused  bool
}

func (q *Queries) CreateMonsterAbility(ctx context.Context, arg CreateMonsterAbilityParams) (MonsterAbility, error) {
	row := q.db.QueryRowContext(ctx, createMonsterAbility,
		arg.DataHash,
		arg.AbilityID,
		arg.IsForced,
		arg.IsUnused,
	)
	var i MonsterAbility
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.AbilityID,
		&i.IsForced,
		&i.IsUnused,
	)
	return i, err
}

const createMonsterAmount = `-- name: CreateMonsterAmount :one
INSERT INTO monster_amounts (data_hash, monster_id, amount)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monster_amounts.data_hash
RETURNING id, data_hash, monster_id, amount
`

type CreateMonsterAmountParams struct {
	DataHash  string
	MonsterID int32
	Amount    int32
}

func (q *Queries) CreateMonsterAmount(ctx context.Context, arg CreateMonsterAmountParams) (MonsterAmount, error) {
	row := q.db.QueryRowContext(ctx, createMonsterAmount, arg.DataHash, arg.MonsterID, arg.Amount)
	var i MonsterAmount
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.MonsterID,
		&i.Amount,
	)
	return i, err
}

const createMonsterEquipment = `-- name: CreateMonsterEquipment :one
INSERT INTO monster_equipment (data_hash, monster_id, drop_chance, power, critical_plus)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monster_equipment.data_hash
RETURNING id, data_hash, monster_id, drop_chance, power, critical_plus
`

type CreateMonsterEquipmentParams struct {
	DataHash     string
	MonsterID    int32
	DropChance   interface{}
	Power        interface{}
	CriticalPlus int32
}

func (q *Queries) CreateMonsterEquipment(ctx context.Context, arg CreateMonsterEquipmentParams) (MonsterEquipment, error) {
	row := q.db.QueryRowContext(ctx, createMonsterEquipment,
		arg.DataHash,
		arg.MonsterID,
		arg.DropChance,
		arg.Power,
		arg.CriticalPlus,
	)
	var i MonsterEquipment
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.MonsterID,
		&i.DropChance,
		&i.Power,
		&i.CriticalPlus,
	)
	return i, err
}

const createMonsterEquipmentAbilitiesJunction = `-- name: CreateMonsterEquipmentAbilitiesJunction :exec
INSERT INTO j_monster_equipment_abilities (data_hash, monster_equipment_id, equipment_drop_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterEquipmentAbilitiesJunctionParams struct {
	DataHash           string
	MonsterEquipmentID int32
	EquipmentDropID    int32
}

func (q *Queries) CreateMonsterEquipmentAbilitiesJunction(ctx context.Context, arg CreateMonsterEquipmentAbilitiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterEquipmentAbilitiesJunction, arg.DataHash, arg.MonsterEquipmentID, arg.EquipmentDropID)
	return err
}

const createMonsterEquipmentSlots = `-- name: CreateMonsterEquipmentSlots :one
INSERT INTO monster_equipment_slots (data_hash, monster_equipment_id, min_amount, max_amount, type)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monster_equipment_slots.data_hash
RETURNING id, data_hash, monster_equipment_id, min_amount, max_amount, type
`

type CreateMonsterEquipmentSlotsParams struct {
	DataHash           string
	MonsterEquipmentID int32
	MinAmount          interface{}
	MaxAmount          interface{}
	Type               EquipmentSlotsType
}

func (q *Queries) CreateMonsterEquipmentSlots(ctx context.Context, arg CreateMonsterEquipmentSlotsParams) (MonsterEquipmentSlot, error) {
	row := q.db.QueryRowContext(ctx, createMonsterEquipmentSlots,
		arg.DataHash,
		arg.MonsterEquipmentID,
		arg.MinAmount,
		arg.MaxAmount,
		arg.Type,
	)
	var i MonsterEquipmentSlot
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.MonsterEquipmentID,
		&i.MinAmount,
		&i.MaxAmount,
		&i.Type,
	)
	return i, err
}

const createMonsterEquipmentSlotsChancesJunction = `-- name: CreateMonsterEquipmentSlotsChancesJunction :exec
INSERT INTO j_monster_equipment_slots_chances(data_hash, monster_equipment_id, equipment_slots_id, slots_chance_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterEquipmentSlotsChancesJunctionParams struct {
	DataHash           string
	MonsterEquipmentID int32
	EquipmentSlotsID   int32
	SlotsChanceID      int32
}

func (q *Queries) CreateMonsterEquipmentSlotsChancesJunction(ctx context.Context, arg CreateMonsterEquipmentSlotsChancesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterEquipmentSlotsChancesJunction,
		arg.DataHash,
		arg.MonsterEquipmentID,
		arg.EquipmentSlotsID,
		arg.SlotsChanceID,
	)
	return err
}

const createMonsterItem = `-- name: CreateMonsterItem :one
INSERT INTO monster_items (data_hash, monster_id, drop_chance, drop_condition, other_items_condition, steal_common_id, steal_rare_id, drop_common_id, drop_rare_id, secondary_drop_common_id, secondary_drop_rare_id, bribe_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monster_items.data_hash
RETURNING id, data_hash, monster_id, drop_chance, drop_condition, other_items_condition, steal_common_id, steal_rare_id, drop_common_id, drop_rare_id, secondary_drop_common_id, secondary_drop_rare_id, bribe_id
`

type CreateMonsterItemParams struct {
	DataHash              string
	MonsterID             int32
	DropChance            interface{}
	DropCondition         sql.NullString
	OtherItemsCondition   sql.NullString
	StealCommonID         sql.NullInt32
	StealRareID           sql.NullInt32
	DropCommonID          sql.NullInt32
	DropRareID            sql.NullInt32
	SecondaryDropCommonID sql.NullInt32
	SecondaryDropRareID   sql.NullInt32
	BribeID               sql.NullInt32
}

func (q *Queries) CreateMonsterItem(ctx context.Context, arg CreateMonsterItemParams) (MonsterItem, error) {
	row := q.db.QueryRowContext(ctx, createMonsterItem,
		arg.DataHash,
		arg.MonsterID,
		arg.DropChance,
		arg.DropCondition,
		arg.OtherItemsCondition,
		arg.StealCommonID,
		arg.StealRareID,
		arg.DropCommonID,
		arg.DropRareID,
		arg.SecondaryDropCommonID,
		arg.SecondaryDropRareID,
		arg.BribeID,
	)
	var i MonsterItem
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.MonsterID,
		&i.DropChance,
		&i.DropCondition,
		&i.OtherItemsCondition,
		&i.StealCommonID,
		&i.StealRareID,
		&i.DropCommonID,
		&i.DropRareID,
		&i.SecondaryDropCommonID,
		&i.SecondaryDropRareID,
		&i.BribeID,
	)
	return i, err
}

const createMonsterItemsOtherItemsJunction = `-- name: CreateMonsterItemsOtherItemsJunction :exec
INSERT INTO j_monster_items_other_items (data_hash, monster_items_id, possible_item_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterItemsOtherItemsJunctionParams struct {
	DataHash       string
	MonsterItemsID int32
	PossibleItemID int32
}

func (q *Queries) CreateMonsterItemsOtherItemsJunction(ctx context.Context, arg CreateMonsterItemsOtherItemsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterItemsOtherItemsJunction, arg.DataHash, arg.MonsterItemsID, arg.PossibleItemID)
	return err
}

const createMonstersAbilitiesJunction = `-- name: CreateMonstersAbilitiesJunction :exec
INSERT INTO j_monsters_abilities (data_hash, monster_id, monster_ability_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersAbilitiesJunctionParams struct {
	DataHash         string
	MonsterID        int32
	MonsterAbilityID int32
}

func (q *Queries) CreateMonstersAbilitiesJunction(ctx context.Context, arg CreateMonstersAbilitiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersAbilitiesJunction, arg.DataHash, arg.MonsterID, arg.MonsterAbilityID)
	return err
}

const createMonstersAutoAbilitiesJunction = `-- name: CreateMonstersAutoAbilitiesJunction :exec
INSERT INTO j_monsters_auto_abilities (data_hash, monster_id, auto_ability_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersAutoAbilitiesJunctionParams struct {
	DataHash      string
	MonsterID     int32
	AutoAbilityID int32
}

func (q *Queries) CreateMonstersAutoAbilitiesJunction(ctx context.Context, arg CreateMonstersAutoAbilitiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersAutoAbilitiesJunction, arg.DataHash, arg.MonsterID, arg.AutoAbilityID)
	return err
}

const createMonstersBaseStatsJunction = `-- name: CreateMonstersBaseStatsJunction :exec
INSERT INTO j_monsters_base_stats (data_hash, monster_id, base_stat_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersBaseStatsJunctionParams struct {
	DataHash   string
	MonsterID  int32
	BaseStatID int32
}

func (q *Queries) CreateMonstersBaseStatsJunction(ctx context.Context, arg CreateMonstersBaseStatsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersBaseStatsJunction, arg.DataHash, arg.MonsterID, arg.BaseStatID)
	return err
}

const createMonstersElemResistsJunction = `-- name: CreateMonstersElemResistsJunction :exec
INSERT INTO j_monsters_elem_resists (data_hash, monster_id, elem_resist_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersElemResistsJunctionParams struct {
	DataHash     string
	MonsterID    int32
	ElemResistID int32
}

func (q *Queries) CreateMonstersElemResistsJunction(ctx context.Context, arg CreateMonstersElemResistsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersElemResistsJunction, arg.DataHash, arg.MonsterID, arg.ElemResistID)
	return err
}

const createMonstersImmunitiesJunction = `-- name: CreateMonstersImmunitiesJunction :exec
INSERT INTO j_monsters_immunities (data_hash, monster_id, status_condition_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersImmunitiesJunctionParams struct {
	DataHash          string
	MonsterID         int32
	StatusConditionID int32
}

func (q *Queries) CreateMonstersImmunitiesJunction(ctx context.Context, arg CreateMonstersImmunitiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersImmunitiesJunction, arg.DataHash, arg.MonsterID, arg.StatusConditionID)
	return err
}

const createMonstersPropertiesJunction = `-- name: CreateMonstersPropertiesJunction :exec
INSERT INTO j_monsters_properties (data_hash, monster_id, property_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersPropertiesJunctionParams struct {
	DataHash   string
	MonsterID  int32
	PropertyID int32
}

func (q *Queries) CreateMonstersPropertiesJunction(ctx context.Context, arg CreateMonstersPropertiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersPropertiesJunction, arg.DataHash, arg.MonsterID, arg.PropertyID)
	return err
}

const createMonstersRonsoRagesJunction = `-- name: CreateMonstersRonsoRagesJunction :exec
INSERT INTO j_monsters_ronso_rages (data_hash, monster_id, overdrive_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersRonsoRagesJunctionParams struct {
	DataHash    string
	MonsterID   int32
	OverdriveID int32
}

func (q *Queries) CreateMonstersRonsoRagesJunction(ctx context.Context, arg CreateMonstersRonsoRagesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersRonsoRagesJunction, arg.DataHash, arg.MonsterID, arg.OverdriveID)
	return err
}

const createMonstersStatusResistsJunction = `-- name: CreateMonstersStatusResistsJunction :exec
INSERT INTO j_monsters_status_resists (data_hash, monster_id, status_resist_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonstersStatusResistsJunctionParams struct {
	DataHash       string
	MonsterID      int32
	StatusResistID int32
}

func (q *Queries) CreateMonstersStatusResistsJunction(ctx context.Context, arg CreateMonstersStatusResistsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonstersStatusResistsJunction, arg.DataHash, arg.MonsterID, arg.StatusResistID)
	return err
}

const getAltStateAutoAbilities = `-- name: GetAltStateAutoAbilities :many
SELECT
    a.name AS auto_ability,
    a.id AS auto_ability_id
FROM j_alt_state_changes_auto_abilities j
LEFT JOIN auto_abilities a ON j.auto_ability_id = a.id
WHERE j.alt_state_change_id = $1
ORDER BY a.id
`

type GetAltStateAutoAbilitiesRow struct {
	AutoAbility   sql.NullString
	AutoAbilityID sql.NullInt32
}

func (q *Queries) GetAltStateAutoAbilities(ctx context.Context, altStateChangeID int32) ([]GetAltStateAutoAbilitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAltStateAutoAbilities, altStateChangeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAltStateAutoAbilitiesRow
	for rows.Next() {
		var i GetAltStateAutoAbilitiesRow
		if err := rows.Scan(&i.AutoAbility, &i.AutoAbilityID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAltStateBaseStats = `-- name: GetAltStateBaseStats :many
SELECT
    s.name AS stat,
    s.id AS stat_id,
    bs.value AS value
FROM j_alt_state_changes_base_stats j
LEFT JOIN base_stats bs ON j.base_stat_id = bs.id
LEFT JOIN stats s ON bs.stat_id = s.id
WHERE j.alt_state_change_id = $1
ORDER BY s.id
`

type GetAltStateBaseStatsRow struct {
	Stat   sql.NullString
	StatID sql.NullInt32
	Value  sql.NullInt32
}

func (q *Queries) GetAltStateBaseStats(ctx context.Context, altStateChangeID int32) ([]GetAltStateBaseStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAltStateBaseStats, altStateChangeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAltStateBaseStatsRow
	for rows.Next() {
		var i GetAltStateBaseStatsRow
		if err := rows.Scan(&i.Stat, &i.StatID, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAltStateChanges = `-- name: GetAltStateChanges :many
SELECT id, data_hash, altered_state_id, alteration_type, distance FROM alt_state_changes WHERE altered_state_id = $1
`

func (q *Queries) GetAltStateChanges(ctx context.Context, alteredStateID int32) ([]AltStateChange, error) {
	rows, err := q.db.QueryContext(ctx, getAltStateChanges, alteredStateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AltStateChange
	for rows.Next() {
		var i AltStateChange
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.AlteredStateID,
			&i.AlterationType,
			&i.Distance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAltStateElemResists = `-- name: GetAltStateElemResists :many
SELECT
    e.id AS element_id,
    e.name AS element,
    a.id AS affinity_id,
    a.name AS affinity
FROM j_alt_state_changes_elem_resists j
LEFT JOIN elemental_resists er ON j.elem_resist_id = er.id
LEFT JOIN elements e ON er.element_id = e.id
LEFT JOIN affinities a ON er.affinity_id = a.id
WHERE j.alt_state_change_id = $1
ORDER BY e.id
`

type GetAltStateElemResistsRow struct {
	ElementID  sql.NullInt32
	Element    sql.NullString
	AffinityID sql.NullInt32
	Affinity   sql.NullString
}

func (q *Queries) GetAltStateElemResists(ctx context.Context, altStateChangeID int32) ([]GetAltStateElemResistsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAltStateElemResists, altStateChangeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAltStateElemResistsRow
	for rows.Next() {
		var i GetAltStateElemResistsRow
		if err := rows.Scan(
			&i.ElementID,
			&i.Element,
			&i.AffinityID,
			&i.Affinity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAltStateImmunities = `-- name: GetAltStateImmunities :many
SELECT
    sc.id AS status_id,
    sc.name AS status
FROM j_alt_state_changes_status_immunities j
LEFT JOIN status_conditions sc ON j.status_condition_id = sc.id
WHERE j.alt_state_change_id = $1
ORDER BY sc.id
`

type GetAltStateImmunitiesRow struct {
	StatusID sql.NullInt32
	Status   sql.NullString
}

func (q *Queries) GetAltStateImmunities(ctx context.Context, altStateChangeID int32) ([]GetAltStateImmunitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAltStateImmunities, altStateChangeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAltStateImmunitiesRow
	for rows.Next() {
		var i GetAltStateImmunitiesRow
		if err := rows.Scan(&i.StatusID, &i.Status); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAltStateProperties = `-- name: GetAltStateProperties :many
SELECT
    p.name AS property,
    p.id AS property_id
FROM j_alt_state_changes_properties j
LEFT JOIN properties p ON j.property_id = p.id
WHERE j.alt_state_change_id = $1
ORDER BY p.id
`

type GetAltStatePropertiesRow struct {
	Property   sql.NullString
	PropertyID sql.NullInt32
}

func (q *Queries) GetAltStateProperties(ctx context.Context, altStateChangeID int32) ([]GetAltStatePropertiesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAltStateProperties, altStateChangeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAltStatePropertiesRow
	for rows.Next() {
		var i GetAltStatePropertiesRow
		if err := rows.Scan(&i.Property, &i.PropertyID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAltStateStatusses = `-- name: GetAltStateStatusses :many
SELECT
    sc.id AS status_id,
    sc.name AS status,
    isc.probability AS probability,
    isc.duration_type AS duration_type,
    isc.amount AS amount
FROM j_alt_state_changes_statusses j
LEFT JOIN inflicted_statusses isc ON j.inflicted_status_id = isc.id
LEFT JOIN status_conditions sc ON isc.status_condition_id = sc.id
WHERE j.alt_state_change_id = $1
ORDER BY sc.id
`

type GetAltStateStatussesRow struct {
	StatusID     sql.NullInt32
	Status       sql.NullString
	Probability  interface{}
	DurationType NullDurationType
	Amount       sql.NullInt32
}

func (q *Queries) GetAltStateStatusses(ctx context.Context, altStateChangeID int32) ([]GetAltStateStatussesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAltStateStatusses, altStateChangeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAltStateStatussesRow
	for rows.Next() {
		var i GetAltStateStatussesRow
		if err := rows.Scan(
			&i.StatusID,
			&i.Status,
			&i.Probability,
			&i.DurationType,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEquipmentDropCharacters = `-- name: GetEquipmentDropCharacters :many
SELECT
    c.id AS character_id,
    pu.name AS character_name
FROM j_equipment_drops_characters j
LEFT JOIN characters c ON j.character_id = c.id
LEFT JOIN player_units pu ON c.unit_id = pu.id
WHERE j.monster_equipment_id = $1
AND j.equipment_drop_id = $2
`

type GetEquipmentDropCharactersParams struct {
	MonsterEquipmentID int32
	EquipmentDropID    int32
}

type GetEquipmentDropCharactersRow struct {
	CharacterID   sql.NullInt32
	CharacterName sql.NullString
}

func (q *Queries) GetEquipmentDropCharacters(ctx context.Context, arg GetEquipmentDropCharactersParams) ([]GetEquipmentDropCharactersRow, error) {
	rows, err := q.db.QueryContext(ctx, getEquipmentDropCharacters, arg.MonsterEquipmentID, arg.EquipmentDropID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEquipmentDropCharactersRow
	for rows.Next() {
		var i GetEquipmentDropCharactersRow
		if err := rows.Scan(&i.CharacterID, &i.CharacterName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonster = `-- name: GetMonster :one
SELECT id, data_hash, name, version, specification, notes, species, is_story_based, can_be_captured, area_conquest_location, ctb_icon_type, has_overdrive, is_underwater, is_zombie, distance, ap, ap_overkill, overkill_damage, gil, steal_gil, doom_countdown, poison_rate, threaten_chance, zanmato_level, monster_arena_price, sensor_text, scan_text FROM monsters WHERE id = $1
`

func (q *Queries) GetMonster(ctx context.Context, id int32) (Monster, error) {
	row := q.db.QueryRowContext(ctx, getMonster, id)
	var i Monster
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Name,
		&i.Version,
		&i.Specification,
		&i.Notes,
		&i.Species,
		&i.IsStoryBased,
		&i.CanBeCaptured,
		&i.AreaConquestLocation,
		&i.CtbIconType,
		&i.HasOverdrive,
		&i.IsUnderwater,
		&i.IsZombie,
		&i.Distance,
		&i.Ap,
		&i.ApOverkill,
		&i.OverkillDamage,
		&i.Gil,
		&i.StealGil,
		&i.DoomCountdown,
		&i.PoisonRate,
		&i.ThreatenChance,
		&i.ZanmatoLevel,
		&i.MonsterArenaPrice,
		&i.SensorText,
		&i.ScanText,
	)
	return i, err
}

const getMonsterAbilities = `-- name: GetMonsterAbilities :many
SELECT 
    a.id AS ability_id,
    a.name AS ability,
    a.version AS version,
    a.specification AS specification,
    a.type AS ability_type,
    ma.is_forced AS is_forced,
    ma.is_unused AS is_unused
FROM j_monsters_abilities j
LEFT JOIN monster_abilities ma ON j.monster_ability_id = ma.id
LEFT JOIN abilities a ON ma.ability_id = a.id
WHERE j.monster_id = $1
ORDER BY a.id
`

type GetMonsterAbilitiesRow struct {
	AbilityID     sql.NullInt32
	Ability       sql.NullString
	Version       sql.NullInt32
	Specification sql.NullString
	AbilityType   NullAbilityType
	IsForced      sql.NullBool
	IsUnused      sql.NullBool
}

func (q *Queries) GetMonsterAbilities(ctx context.Context, monsterID int32) ([]GetMonsterAbilitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonsterAbilities, monsterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonsterAbilitiesRow
	for rows.Next() {
		var i GetMonsterAbilitiesRow
		if err := rows.Scan(
			&i.AbilityID,
			&i.Ability,
			&i.Version,
			&i.Specification,
			&i.AbilityType,
			&i.IsForced,
			&i.IsUnused,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonsterAlteredStates = `-- name: GetMonsterAlteredStates :many
SELECT id, data_hash, monster_id, condition, is_temporary FROM altered_states WHERE monster_id = $1
`

func (q *Queries) GetMonsterAlteredStates(ctx context.Context, monsterID int32) ([]AlteredState, error) {
	rows, err := q.db.QueryContext(ctx, getMonsterAlteredStates, monsterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AlteredState
	for rows.Next() {
		var i AlteredState
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.MonsterID,
			&i.Condition,
			&i.IsTemporary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonsterAutoAbilities = `-- name: GetMonsterAutoAbilities :many
SELECT
    a.id AS auto_ability_id,
    a.name AS auto_ability
FROM j_monsters_auto_abilities j
LEFT JOIN auto_abilities a ON j.auto_ability_id = a.id
WHERE j.monster_id = $1
ORDER BY a.id
`

type GetMonsterAutoAbilitiesRow struct {
	AutoAbilityID sql.NullInt32
	AutoAbility   sql.NullString
}

func (q *Queries) GetMonsterAutoAbilities(ctx context.Context, monsterID int32) ([]GetMonsterAutoAbilitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonsterAutoAbilities, monsterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonsterAutoAbilitiesRow
	for rows.Next() {
		var i GetMonsterAutoAbilitiesRow
		if err := rows.Scan(&i.AutoAbilityID, &i.AutoAbility); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonsterBaseStats = `-- name: GetMonsterBaseStats :many
SELECT
    s.id AS stat_id,
    s.name AS stat,
    bs.value AS value
FROM j_monsters_base_stats j
LEFT JOIN base_stats bs ON j.base_stat_id = bs.id
LEFT JOIN stats s ON bs.stat_id = s.id
WHERE j.monster_id = $1
ORDER BY s.id
`

type GetMonsterBaseStatsRow struct {
	StatID sql.NullInt32
	Stat   sql.NullString
	Value  sql.NullInt32
}

func (q *Queries) GetMonsterBaseStats(ctx context.Context, monsterID int32) ([]GetMonsterBaseStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonsterBaseStats, monsterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonsterBaseStatsRow
	for rows.Next() {
		var i GetMonsterBaseStatsRow
		if err := rows.Scan(&i.StatID, &i.Stat, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonsterElemResists = `-- name: GetMonsterElemResists :many
SELECT
    e.id AS element_id,
    e.name AS element,
    a.id AS affinity_id,
    a.name AS affinity
FROM j_monsters_elem_resists j
LEFT JOIN elemental_resists er ON j.elem_resist_id = er.id
LEFT JOIN elements e ON er.element_id = e.id
LEFT JOIN affinities a ON er.affinity_id = a.id
WHERE j.monster_id = $1
ORDER BY e.id
`

type GetMonsterElemResistsRow struct {
	ElementID  sql.NullInt32
	Element    sql.NullString
	AffinityID sql.NullInt32
	Affinity   sql.NullString
}

func (q *Queries) GetMonsterElemResists(ctx context.Context, monsterID int32) ([]GetMonsterElemResistsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonsterElemResists, monsterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonsterElemResistsRow
	for rows.Next() {
		var i GetMonsterElemResistsRow
		if err := rows.Scan(
			&i.ElementID,
			&i.Element,
			&i.AffinityID,
			&i.Affinity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonsterEquipment = `-- name: GetMonsterEquipment :one
SELECT id, data_hash, monster_id, drop_chance, power, critical_plus FROM monster_equipment WHERE monster_id = $1
`

func (q *Queries) GetMonsterEquipment(ctx context.Context, monsterID int32) (MonsterEquipment, error) {
	row := q.db.QueryRowContext(ctx, getMonsterEquipment, monsterID)
	var i MonsterEquipment
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.MonsterID,
		&i.DropChance,
		&i.Power,
		&i.CriticalPlus,
	)
	return i, err
}

const getMonsterEquipmentAbilities = `-- name: GetMonsterEquipmentAbilities :many
SELECT
    ed.id AS id,
    aa.name AS auto_ability,
    aa.id AS auto_ability_id,
    ed.is_forced AS is_forced,
    ed.probability AS probability
FROM j_monster_equipment_abilities j
LEFT JOIN equipment_drops ed ON j.equipment_drop_id = ed.id
LEFT JOIN auto_abilities aa ON ed.auto_ability_id = aa.id
WHERE j.monster_equipment_id = $1
AND ed.type = $2
`

type GetMonsterEquipmentAbilitiesParams struct {
	MonsterEquipmentID int32
	Type               EquipType
}

type GetMonsterEquipmentAbilitiesRow struct {
	ID            sql.NullInt32
	AutoAbility   sql.NullString
	AutoAbilityID sql.NullInt32
	IsForced      sql.NullBool
	Probability   interface{}
}

func (q *Queries) GetMonsterEquipmentAbilities(ctx context.Context, arg GetMonsterEquipmentAbilitiesParams) ([]GetMonsterEquipmentAbilitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonsterEquipmentAbilities, arg.MonsterEquipmentID, arg.Type)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonsterEquipmentAbilitiesRow
	for rows.Next() {
		var i GetMonsterEquipmentAbilitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.AutoAbility,
			&i.AutoAbilityID,
			&i.IsForced,
			&i.Probability,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonsterEquipmentSlots = `-- name: GetMonsterEquipmentSlots :many
SELECT id, data_hash, monster_equipment_id, min_amount, max_amount, type FROM monster_equipment_slots
WHERE monster_equipment_id = $1
ORDER BY id
`

func (q *Queries) GetMonsterEquipmentSlots(ctx context.Context, monsterEquipmentID int32) ([]MonsterEquipmentSlot, error) {
	rows, err := q.db.QueryContext(ctx, getMonsterEquipmentSlots, monsterEquipmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MonsterEquipmentSlot
	for rows.Next() {
		var i MonsterEquipmentSlot
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.MonsterEquipmentID,
			&i.MinAmount,
			&i.MaxAmount,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonsterEquipmentSlotsChances = `-- name: GetMonsterEquipmentSlotsChances :many
SELECT
    esc.amount AS amount,
    esc.chance AS chance
FROM equipment_slots_chances esc
LEFT JOIN j_monster_equipment_slots_chances j ON j.slots_chance_id = esc.id
WHERE j.monster_equipment_id = $1
AND j.equipment_slots_id = $2
`

type GetMonsterEquipmentSlotsChancesParams struct {
	MonsterEquipmentID int32
	EquipmentSlotsID   int32
}

type GetMonsterEquipmentSlotsChancesRow struct {
	Amount interface{}
	Chance interface{}
}

func (q *Queries) GetMonsterEquipmentSlotsChances(ctx context.Context, arg GetMonsterEquipmentSlotsChancesParams) ([]GetMonsterEquipmentSlotsChancesRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonsterEquipmentSlotsChances, arg.MonsterEquipmentID, arg.EquipmentSlotsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonsterEquipmentSlotsChancesRow
	for rows.Next() {
		var i GetMonsterEquipmentSlotsChancesRow
		if err := rows.Scan(&i.Amount, &i.Chance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonsterImmunities = `-- name: GetMonsterImmunities :many
SELECT
    sc.id AS status_id,
    sc.name AS status
FROM j_monsters_immunities j
LEFT JOIN status_conditions sc ON j.status_condition_id = sc.id
WHERE j.monster_id = $1
ORDER BY sc.id
`

type GetMonsterImmunitiesRow struct {
	StatusID sql.NullInt32
	Status   sql.NullString
}

func (q *Queries) GetMonsterImmunities(ctx context.Context, monsterID int32) ([]GetMonsterImmunitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonsterImmunities, monsterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonsterImmunitiesRow
	for rows.Next() {
		var i GetMonsterImmunitiesRow
		if err := rows.Scan(&i.StatusID, &i.Status); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonsterItems = `-- name: GetMonsterItems :one
SELECT
    mi.id, mi.data_hash, mi.monster_id, mi.drop_chance, mi.drop_condition, mi.other_items_condition, mi.steal_common_id, mi.steal_rare_id, mi.drop_common_id, mi.drop_rare_id, mi.secondary_drop_common_id, mi.secondary_drop_rare_id, mi.bribe_id,

    i1.id AS steal_common_item_id,
    mi1.name AS steal_common_item,
    mi1.type AS steal_common_item_type,
    ia1.amount AS steal_common_amount,

    i2.id AS steal_rare_item_id,
    mi2.name AS steal_rare_item,
    mi2.type AS steal_rare_item_type,
    ia2.amount AS steal_rare_amount,

    i3.id AS drop_common_item_id,
    mi3.name AS drop_common_item,
    mi3.type AS drop_common_item_type,
    ia3.amount AS drop_common_amount,

    i4.id AS drop_rare_item_id,
    mi4.name AS drop_rare_item,
    mi4.type AS drop_rare_item_type,
    ia4.amount AS drop_rare_amount,

    i5.id AS sec_drop_common_item_id,
    mi5.name AS sec_drop_common_item,
    mi5.type AS sec_drop_common_item_type,
    ia5.amount AS sec_drop_common_amount,

    i6.id AS sec_drop_rare_item_id,
    mi6.name AS sec_drop_rare_item,
    mi6.type AS sec_drop_rare_item_type,
    ia6.amount AS sec_drop_rare_amount,

    i7.id AS bribe_item_id,
    mi7.name AS bribe_item,
    mi7.type AS bribe_item_type,
    ia7.amount AS bribe_amount

FROM monster_items mi

LEFT JOIN item_amounts ia1 ON mi.steal_common_id = ia1.id
LEFT JOIN master_items mi1 ON ia1.master_item_id = mi1.id
LEFT JOIN items i1 ON i1.master_item_id = mi1.id

LEFT JOIN item_amounts ia2 ON mi.steal_rare_id = ia2.id
LEFT JOIN master_items mi2 ON ia2.master_item_id = mi2.id
LEFT JOIN items i2 ON i2.master_item_id = mi2.id

LEFT JOIN item_amounts ia3 ON mi.drop_common_id = ia3.id
LEFT JOIN master_items mi3 ON ia3.master_item_id = mi3.id
LEFT JOIN items i3 ON i3.master_item_id = mi3.id

LEFT JOIN item_amounts ia4 ON mi.drop_rare_id = ia4.id
LEFT JOIN master_items mi4 ON ia4.master_item_id = mi4.id
LEFT JOIN items i4 ON i4.master_item_id = mi4.id

LEFT JOIN item_amounts ia5 ON mi.secondary_drop_common_id = ia5.id
LEFT JOIN master_items mi5 ON ia5.master_item_id = mi5.id
LEFT JOIN items i5 ON i5.master_item_id = mi5.id

LEFT JOIN item_amounts ia6 ON mi.secondary_drop_rare_id = ia6.id
LEFT JOIN master_items mi6 ON ia6.master_item_id = mi6.id
LEFT JOIN items i6 ON i6.master_item_id = mi6.id

LEFT JOIN item_amounts ia7 ON mi.bribe_id = ia7.id
LEFT JOIN master_items mi7 ON ia7.master_item_id = mi7.id
LEFT JOIN items i7 ON i7.master_item_id = mi7.id

WHERE mi.monster_id = $1
`

type GetMonsterItemsRow struct {
	ID                    int32
	DataHash              string
	MonsterID             int32
	DropChance            interface{}
	DropCondition         sql.NullString
	OtherItemsCondition   sql.NullString
	StealCommonID         sql.NullInt32
	StealRareID           sql.NullInt32
	DropCommonID          sql.NullInt32
	DropRareID            sql.NullInt32
	SecondaryDropCommonID sql.NullInt32
	SecondaryDropRareID   sql.NullInt32
	BribeID               sql.NullInt32
	StealCommonItemID     sql.NullInt32
	StealCommonItem       sql.NullString
	StealCommonItemType   NullItemType
	StealCommonAmount     sql.NullInt32
	StealRareItemID       sql.NullInt32
	StealRareItem         sql.NullString
	StealRareItemType     NullItemType
	StealRareAmount       sql.NullInt32
	DropCommonItemID      sql.NullInt32
	DropCommonItem        sql.NullString
	DropCommonItemType    NullItemType
	DropCommonAmount      sql.NullInt32
	DropRareItemID        sql.NullInt32
	DropRareItem          sql.NullString
	DropRareItemType      NullItemType
	DropRareAmount        sql.NullInt32
	SecDropCommonItemID   sql.NullInt32
	SecDropCommonItem     sql.NullString
	SecDropCommonItemType NullItemType
	SecDropCommonAmount   sql.NullInt32
	SecDropRareItemID     sql.NullInt32
	SecDropRareItem       sql.NullString
	SecDropRareItemType   NullItemType
	SecDropRareAmount     sql.NullInt32
	BribeItemID           sql.NullInt32
	BribeItem             sql.NullString
	BribeItemType         NullItemType
	BribeAmount           sql.NullInt32
}

func (q *Queries) GetMonsterItems(ctx context.Context, monsterID int32) (GetMonsterItemsRow, error) {
	row := q.db.QueryRowContext(ctx, getMonsterItems, monsterID)
	var i GetMonsterItemsRow
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.MonsterID,
		&i.DropChance,
		&i.DropCondition,
		&i.OtherItemsCondition,
		&i.StealCommonID,
		&i.StealRareID,
		&i.DropCommonID,
		&i.DropRareID,
		&i.SecondaryDropCommonID,
		&i.SecondaryDropRareID,
		&i.BribeID,
		&i.StealCommonItemID,
		&i.StealCommonItem,
		&i.StealCommonItemType,
		&i.StealCommonAmount,
		&i.StealRareItemID,
		&i.StealRareItem,
		&i.StealRareItemType,
		&i.StealRareAmount,
		&i.DropCommonItemID,
		&i.DropCommonItem,
		&i.DropCommonItemType,
		&i.DropCommonAmount,
		&i.DropRareItemID,
		&i.DropRareItem,
		&i.DropRareItemType,
		&i.DropRareAmount,
		&i.SecDropCommonItemID,
		&i.SecDropCommonItem,
		&i.SecDropCommonItemType,
		&i.SecDropCommonAmount,
		&i.SecDropRareItemID,
		&i.SecDropRareItem,
		&i.SecDropRareItemType,
		&i.SecDropRareAmount,
		&i.BribeItemID,
		&i.BribeItem,
		&i.BribeItemType,
		&i.BribeAmount,
	)
	return i, err
}

const getMonsterOtherItems = `-- name: GetMonsterOtherItems :many
SELECT
    i.id AS item_id,
    mi.name AS item,
    mi.type AS item_type,
    ia.amount AS amount,
    pi.chance AS chance
FROM j_monster_items_other_items j
LEFT JOIN possible_items pi ON j.possible_item_id = pi.id
LEFT JOIN item_amounts ia ON pi.item_amount_id = ia.id
LEFT JOIN master_items mi ON ia.master_item_id = mi.id
LEFT JOIN items i ON i.master_item_id = mi.id
WHERE j.monster_items_id = $1
ORDER BY chance DESC
`

type GetMonsterOtherItemsRow struct {
	ItemID   sql.NullInt32
	Item     sql.NullString
	ItemType NullItemType
	Amount   sql.NullInt32
	Chance   interface{}
}

func (q *Queries) GetMonsterOtherItems(ctx context.Context, monsterItemsID int32) ([]GetMonsterOtherItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonsterOtherItems, monsterItemsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonsterOtherItemsRow
	for rows.Next() {
		var i GetMonsterOtherItemsRow
		if err := rows.Scan(
			&i.ItemID,
			&i.Item,
			&i.ItemType,
			&i.Amount,
			&i.Chance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonsterProperties = `-- name: GetMonsterProperties :many
SELECT
    p.id AS property_id,
    p.name AS property
FROM j_monsters_properties j
LEFT JOIN properties p ON j.property_id = p.id
WHERE j.monster_id = $1
ORDER BY p.id
`

type GetMonsterPropertiesRow struct {
	PropertyID sql.NullInt32
	Property   sql.NullString
}

func (q *Queries) GetMonsterProperties(ctx context.Context, monsterID int32) ([]GetMonsterPropertiesRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonsterProperties, monsterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonsterPropertiesRow
	for rows.Next() {
		var i GetMonsterPropertiesRow
		if err := rows.Scan(&i.PropertyID, &i.Property); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonsterRonsoRages = `-- name: GetMonsterRonsoRages :many
SELECT
    o.id AS ronso_rage_id,
    o.name AS ronso_rage
FROM j_monsters_ronso_rages j
LEFT JOIN overdrives o ON j.overdrive_id = o.id
WHERE j.monster_id = $1
ORDER BY o.id
`

type GetMonsterRonsoRagesRow struct {
	RonsoRageID sql.NullInt32
	RonsoRage   sql.NullString
}

func (q *Queries) GetMonsterRonsoRages(ctx context.Context, monsterID int32) ([]GetMonsterRonsoRagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonsterRonsoRages, monsterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonsterRonsoRagesRow
	for rows.Next() {
		var i GetMonsterRonsoRagesRow
		if err := rows.Scan(&i.RonsoRageID, &i.RonsoRage); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonsterStatusResists = `-- name: GetMonsterStatusResists :many
SELECT
    sc.id AS status_id,
    sc.name AS status,
    sr.resistance AS resistance
FROM j_monsters_status_resists j
LEFT JOIN status_resists sr ON j.status_resist_id = sr.id
LEFT JOIN status_conditions sc ON sr.status_condition_id = sc.id
WHERE j.monster_id = $1
ORDER BY sc.id
`

type GetMonsterStatusResistsRow struct {
	StatusID   sql.NullInt32
	Status     sql.NullString
	Resistance interface{}
}

func (q *Queries) GetMonsterStatusResists(ctx context.Context, monsterID int32) ([]GetMonsterStatusResistsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMonsterStatusResists, monsterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMonsterStatusResistsRow
	for rows.Next() {
		var i GetMonsterStatusResistsRow
		if err := rows.Scan(&i.StatusID, &i.Status, &i.Resistance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonsters = `-- name: GetMonsters :many
SELECT id, data_hash, name, version, specification, notes, species, is_story_based, can_be_captured, area_conquest_location, ctb_icon_type, has_overdrive, is_underwater, is_zombie, distance, ap, ap_overkill, overkill_damage, gil, steal_gil, doom_countdown, poison_rate, threaten_chance, zanmato_level, monster_arena_price, sensor_text, scan_text FROM monsters ORDER BY id
`

func (q *Queries) GetMonsters(ctx context.Context) ([]Monster, error) {
	rows, err := q.db.QueryContext(ctx, getMonsters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Monster
	for rows.Next() {
		var i Monster
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Name,
			&i.Version,
			&i.Specification,
			&i.Notes,
			&i.Species,
			&i.IsStoryBased,
			&i.CanBeCaptured,
			&i.AreaConquestLocation,
			&i.CtbIconType,
			&i.HasOverdrive,
			&i.IsUnderwater,
			&i.IsZombie,
			&i.Distance,
			&i.Ap,
			&i.ApOverkill,
			&i.OverkillDamage,
			&i.Gil,
			&i.StealGil,
			&i.DoomCountdown,
			&i.PoisonRate,
			&i.ThreatenChance,
			&i.ZanmatoLevel,
			&i.MonsterArenaPrice,
			&i.SensorText,
			&i.ScanText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonstersByName = `-- name: GetMonstersByName :many
SELECT id, data_hash, name, version, specification, notes, species, is_story_based, can_be_captured, area_conquest_location, ctb_icon_type, has_overdrive, is_underwater, is_zombie, distance, ap, ap_overkill, overkill_damage, gil, steal_gil, doom_countdown, poison_rate, threaten_chance, zanmato_level, monster_arena_price, sensor_text, scan_text FROM monsters WHERE name = $1
`

func (q *Queries) GetMonstersByName(ctx context.Context, name string) ([]Monster, error) {
	rows, err := q.db.QueryContext(ctx, getMonstersByName, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Monster
	for rows.Next() {
		var i Monster
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Name,
			&i.Version,
			&i.Specification,
			&i.Notes,
			&i.Species,
			&i.IsStoryBased,
			&i.CanBeCaptured,
			&i.AreaConquestLocation,
			&i.CtbIconType,
			&i.HasOverdrive,
			&i.IsUnderwater,
			&i.IsZombie,
			&i.Distance,
			&i.Ap,
			&i.ApOverkill,
			&i.OverkillDamage,
			&i.Gil,
			&i.StealGil,
			&i.DoomCountdown,
			&i.PoisonRate,
			&i.ThreatenChance,
			&i.ZanmatoLevel,
			&i.MonsterArenaPrice,
			&i.SensorText,
			&i.ScanText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

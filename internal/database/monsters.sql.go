// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: monsters.sql

package database

import (
	"context"
	"database/sql"
)

const createMonster = `-- name: CreateMonster :one
INSERT INTO monsters (data_hash, name, version, specification, notes, species, is_story_based, can_be_captured, area_conquest_location, ctb_icon_type, has_overdrive, is_underwater, is_zombie, distance, ap, ap_overkill, overkill_damage, gil, steal_gil, doom_countdown, poison_rate, threaten_chance, zanmato_level, monster_arena_price, sensor_text, scan_text)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monsters.data_hash
RETURNING id, data_hash, name, version, specification, notes, species, is_story_based, can_be_captured, area_conquest_location, ctb_icon_type, has_overdrive, is_underwater, is_zombie, distance, ap, ap_overkill, overkill_damage, gil, steal_gil, doom_countdown, poison_rate, threaten_chance, zanmato_level, monster_arena_price, sensor_text, scan_text
`

type CreateMonsterParams struct {
	DataHash             string
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	Notes                sql.NullString
	Species              MonsterSpecies
	IsStoryBased         bool
	CanBeCaptured        bool
	AreaConquestLocation NullMaCreationArea
	CtbIconType          CtbIconType
	HasOverdrive         bool
	IsUnderwater         bool
	IsZombie             bool
	Distance             interface{}
	Ap                   int32
	ApOverkill           int32
	OverkillDamage       int32
	Gil                  int32
	StealGil             sql.NullInt32
	DoomCountdown        interface{}
	PoisonRate           interface{}
	ThreatenChance       interface{}
	ZanmatoLevel         interface{}
	MonsterArenaPrice    sql.NullInt32
	SensorText           string
	ScanText             sql.NullString
}

func (q *Queries) CreateMonster(ctx context.Context, arg CreateMonsterParams) (Monster, error) {
	row := q.db.QueryRowContext(ctx, createMonster,
		arg.DataHash,
		arg.Name,
		arg.Version,
		arg.Specification,
		arg.Notes,
		arg.Species,
		arg.IsStoryBased,
		arg.CanBeCaptured,
		arg.AreaConquestLocation,
		arg.CtbIconType,
		arg.HasOverdrive,
		arg.IsUnderwater,
		arg.IsZombie,
		arg.Distance,
		arg.Ap,
		arg.ApOverkill,
		arg.OverkillDamage,
		arg.Gil,
		arg.StealGil,
		arg.DoomCountdown,
		arg.PoisonRate,
		arg.ThreatenChance,
		arg.ZanmatoLevel,
		arg.MonsterArenaPrice,
		arg.SensorText,
		arg.ScanText,
	)
	var i Monster
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Name,
		&i.Version,
		&i.Specification,
		&i.Notes,
		&i.Species,
		&i.IsStoryBased,
		&i.CanBeCaptured,
		&i.AreaConquestLocation,
		&i.CtbIconType,
		&i.HasOverdrive,
		&i.IsUnderwater,
		&i.IsZombie,
		&i.Distance,
		&i.Ap,
		&i.ApOverkill,
		&i.OverkillDamage,
		&i.Gil,
		&i.StealGil,
		&i.DoomCountdown,
		&i.PoisonRate,
		&i.ThreatenChance,
		&i.ZanmatoLevel,
		&i.MonsterArenaPrice,
		&i.SensorText,
		&i.ScanText,
	)
	return i, err
}

const createMonsterAmount = `-- name: CreateMonsterAmount :one
INSERT INTO monster_amounts (data_hash, monster_id, amount)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monster_amounts.data_hash
RETURNING id, data_hash, monster_id, amount
`

type CreateMonsterAmountParams struct {
	DataHash  string
	MonsterID int32
	Amount    int32
}

func (q *Queries) CreateMonsterAmount(ctx context.Context, arg CreateMonsterAmountParams) (MonsterAmount, error) {
	row := q.db.QueryRowContext(ctx, createMonsterAmount, arg.DataHash, arg.MonsterID, arg.Amount)
	var i MonsterAmount
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.MonsterID,
		&i.Amount,
	)
	return i, err
}

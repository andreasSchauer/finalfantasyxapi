// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: world_sidequests.sql

package database

import (
	"context"
	"database/sql"
)

const createBlitzballItemList = `-- name: CreateBlitzballItemList :exec
INSERT INTO blitzball_items_lists (data_hash, category, slot)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateBlitzballItemListParams struct {
	DataHash string
	Category BlitzballTournamentCategory
	Slot     BlitzballItemSlot
}

func (q *Queries) CreateBlitzballItemList(ctx context.Context, arg CreateBlitzballItemListParams) error {
	_, err := q.db.ExecContext(ctx, createBlitzballItemList, arg.DataHash, arg.Category, arg.Slot)
	return err
}

const createMonsterArenaCreation = `-- name: CreateMonsterArenaCreation :exec
INSERT INTO monster_arena_creations (data_hash, name, category, required_area, required_species, underwater_only, creations_unlocked_category, amount)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterArenaCreationParams struct {
	DataHash                  string
	Name                      string
	Category                  MaCreationCategory
	RequiredArea              sql.NullString
	RequiredSpecies           sql.NullString
	UnderwaterOnly            bool
	CreationsUnlockedCategory NullCreationsUnlockedCategory
	Amount                    int32
}

func (q *Queries) CreateMonsterArenaCreation(ctx context.Context, arg CreateMonsterArenaCreationParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterArenaCreation,
		arg.DataHash,
		arg.Name,
		arg.Category,
		arg.RequiredArea,
		arg.RequiredSpecies,
		arg.UnderwaterOnly,
		arg.CreationsUnlockedCategory,
		arg.Amount,
	)
	return err
}

const createQuest = `-- name: CreateQuest :one
INSERT INTO quests (data_hash, name, type)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = quests.data_hash
RETURNING id, data_hash, name, type
`

type CreateQuestParams struct {
	DataHash string
	Name     string
	Type     QuestType
}

func (q *Queries) CreateQuest(ctx context.Context, arg CreateQuestParams) (Quest, error) {
	row := q.db.QueryRowContext(ctx, createQuest, arg.DataHash, arg.Name, arg.Type)
	var i Quest
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Name,
		&i.Type,
	)
	return i, err
}

const createShop = `-- name: CreateShop :exec
INSERT INTO shops (data_hash, version, notes, category)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateShopParams struct {
	DataHash string
	Version  sql.NullInt32
	Notes    sql.NullString
	Category ShopCategory
}

func (q *Queries) CreateShop(ctx context.Context, arg CreateShopParams) error {
	_, err := q.db.ExecContext(ctx, createShop,
		arg.DataHash,
		arg.Version,
		arg.Notes,
		arg.Category,
	)
	return err
}

const createSidequest = `-- name: CreateSidequest :one
INSERT INTO sidequests (quest_id)
VALUES ($1)
RETURNING id, quest_id
`

func (q *Queries) CreateSidequest(ctx context.Context, questID int32) (Sidequest, error) {
	row := q.db.QueryRowContext(ctx, createSidequest, questID)
	var i Sidequest
	err := row.Scan(&i.ID, &i.QuestID)
	return i, err
}

const createSubquest = `-- name: CreateSubquest :exec
INSERT INTO subquests (quest_id, parent_sidequest_id)
VALUES ($1, $2)
`

type CreateSubquestParams struct {
	QuestID           int32
	ParentSidequestID int32
}

func (q *Queries) CreateSubquest(ctx context.Context, arg CreateSubquestParams) error {
	_, err := q.db.ExecContext(ctx, createSubquest, arg.QuestID, arg.ParentSidequestID)
	return err
}

const createTreasure = `-- name: CreateTreasure :exec
INSERT INTO treasures (data_hash, treasure_list_id, treasure_type, loot_type, is_post_airship, is_anima_treasure, notes, gil_amount)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateTreasureParams struct {
	DataHash        string
	TreasureListID  int32
	TreasureType    TreasureType
	LootType        LootType
	IsPostAirship   bool
	IsAnimaTreasure bool
	Notes           sql.NullString
	GilAmount       sql.NullInt32
}

func (q *Queries) CreateTreasure(ctx context.Context, arg CreateTreasureParams) error {
	_, err := q.db.ExecContext(ctx, createTreasure,
		arg.DataHash,
		arg.TreasureListID,
		arg.TreasureType,
		arg.LootType,
		arg.IsPostAirship,
		arg.IsAnimaTreasure,
		arg.Notes,
		arg.GilAmount,
	)
	return err
}

const createTreasureList = `-- name: CreateTreasureList :one
INSERT INTO treasure_lists DEFAULT VALUES
RETURNING id
`

func (q *Queries) CreateTreasureList(ctx context.Context) (int32, error) {
	row := q.db.QueryRowContext(ctx, createTreasureList)
	var id int32
	err := row.Scan(&id)
	return id, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: characters.sql

package database

import (
	"context"
	"database/sql"
)

const createAeon = `-- name: CreateAeon :one
INSERT INTO aeons (data_hash, unit_id, unlock_condition, is_optional, battles_to_regenerate, phys_atk_damage_constant, phys_atk_range, phys_atk_shatter_rate, phys_atk_acc_source, phys_atk_hit_chance, phys_atk_acc_modifier)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = aeons.data_hash
RETURNING id, data_hash, unit_id, unlock_condition, is_optional, battles_to_regenerate, phys_atk_damage_constant, phys_atk_range, phys_atk_shatter_rate, phys_atk_acc_source, phys_atk_hit_chance, phys_atk_acc_modifier
`

type CreateAeonParams struct {
	DataHash              string
	UnitID                int32
	UnlockCondition       string
	IsOptional            bool
	BattlesToRegenerate   int32
	PhysAtkDamageConstant sql.NullInt32
	PhysAtkRange          interface{}
	PhysAtkShatterRate    interface{}
	PhysAtkAccSource      NullAccuracySource
	PhysAtkHitChance      interface{}
	PhysAtkAccModifier    sql.NullFloat64
}

func (q *Queries) CreateAeon(ctx context.Context, arg CreateAeonParams) (Aeon, error) {
	row := q.db.QueryRowContext(ctx, createAeon,
		arg.DataHash,
		arg.UnitID,
		arg.UnlockCondition,
		arg.IsOptional,
		arg.BattlesToRegenerate,
		arg.PhysAtkDamageConstant,
		arg.PhysAtkRange,
		arg.PhysAtkShatterRate,
		arg.PhysAtkAccSource,
		arg.PhysAtkHitChance,
		arg.PhysAtkAccModifier,
	)
	var i Aeon
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.UnitID,
		&i.UnlockCondition,
		&i.IsOptional,
		&i.BattlesToRegenerate,
		&i.PhysAtkDamageConstant,
		&i.PhysAtkRange,
		&i.PhysAtkShatterRate,
		&i.PhysAtkAccSource,
		&i.PhysAtkHitChance,
		&i.PhysAtkAccModifier,
	)
	return i, err
}

const createCharClassOverdriveJunction = `-- name: CreateCharClassOverdriveJunction :exec
INSERT INTO j_character_class_overdrive (data_hash, class_id, overdrive_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateCharClassOverdriveJunctionParams struct {
	DataHash    string
	ClassID     int32
	OverdriveID int32
}

func (q *Queries) CreateCharClassOverdriveJunction(ctx context.Context, arg CreateCharClassOverdriveJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createCharClassOverdriveJunction, arg.DataHash, arg.ClassID, arg.OverdriveID)
	return err
}

const createCharClassPlayerAbilityJunction = `-- name: CreateCharClassPlayerAbilityJunction :exec
INSERT INTO j_character_class_player_ability (data_hash, class_id, ability_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateCharClassPlayerAbilityJunctionParams struct {
	DataHash  string
	ClassID   int32
	AbilityID int32
}

func (q *Queries) CreateCharClassPlayerAbilityJunction(ctx context.Context, arg CreateCharClassPlayerAbilityJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createCharClassPlayerAbilityJunction, arg.DataHash, arg.ClassID, arg.AbilityID)
	return err
}

const createCharacter = `-- name: CreateCharacter :one
INSERT INTO characters (data_hash, unit_id, story_only, weapon_type, armor_type, physical_attack_range, can_fight_underwater)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = characters.data_hash
RETURNING id, data_hash, unit_id, story_only, weapon_type, armor_type, physical_attack_range, can_fight_underwater
`

type CreateCharacterParams struct {
	DataHash            string
	UnitID              int32
	StoryOnly           bool
	WeaponType          WeaponType
	ArmorType           ArmorType
	PhysicalAttackRange interface{}
	CanFightUnderwater  bool
}

func (q *Queries) CreateCharacter(ctx context.Context, arg CreateCharacterParams) (Character, error) {
	row := q.db.QueryRowContext(ctx, createCharacter,
		arg.DataHash,
		arg.UnitID,
		arg.StoryOnly,
		arg.WeaponType,
		arg.ArmorType,
		arg.PhysicalAttackRange,
		arg.CanFightUnderwater,
	)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.UnitID,
		&i.StoryOnly,
		&i.WeaponType,
		&i.ArmorType,
		&i.PhysicalAttackRange,
		&i.CanFightUnderwater,
	)
	return i, err
}

const createCharacterBaseStatJunction = `-- name: CreateCharacterBaseStatJunction :exec
INSERT INTO j_character_base_stat (data_hash, character_id, base_stat_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = j_character_base_stat.data_hash
RETURNING id, data_hash, character_id, base_stat_id
`

type CreateCharacterBaseStatJunctionParams struct {
	DataHash    string
	CharacterID int32
	BaseStatID  int32
}

func (q *Queries) CreateCharacterBaseStatJunction(ctx context.Context, arg CreateCharacterBaseStatJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createCharacterBaseStatJunction, arg.DataHash, arg.CharacterID, arg.BaseStatID)
	return err
}

const createCharacterClass = `-- name: CreateCharacterClass :one
INSERT INTO character_classes (data_hash, name)
VALUES ($1, $2)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = character_classes.data_hash
RETURNING id, data_hash, name
`

type CreateCharacterClassParams struct {
	DataHash string
	Name     string
}

func (q *Queries) CreateCharacterClass(ctx context.Context, arg CreateCharacterClassParams) (CharacterClass, error) {
	row := q.db.QueryRowContext(ctx, createCharacterClass, arg.DataHash, arg.Name)
	var i CharacterClass
	err := row.Scan(&i.ID, &i.DataHash, &i.Name)
	return i, err
}

const createPlayerUnit = `-- name: CreatePlayerUnit :one
INSERT INTO player_units (data_hash, name, type)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = player_units.data_hash
RETURNING id, data_hash, name, type
`

type CreatePlayerUnitParams struct {
	DataHash string
	Name     string
	Type     UnitType
}

func (q *Queries) CreatePlayerUnit(ctx context.Context, arg CreatePlayerUnitParams) (PlayerUnit, error) {
	row := q.db.QueryRowContext(ctx, createPlayerUnit, arg.DataHash, arg.Name, arg.Type)
	var i PlayerUnit
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Name,
		&i.Type,
	)
	return i, err
}

const createUnitsCharClassesJunction = `-- name: CreateUnitsCharClassesJunction :exec
INSERT INTO j_unit_character_class (data_hash, unit_id, class_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateUnitsCharClassesJunctionParams struct {
	DataHash string
	UnitID   int32
	ClassID  int32
}

func (q *Queries) CreateUnitsCharClassesJunction(ctx context.Context, arg CreateUnitsCharClassesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createUnitsCharClassesJunction, arg.DataHash, arg.UnitID, arg.ClassID)
	return err
}

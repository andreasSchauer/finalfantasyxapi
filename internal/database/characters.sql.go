// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: characters.sql

package database

import (
	"context"
	"database/sql"
)

const createAeon = `-- name: CreateAeon :one
INSERT INTO aeons (data_hash, unit_id, unlock_condition, is_optional, battles_to_regenerate, phys_atk_damage_constant, phys_atk_range, phys_atk_shatter_rate, phys_atk_acc_source, phys_atk_hit_chance, phys_atk_acc_modifier)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = aeons.data_hash
RETURNING id, data_hash, unit_id, unlock_condition, is_optional, battles_to_regenerate, phys_atk_damage_constant, phys_atk_range, phys_atk_shatter_rate, phys_atk_acc_source, phys_atk_hit_chance, phys_atk_acc_modifier, area_id
`

type CreateAeonParams struct {
	DataHash              string
	UnitID                int32
	UnlockCondition       string
	IsOptional            bool
	BattlesToRegenerate   int32
	PhysAtkDamageConstant sql.NullInt32
	PhysAtkRange          interface{}
	PhysAtkShatterRate    interface{}
	PhysAtkAccSource      NullAccuracySource
	PhysAtkHitChance      interface{}
	PhysAtkAccModifier    sql.NullFloat64
}

func (q *Queries) CreateAeon(ctx context.Context, arg CreateAeonParams) (Aeon, error) {
	row := q.db.QueryRowContext(ctx, createAeon,
		arg.DataHash,
		arg.UnitID,
		arg.UnlockCondition,
		arg.IsOptional,
		arg.BattlesToRegenerate,
		arg.PhysAtkDamageConstant,
		arg.PhysAtkRange,
		arg.PhysAtkShatterRate,
		arg.PhysAtkAccSource,
		arg.PhysAtkHitChance,
		arg.PhysAtkAccModifier,
	)
	var i Aeon
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.UnitID,
		&i.UnlockCondition,
		&i.IsOptional,
		&i.BattlesToRegenerate,
		&i.PhysAtkDamageConstant,
		&i.PhysAtkRange,
		&i.PhysAtkShatterRate,
		&i.PhysAtkAccSource,
		&i.PhysAtkHitChance,
		&i.PhysAtkAccModifier,
		&i.AreaID,
	)
	return i, err
}

const createAeonBaseStatJunction = `-- name: CreateAeonBaseStatJunction :exec
INSERT INTO j_aeon_base_stat (data_hash, aeon_id, base_stat_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAeonBaseStatJunctionParams struct {
	DataHash   string
	AeonID     int32
	BaseStatID int32
}

func (q *Queries) CreateAeonBaseStatJunction(ctx context.Context, arg CreateAeonBaseStatJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAeonBaseStatJunction, arg.DataHash, arg.AeonID, arg.BaseStatID)
	return err
}

const createAeonEquipment = `-- name: CreateAeonEquipment :one
INSERT INTO aeon_equipments (data_hash, auto_ability_id, celestial_wpn, equip_type)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = aeon_equipments.data_hash
RETURNING id, data_hash, auto_ability_id, celestial_wpn, equip_type
`

type CreateAeonEquipmentParams struct {
	DataHash      string
	AutoAbilityID int32
	CelestialWpn  bool
	EquipType     EquipType
}

func (q *Queries) CreateAeonEquipment(ctx context.Context, arg CreateAeonEquipmentParams) (AeonEquipment, error) {
	row := q.db.QueryRowContext(ctx, createAeonEquipment,
		arg.DataHash,
		arg.AutoAbilityID,
		arg.CelestialWpn,
		arg.EquipType,
	)
	var i AeonEquipment
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.AutoAbilityID,
		&i.CelestialWpn,
		&i.EquipType,
	)
	return i, err
}

const createAeonEquipmentJunction = `-- name: CreateAeonEquipmentJunction :exec
INSERT INTO j_aeon_equipment (data_hash, aeon_id, aeon_equipment_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAeonEquipmentJunctionParams struct {
	DataHash        string
	AeonID          int32
	AeonEquipmentID int32
}

func (q *Queries) CreateAeonEquipmentJunction(ctx context.Context, arg CreateAeonEquipmentJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAeonEquipmentJunction, arg.DataHash, arg.AeonID, arg.AeonEquipmentID)
	return err
}

const createCharacter = `-- name: CreateCharacter :one
INSERT INTO characters (data_hash, unit_id, story_only, weapon_type, armor_type, physical_attack_range, can_fight_underwater)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = characters.data_hash
RETURNING id, data_hash, unit_id, story_only, weapon_type, armor_type, physical_attack_range, can_fight_underwater
`

type CreateCharacterParams struct {
	DataHash            string
	UnitID              int32
	StoryOnly           bool
	WeaponType          WeaponType
	ArmorType           ArmorType
	PhysicalAttackRange interface{}
	CanFightUnderwater  bool
}

func (q *Queries) CreateCharacter(ctx context.Context, arg CreateCharacterParams) (Character, error) {
	row := q.db.QueryRowContext(ctx, createCharacter,
		arg.DataHash,
		arg.UnitID,
		arg.StoryOnly,
		arg.WeaponType,
		arg.ArmorType,
		arg.PhysicalAttackRange,
		arg.CanFightUnderwater,
	)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.UnitID,
		&i.StoryOnly,
		&i.WeaponType,
		&i.ArmorType,
		&i.PhysicalAttackRange,
		&i.CanFightUnderwater,
	)
	return i, err
}

const createCharacterBaseStatJunction = `-- name: CreateCharacterBaseStatJunction :exec
INSERT INTO j_character_base_stat (data_hash, character_id, base_stat_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = j_character_base_stat.data_hash
RETURNING id, data_hash, character_id, base_stat_id
`

type CreateCharacterBaseStatJunctionParams struct {
	DataHash    string
	CharacterID int32
	BaseStatID  int32
}

func (q *Queries) CreateCharacterBaseStatJunction(ctx context.Context, arg CreateCharacterBaseStatJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createCharacterBaseStatJunction, arg.DataHash, arg.CharacterID, arg.BaseStatID)
	return err
}

const createCharacterClass = `-- name: CreateCharacterClass :one
INSERT INTO character_classes (data_hash, name)
VALUES ($1, $2)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = character_classes.data_hash
RETURNING id, data_hash, name
`

type CreateCharacterClassParams struct {
	DataHash string
	Name     string
}

func (q *Queries) CreateCharacterClass(ctx context.Context, arg CreateCharacterClassParams) (CharacterClass, error) {
	row := q.db.QueryRowContext(ctx, createCharacterClass, arg.DataHash, arg.Name)
	var i CharacterClass
	err := row.Scan(&i.ID, &i.DataHash, &i.Name)
	return i, err
}

const createDefaultAbility = `-- name: CreateDefaultAbility :exec
INSERT INTO default_abilities (data_hash, class_id, ability_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateDefaultAbilityParams struct {
	DataHash  string
	ClassID   int32
	AbilityID int32
}

func (q *Queries) CreateDefaultAbility(ctx context.Context, arg CreateDefaultAbilityParams) error {
	_, err := q.db.ExecContext(ctx, createDefaultAbility, arg.DataHash, arg.ClassID, arg.AbilityID)
	return err
}

const createDefaultOverdriveAbility = `-- name: CreateDefaultOverdriveAbility :exec
INSERT INTO default_overdrive_abilities (data_hash, class_id, ability_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateDefaultOverdriveAbilityParams struct {
	DataHash  string
	ClassID   int32
	AbilityID int32
}

func (q *Queries) CreateDefaultOverdriveAbility(ctx context.Context, arg CreateDefaultOverdriveAbilityParams) error {
	_, err := q.db.ExecContext(ctx, createDefaultOverdriveAbility, arg.DataHash, arg.ClassID, arg.AbilityID)
	return err
}

const createPlayerUnit = `-- name: CreatePlayerUnit :one
INSERT INTO player_units (data_hash, name, type)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = player_units.data_hash
RETURNING id, data_hash, name, type
`

type CreatePlayerUnitParams struct {
	DataHash string
	Name     string
	Type     UnitType
}

func (q *Queries) CreatePlayerUnit(ctx context.Context, arg CreatePlayerUnitParams) (PlayerUnit, error) {
	row := q.db.QueryRowContext(ctx, createPlayerUnit, arg.DataHash, arg.Name, arg.Type)
	var i PlayerUnit
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Name,
		&i.Type,
	)
	return i, err
}

const createUnitsCharClassesJunction = `-- name: CreateUnitsCharClassesJunction :exec
INSERT INTO j_unit_character_class (data_hash, unit_id, class_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateUnitsCharClassesJunctionParams struct {
	DataHash string
	UnitID   int32
	ClassID  int32
}

func (q *Queries) CreateUnitsCharClassesJunction(ctx context.Context, arg CreateUnitsCharClassesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createUnitsCharClassesJunction, arg.DataHash, arg.UnitID, arg.ClassID)
	return err
}

const updateAeon = `-- name: UpdateAeon :exec
UPDATE aeons
SET data_hash = $1,
    unit_id = $2,
    unlock_condition = $3,
    is_optional = $4,
    battles_to_regenerate = $5,
    phys_atk_damage_constant = $6,
    phys_atk_range = $7,
    phys_atk_shatter_rate = $8,
    phys_atk_acc_source = $9,
    phys_atk_hit_chance = $10,
    phys_atk_acc_modifier = $11,
    area_id = $12
WHERE id = $13
`

type UpdateAeonParams struct {
	DataHash              string
	UnitID                int32
	UnlockCondition       string
	IsOptional            bool
	BattlesToRegenerate   int32
	PhysAtkDamageConstant sql.NullInt32
	PhysAtkRange          interface{}
	PhysAtkShatterRate    interface{}
	PhysAtkAccSource      NullAccuracySource
	PhysAtkHitChance      interface{}
	PhysAtkAccModifier    sql.NullFloat64
	AreaID                sql.NullInt32
	ID                    int32
}

func (q *Queries) UpdateAeon(ctx context.Context, arg UpdateAeonParams) error {
	_, err := q.db.ExecContext(ctx, updateAeon,
		arg.DataHash,
		arg.UnitID,
		arg.UnlockCondition,
		arg.IsOptional,
		arg.BattlesToRegenerate,
		arg.PhysAtkDamageConstant,
		arg.PhysAtkRange,
		arg.PhysAtkShatterRate,
		arg.PhysAtkAccSource,
		arg.PhysAtkHitChance,
		arg.PhysAtkAccModifier,
		arg.AreaID,
		arg.ID,
	)
	return err
}

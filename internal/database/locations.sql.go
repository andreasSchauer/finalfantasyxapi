// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: locations.sql

package database

import (
	"context"
	"database/sql"
)

const createArea = `-- name: CreateArea :one
INSERT INTO areas (data_hash, sublocation_id, name, version, specification, story_only, has_save_sphere, airship_drop_off, has_compilation_sphere, can_ride_chocobo)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = areas.data_hash
RETURNING id, data_hash, sublocation_id, name, version, specification, story_only, has_save_sphere, airship_drop_off, has_compilation_sphere, can_ride_chocobo
`

type CreateAreaParams struct {
	DataHash             string
	SublocationID        int32
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	StoryOnly            bool
	HasSaveSphere        bool
	AirshipDropOff       bool
	HasCompilationSphere bool
	CanRideChocobo       bool
}

func (q *Queries) CreateArea(ctx context.Context, arg CreateAreaParams) (Area, error) {
	row := q.db.QueryRowContext(ctx, createArea,
		arg.DataHash,
		arg.SublocationID,
		arg.Name,
		arg.Version,
		arg.Specification,
		arg.StoryOnly,
		arg.HasSaveSphere,
		arg.AirshipDropOff,
		arg.HasCompilationSphere,
		arg.CanRideChocobo,
	)
	var i Area
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.SublocationID,
		&i.Name,
		&i.Version,
		&i.Specification,
		&i.StoryOnly,
		&i.HasSaveSphere,
		&i.AirshipDropOff,
		&i.HasCompilationSphere,
		&i.CanRideChocobo,
	)
	return i, err
}

const createAreaConnectedAreasJunction = `-- name: CreateAreaConnectedAreasJunction :exec
INSERT INTO j_area_connected_areas (data_hash, area_id, connection_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAreaConnectedAreasJunctionParams struct {
	DataHash     string
	AreaID       int32
	ConnectionID int32
}

func (q *Queries) CreateAreaConnectedAreasJunction(ctx context.Context, arg CreateAreaConnectedAreasJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAreaConnectedAreasJunction, arg.DataHash, arg.AreaID, arg.ConnectionID)
	return err
}

const createAreaConnection = `-- name: CreateAreaConnection :one
INSERT INTO area_connections (data_hash, area_id, connection_type, story_only, notes)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = area_connections.data_hash
RETURNING id, data_hash, area_id, connection_type, story_only, notes
`

type CreateAreaConnectionParams struct {
	DataHash       string
	AreaID         int32
	ConnectionType AreaConnectionType
	StoryOnly      bool
	Notes          sql.NullString
}

func (q *Queries) CreateAreaConnection(ctx context.Context, arg CreateAreaConnectionParams) (AreaConnection, error) {
	row := q.db.QueryRowContext(ctx, createAreaConnection,
		arg.DataHash,
		arg.AreaID,
		arg.ConnectionType,
		arg.StoryOnly,
		arg.Notes,
	)
	var i AreaConnection
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.AreaID,
		&i.ConnectionType,
		&i.StoryOnly,
		&i.Notes,
	)
	return i, err
}

const createEncounterLocation = `-- name: CreateEncounterLocation :one
INSERT INTO encounter_locations (data_hash, version, area_id, notes)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = encounter_locations.data_hash
RETURNING id, data_hash, version, area_id, notes
`

type CreateEncounterLocationParams struct {
	DataHash string
	Version  sql.NullInt32
	AreaID   int32
	Notes    sql.NullString
}

func (q *Queries) CreateEncounterLocation(ctx context.Context, arg CreateEncounterLocationParams) (EncounterLocation, error) {
	row := q.db.QueryRowContext(ctx, createEncounterLocation,
		arg.DataHash,
		arg.Version,
		arg.AreaID,
		arg.Notes,
	)
	var i EncounterLocation
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Version,
		&i.AreaID,
		&i.Notes,
	)
	return i, err
}

const createEncounterLocationFormationsJunction = `-- name: CreateEncounterLocationFormationsJunction :exec
INSERT INTO j_encounter_location_formations (data_hash, encounter_location_id, monster_formation_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateEncounterLocationFormationsJunctionParams struct {
	DataHash            string
	EncounterLocationID int32
	MonsterFormationID  int32
}

func (q *Queries) CreateEncounterLocationFormationsJunction(ctx context.Context, arg CreateEncounterLocationFormationsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createEncounterLocationFormationsJunction, arg.DataHash, arg.EncounterLocationID, arg.MonsterFormationID)
	return err
}

const createFormationBossSong = `-- name: CreateFormationBossSong :one
INSERT INTO formation_boss_songs (data_hash, song_id, celebrate_victory)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = formation_boss_songs.data_hash
RETURNING id, data_hash, song_id, celebrate_victory
`

type CreateFormationBossSongParams struct {
	DataHash         string
	SongID           int32
	CelebrateVictory bool
}

func (q *Queries) CreateFormationBossSong(ctx context.Context, arg CreateFormationBossSongParams) (FormationBossSong, error) {
	row := q.db.QueryRowContext(ctx, createFormationBossSong, arg.DataHash, arg.SongID, arg.CelebrateVictory)
	var i FormationBossSong
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.SongID,
		&i.CelebrateVictory,
	)
	return i, err
}

const createFoundEquipmentAbilitiesJunction = `-- name: CreateFoundEquipmentAbilitiesJunction :exec
INSERT INTO j_found_equipment_abilities (data_hash, found_equipment_id, auto_ability_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateFoundEquipmentAbilitiesJunctionParams struct {
	DataHash         string
	FoundEquipmentID int32
	AutoAbilityID    int32
}

func (q *Queries) CreateFoundEquipmentAbilitiesJunction(ctx context.Context, arg CreateFoundEquipmentAbilitiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createFoundEquipmentAbilitiesJunction, arg.DataHash, arg.FoundEquipmentID, arg.AutoAbilityID)
	return err
}

const createFoundEquipmentPiece = `-- name: CreateFoundEquipmentPiece :one
INSERT INTO found_equipment_pieces (data_hash, equipment_name_id, empty_slots_amount)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = found_equipment_pieces.data_hash
RETURNING id, data_hash, equipment_name_id, empty_slots_amount
`

type CreateFoundEquipmentPieceParams struct {
	DataHash         string
	EquipmentNameID  int32
	EmptySlotsAmount interface{}
}

func (q *Queries) CreateFoundEquipmentPiece(ctx context.Context, arg CreateFoundEquipmentPieceParams) (FoundEquipmentPiece, error) {
	row := q.db.QueryRowContext(ctx, createFoundEquipmentPiece, arg.DataHash, arg.EquipmentNameID, arg.EmptySlotsAmount)
	var i FoundEquipmentPiece
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.EquipmentNameID,
		&i.EmptySlotsAmount,
	)
	return i, err
}

const createLocation = `-- name: CreateLocation :one
INSERT INTO locations (data_hash, name)
VALUES ($1, $2)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = locations.data_hash
RETURNING id, data_hash, name
`

type CreateLocationParams struct {
	DataHash string
	Name     string
}

func (q *Queries) CreateLocation(ctx context.Context, arg CreateLocationParams) (Location, error) {
	row := q.db.QueryRowContext(ctx, createLocation, arg.DataHash, arg.Name)
	var i Location
	err := row.Scan(&i.ID, &i.DataHash, &i.Name)
	return i, err
}

const createMonsterFormation = `-- name: CreateMonsterFormation :one
INSERT INTO monster_formations (data_hash, category, is_forced_ambush, can_escape, boss_song_id, notes)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monster_formations.data_hash
RETURNING id, data_hash, category, is_forced_ambush, can_escape, boss_song_id, notes
`

type CreateMonsterFormationParams struct {
	DataHash       string
	Category       MonsterFormationCategory
	IsForcedAmbush bool
	CanEscape      bool
	BossSongID     sql.NullInt32
	Notes          sql.NullString
}

func (q *Queries) CreateMonsterFormation(ctx context.Context, arg CreateMonsterFormationParams) (MonsterFormation, error) {
	row := q.db.QueryRowContext(ctx, createMonsterFormation,
		arg.DataHash,
		arg.Category,
		arg.IsForcedAmbush,
		arg.CanEscape,
		arg.BossSongID,
		arg.Notes,
	)
	var i MonsterFormation
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Category,
		&i.IsForcedAmbush,
		&i.CanEscape,
		&i.BossSongID,
		&i.Notes,
	)
	return i, err
}

const createMonsterFormationsMonstersJunction = `-- name: CreateMonsterFormationsMonstersJunction :exec
INSERT INTO j_monster_formations_monsters (data_hash, monster_formation_id, monster_amount_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterFormationsMonstersJunctionParams struct {
	DataHash           string
	MonsterFormationID int32
	MonsterAmountID    int32
}

func (q *Queries) CreateMonsterFormationsMonstersJunction(ctx context.Context, arg CreateMonsterFormationsMonstersJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterFormationsMonstersJunction, arg.DataHash, arg.MonsterFormationID, arg.MonsterAmountID)
	return err
}

const createMonsterFormationsTriggerCommandsJunction = `-- name: CreateMonsterFormationsTriggerCommandsJunction :exec
INSERT INTO j_monster_formations_trigger_commands (data_hash, monster_formation_id, trigger_command_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterFormationsTriggerCommandsJunctionParams struct {
	DataHash           string
	MonsterFormationID int32
	TriggerCommandID   int32
}

func (q *Queries) CreateMonsterFormationsTriggerCommandsJunction(ctx context.Context, arg CreateMonsterFormationsTriggerCommandsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterFormationsTriggerCommandsJunction, arg.DataHash, arg.MonsterFormationID, arg.TriggerCommandID)
	return err
}

const createShop = `-- name: CreateShop :one
INSERT INTO shops (data_hash, version, area_id, notes, category)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = shops.data_hash
RETURNING id, data_hash, version, area_id, notes, category
`

type CreateShopParams struct {
	DataHash string
	Version  sql.NullInt32
	AreaID   int32
	Notes    sql.NullString
	Category ShopCategory
}

func (q *Queries) CreateShop(ctx context.Context, arg CreateShopParams) (Shop, error) {
	row := q.db.QueryRowContext(ctx, createShop,
		arg.DataHash,
		arg.Version,
		arg.AreaID,
		arg.Notes,
		arg.Category,
	)
	var i Shop
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Version,
		&i.AreaID,
		&i.Notes,
		&i.Category,
	)
	return i, err
}

const createShopEquipmentPiece = `-- name: CreateShopEquipmentPiece :one
INSERT INTO shop_equipment_pieces (data_hash, found_equipment_id, price)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = shop_equipment_pieces.data_hash
RETURNING id, data_hash, found_equipment_id, price
`

type CreateShopEquipmentPieceParams struct {
	DataHash         string
	FoundEquipmentID int32
	Price            int32
}

func (q *Queries) CreateShopEquipmentPiece(ctx context.Context, arg CreateShopEquipmentPieceParams) (ShopEquipmentPiece, error) {
	row := q.db.QueryRowContext(ctx, createShopEquipmentPiece, arg.DataHash, arg.FoundEquipmentID, arg.Price)
	var i ShopEquipmentPiece
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.FoundEquipmentID,
		&i.Price,
	)
	return i, err
}

const createShopItem = `-- name: CreateShopItem :one
INSERT INTO shop_items (data_hash, item_id, price)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = shop_items.data_hash
RETURNING id, data_hash, item_id, price
`

type CreateShopItemParams struct {
	DataHash string
	ItemID   int32
	Price    int32
}

func (q *Queries) CreateShopItem(ctx context.Context, arg CreateShopItemParams) (ShopItem, error) {
	row := q.db.QueryRowContext(ctx, createShopItem, arg.DataHash, arg.ItemID, arg.Price)
	var i ShopItem
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.ItemID,
		&i.Price,
	)
	return i, err
}

const createShopsEquipmentJunction = `-- name: CreateShopsEquipmentJunction :exec
INSERT INTO j_shops_equipment (data_hash, shop_id, shop_equipment_id, shop_type)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateShopsEquipmentJunctionParams struct {
	DataHash        string
	ShopID          int32
	ShopEquipmentID int32
	ShopType        ShopType
}

func (q *Queries) CreateShopsEquipmentJunction(ctx context.Context, arg CreateShopsEquipmentJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createShopsEquipmentJunction,
		arg.DataHash,
		arg.ShopID,
		arg.ShopEquipmentID,
		arg.ShopType,
	)
	return err
}

const createShopsItemsJunction = `-- name: CreateShopsItemsJunction :exec
INSERT INTO j_shops_items (data_hash, shop_id, shop_item_id, shop_type)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateShopsItemsJunctionParams struct {
	DataHash   string
	ShopID     int32
	ShopItemID int32
	ShopType   ShopType
}

func (q *Queries) CreateShopsItemsJunction(ctx context.Context, arg CreateShopsItemsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createShopsItemsJunction,
		arg.DataHash,
		arg.ShopID,
		arg.ShopItemID,
		arg.ShopType,
	)
	return err
}

const createSubLocation = `-- name: CreateSubLocation :one
INSERT INTO sublocations (data_hash, location_id, name, specification)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = sublocations.data_hash
RETURNING id, data_hash, location_id, name, specification
`

type CreateSubLocationParams struct {
	DataHash      string
	LocationID    int32
	Name          string
	Specification sql.NullString
}

func (q *Queries) CreateSubLocation(ctx context.Context, arg CreateSubLocationParams) (Sublocation, error) {
	row := q.db.QueryRowContext(ctx, createSubLocation,
		arg.DataHash,
		arg.LocationID,
		arg.Name,
		arg.Specification,
	)
	var i Sublocation
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.LocationID,
		&i.Name,
		&i.Specification,
	)
	return i, err
}

const createTreasure = `-- name: CreateTreasure :one
INSERT INTO treasures (data_hash, area_id, version, treasure_type, loot_type, is_post_airship, is_anima_treasure, notes, gil_amount)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = treasures.data_hash
RETURNING id, data_hash, area_id, version, treasure_type, loot_type, is_post_airship, is_anima_treasure, notes, gil_amount, found_equipment_id
`

type CreateTreasureParams struct {
	DataHash        string
	AreaID          int32
	Version         int32
	TreasureType    TreasureType
	LootType        LootType
	IsPostAirship   bool
	IsAnimaTreasure bool
	Notes           sql.NullString
	GilAmount       sql.NullInt32
}

func (q *Queries) CreateTreasure(ctx context.Context, arg CreateTreasureParams) (Treasure, error) {
	row := q.db.QueryRowContext(ctx, createTreasure,
		arg.DataHash,
		arg.AreaID,
		arg.Version,
		arg.TreasureType,
		arg.LootType,
		arg.IsPostAirship,
		arg.IsAnimaTreasure,
		arg.Notes,
		arg.GilAmount,
	)
	var i Treasure
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.AreaID,
		&i.Version,
		&i.TreasureType,
		&i.LootType,
		&i.IsPostAirship,
		&i.IsAnimaTreasure,
		&i.Notes,
		&i.GilAmount,
		&i.FoundEquipmentID,
	)
	return i, err
}

const createTreasuresItemsJunction = `-- name: CreateTreasuresItemsJunction :exec
INSERT INTO j_treasures_items (data_hash, treasure_id, item_amount_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateTreasuresItemsJunctionParams struct {
	DataHash     string
	TreasureID   int32
	ItemAmountID int32
}

func (q *Queries) CreateTreasuresItemsJunction(ctx context.Context, arg CreateTreasuresItemsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createTreasuresItemsJunction, arg.DataHash, arg.TreasureID, arg.ItemAmountID)
	return err
}

const getArea = `-- name: GetArea :one
SELECT
    l.id AS location_id,
    l.name AS location,
    s.name AS sublocation,
    a.id, a.data_hash, a.sublocation_id, a.name, a.version, a.specification, a.story_only, a.has_save_sphere, a.airship_drop_off, a.has_compilation_sphere, a.can_ride_chocobo
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id 
JOIN locations l ON s.location_id = l.id
WHERE a.id = $1
`

type GetAreaRow struct {
	LocationID           int32
	Location             string
	Sublocation          string
	ID                   int32
	DataHash             string
	SublocationID        int32
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	StoryOnly            bool
	HasSaveSphere        bool
	AirshipDropOff       bool
	HasCompilationSphere bool
	CanRideChocobo       bool
}

func (q *Queries) GetArea(ctx context.Context, id int32) (GetAreaRow, error) {
	row := q.db.QueryRowContext(ctx, getArea, id)
	var i GetAreaRow
	err := row.Scan(
		&i.LocationID,
		&i.Location,
		&i.Sublocation,
		&i.ID,
		&i.DataHash,
		&i.SublocationID,
		&i.Name,
		&i.Version,
		&i.Specification,
		&i.StoryOnly,
		&i.HasSaveSphere,
		&i.AirshipDropOff,
		&i.HasCompilationSphere,
		&i.CanRideChocobo,
	)
	return i, err
}

const getAreaAeonIDs = `-- name: GetAreaAeonIDs :many
SELECT ae.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN aeons ae ON ae.area_id = a.id
JOIN player_units pu ON ae.unit_id = pu.id
WHERE a.id = $1
ORDER BY ae.id
`

func (q *Queries) GetAreaAeonIDs(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaAeonIDs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaBackgroundMusic = `-- name: GetAreaBackgroundMusic :many
SELECT so.id, bm.replaces_encounter_music
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN j_songs_background_music j ON j.area_id = a.id 
JOIN background_music bm ON j.bm_id = bm.id
JOIN songs so ON j.song_id = so.id
WHERE a.id = $1
ORDER BY so.id
`

type GetAreaBackgroundMusicRow struct {
	ID                     int32
	ReplacesEncounterMusic bool
}

func (q *Queries) GetAreaBackgroundMusic(ctx context.Context, id int32) ([]GetAreaBackgroundMusicRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreaBackgroundMusic, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreaBackgroundMusicRow
	for rows.Next() {
		var i GetAreaBackgroundMusicRow
		if err := rows.Scan(&i.ID, &i.ReplacesEncounterMusic); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaBossSongIDs = `-- name: GetAreaBossSongIDs :many
SELECT DISTINCT so.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN encounter_locations el ON el.area_id = a.id
JOIN j_encounter_location_formations j ON j.encounter_location_id = el.id
JOIN monster_formations mf ON j.monster_formation_id = mf.id
JOIN formation_boss_songs bs ON mf.boss_song_id = bs.id
JOIN songs so ON bs.song_id = so.id
WHERE a.id = $1
ORDER BY so.id
`

func (q *Queries) GetAreaBossSongIDs(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaBossSongIDs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaCharacterIDs = `-- name: GetAreaCharacterIDs :many
SELECT c.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN characters c ON c.area_id = a.id
JOIN player_units pu ON c.unit_id = pu.id
WHERE a.id = $1
ORDER BY c.id
`

func (q *Queries) GetAreaCharacterIDs(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaCharacterIDs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaConnectionIDs = `-- name: GetAreaConnectionIDs :many
SELECT a.id
FROM area_connections ac
JOIN j_area_connected_areas j ON j.connection_id = ac.id
JOIN areas a ON ac.area_id = a.id
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN areas a2 ON j.area_id = a2.id
WHERE a2.id = $1
ORDER BY a.id
`

func (q *Queries) GetAreaConnectionIDs(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaConnectionIDs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaCues = `-- name: GetAreaCues :many
SELECT DISTINCT so.id, c.replaces_encounter_music
FROM cues c
JOIN songs so ON c.song_id = so.id
JOIN j_songs_cues j ON j.cue_id = c.id
JOIN areas a ON COALESCE(c.trigger_area_id, j.included_area_id) = a.id
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
WHERE j.included_area_id = $1 OR c.trigger_area_id = $1
ORDER BY so.id
`

type GetAreaCuesRow struct {
	ID                     int32
	ReplacesEncounterMusic bool
}

func (q *Queries) GetAreaCues(ctx context.Context, includedAreaID int32) ([]GetAreaCuesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreaCues, includedAreaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreaCuesRow
	for rows.Next() {
		var i GetAreaCuesRow
		if err := rows.Scan(&i.ID, &i.ReplacesEncounterMusic); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaFMVSongIDs = `-- name: GetAreaFMVSongIDs :many
SELECT DISTINCT so.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN fmvs f ON f.area_id = a.id
JOIN songs so ON f.song_id = so.id
WHERE a.id = $1
ORDER BY so.id
`

func (q *Queries) GetAreaFMVSongIDs(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaFMVSongIDs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaFmvIDs = `-- name: GetAreaFmvIDs :many
SELECT f.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN fmvs f ON f.area_id = a.id
WHERE a.id = $1
ORDER BY f.id
`

func (q *Queries) GetAreaFmvIDs(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaFmvIDs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsAeons = `-- name: GetAreaIDsAeons :many
SELECT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN aeons ae ON ae.area_id = a.id
JOIN player_units pu ON ae.unit_id = pu.id
ORDER BY a.id
`

func (q *Queries) GetAreaIDsAeons(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsAeons)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsBosses = `-- name: GetAreaIDsBosses :many
SELECT DISTINCT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN encounter_locations el ON el.area_id = a.id
JOIN j_encounter_location_formations j ON j.encounter_location_id = el.id
JOIN monster_formations mf ON j.monster_formation_id = mf.id
JOIN formation_boss_songs bs ON mf.boss_song_id = bs.id
JOIN songs so ON bs.song_id = so.id
ORDER BY a.id
`

func (q *Queries) GetAreaIDsBosses(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsBosses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsCharacters = `-- name: GetAreaIDsCharacters :many
SELECT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN characters c ON c.area_id = a.id
JOIN player_units pu ON c.unit_id = pu.id
ORDER BY a.id
`

func (q *Queries) GetAreaIDsCharacters(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsCharacters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsChocobo = `-- name: GetAreaIDsChocobo :many
SELECT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
WHERE a.can_ride_chocobo = $1
ORDER BY a.id
`

func (q *Queries) GetAreaIDsChocobo(ctx context.Context, canRideChocobo bool) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsChocobo, canRideChocobo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsFMVs = `-- name: GetAreaIDsFMVs :many
SELECT DISTINCT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN fmvs f ON f.area_id = a.id
ORDER BY a.id
`

func (q *Queries) GetAreaIDsFMVs(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsFMVs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsItemMonster = `-- name: GetAreaIDsItemMonster :many
SELECT DISTINCT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN encounter_locations el ON el.area_id = a.id
JOIN j_encounter_location_formations j1 ON j1.encounter_location_id = el.id
JOIN monster_formations mf ON j1.monster_formation_id = mf.id
JOIN j_monster_formations_monsters j2 ON j2.monster_formation_id = mf.id
JOIN monster_amounts ma ON j2.monster_amount_id = ma.id
JOIN monsters m ON ma.monster_id = m.id
JOIN monster_items mi ON mi.monster_id = m.id
LEFT JOIN j_monster_items_other_items jmio
  ON jmio.monster_items_id = mi.id
LEFT JOIN possible_items pi
  ON pi.id = jmio.possible_item_id
JOIN item_amounts ia
  ON ia.id IN (
      mi.steal_common_id,
      mi.steal_rare_id,
      mi.drop_common_id,
      mi.drop_rare_id,
      mi.secondary_drop_common_id,
      mi.secondary_drop_rare_id,
      mi.bribe_id,
      pi.item_amount_id
  )
JOIN master_items mit ON ia.master_item_id = mit.id
JOIN items i ON i.master_item_id = mit.id
WHERE i.id = $1
ORDER BY a.id
`

func (q *Queries) GetAreaIDsItemMonster(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsItemMonster, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsItemQuest = `-- name: GetAreaIDsItemQuest :many
SELECT DISTINCT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN completion_locations cl ON cl.area_id = a.id
JOIN quest_completions qc ON cl.completion_id = qc.id
JOIN item_amounts ia ON qc.item_amount_id = ia.id
JOIN master_items mi ON ia.master_item_id = mi.id
JOIN items i ON i.master_item_id = mi.id
WHERE i.id = $1
ORDER BY a.id
`

func (q *Queries) GetAreaIDsItemQuest(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsItemQuest, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsItemShop = `-- name: GetAreaIDsItemShop :many
SELECT DISTINCT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN shops sh ON sh.area_id = a.id
JOIN j_shops_items j ON j.shop_id = sh.id
JOIN shop_items si ON j.shop_item_id = si.id
JOIN items i ON si.item_id = i.id
WHERE i.id = $1
ORDER BY a.id
`

func (q *Queries) GetAreaIDsItemShop(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsItemShop, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsItemTreasure = `-- name: GetAreaIDsItemTreasure :many
SELECT DISTINCT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN treasures t ON t.area_id = a.id
JOIN j_treasures_items j ON j.treasure_id = t.id
JOIN item_amounts ia ON j.item_amount_id = ia.id
JOIN master_items mi ON ia.master_item_id = mi.id
JOIN items i ON i.master_item_id = mi.id
WHERE i.id = $1
ORDER BY a.id
`

func (q *Queries) GetAreaIDsItemTreasure(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsItemTreasure, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsKeyItemQuest = `-- name: GetAreaIDsKeyItemQuest :many
SELECT DISTINCT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN completion_locations cl ON cl.area_id = a.id
JOIN quest_completions qc ON cl.completion_id = qc.id
JOIN item_amounts ia ON qc.item_amount_id = ia.id
JOIN master_items mi ON ia.master_item_id = mi.id
JOIN key_items ki ON ki.master_item_id = mi.id
WHERE ki.id = $1
ORDER BY a.id
`

func (q *Queries) GetAreaIDsKeyItemQuest(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsKeyItemQuest, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsKeyItemTreasure = `-- name: GetAreaIDsKeyItemTreasure :many
SELECT DISTINCT a.id
FROM areas a
JOIN treasures t ON t.area_id = a.id
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN j_treasures_items j ON j.treasure_id = t.id
JOIN item_amounts ia ON j.item_amount_id = ia.id
JOIN master_items mi ON ia.master_item_id = mi.id
JOIN key_items ki ON ki.master_item_id = mi.id
WHERE ki.id = $1
ORDER BY a.id
`

func (q *Queries) GetAreaIDsKeyItemTreasure(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsKeyItemTreasure, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsMonsters = `-- name: GetAreaIDsMonsters :many
SELECT DISTINCT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN encounter_locations el ON el.area_id = a.id
JOIN j_encounter_location_formations j1 ON j1.encounter_location_id = el.id
JOIN monster_formations mf ON j1.monster_formation_id = mf.id
JOIN j_monster_formations_monsters j2 ON j2.monster_formation_id = mf.id
JOIN monster_amounts ma ON j2.monster_amount_id = ma.id
JOIN monsters m ON ma.monster_id = m.id
ORDER BY a.id
`

func (q *Queries) GetAreaIDsMonsters(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsMonsters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsShops = `-- name: GetAreaIDsShops :many
SELECT DISTINCT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN shops sh ON sh.area_id = a.id
ORDER BY a.id
`

func (q *Queries) GetAreaIDsShops(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsShops)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsSidequests = `-- name: GetAreaIDsSidequests :many
SELECT DISTINCT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN completion_locations cl ON cl.area_id = a.id
JOIN quest_completions qc ON cl.completion_id = qc.id
JOIN quests q ON qc.quest_id = q.id
ORDER BY a.id
`

func (q *Queries) GetAreaIDsSidequests(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsSidequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsStoryOnly = `-- name: GetAreaIDsStoryOnly :many
SELECT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
WHERE a.story_only = $1
ORDER BY a.id
`

func (q *Queries) GetAreaIDsStoryOnly(ctx context.Context, storyOnly bool) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsStoryOnly, storyOnly)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsTreasures = `-- name: GetAreaIDsTreasures :many
SELECT DISTINCT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN treasures t ON t.area_id = a.id
ORDER BY a.id
`

func (q *Queries) GetAreaIDsTreasures(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsTreasures)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsWithCompSphere = `-- name: GetAreaIDsWithCompSphere :many
SELECT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
WHERE a.has_compilation_sphere = $1
ORDER BY a.id
`

func (q *Queries) GetAreaIDsWithCompSphere(ctx context.Context, hasCompilationSphere bool) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsWithCompSphere, hasCompilationSphere)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsWithDropOff = `-- name: GetAreaIDsWithDropOff :many
SELECT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
WHERE a.airship_drop_off = $1
ORDER BY a.id
`

func (q *Queries) GetAreaIDsWithDropOff(ctx context.Context, airshipDropOff bool) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsWithDropOff, airshipDropOff)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaIDsWithSaveSphere = `-- name: GetAreaIDsWithSaveSphere :many
SELECT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
WHERE a.has_save_sphere = $1
ORDER BY a.id
`

func (q *Queries) GetAreaIDsWithSaveSphere(ctx context.Context, hasSaveSphere bool) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaIDsWithSaveSphere, hasSaveSphere)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaMonsterFormationIDs = `-- name: GetAreaMonsterFormationIDs :many
SELECT DISTINCT mf.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN encounter_locations el ON el.area_id = a.id
JOIN j_encounter_location_formations j ON j.encounter_location_id = el.id
JOIN monster_formations mf ON j.monster_formation_id = mf.id
WHERE a.id = $1
ORDER BY mf.id
`

func (q *Queries) GetAreaMonsterFormationIDs(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaMonsterFormationIDs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaMonsterIDs = `-- name: GetAreaMonsterIDs :many
SELECT DISTINCT m.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN encounter_locations el ON el.area_id = a.id
JOIN j_encounter_location_formations j1 ON j1.encounter_location_id = el.id
JOIN monster_formations mf ON j1.monster_formation_id = mf.id
JOIN j_monster_formations_monsters j2 ON j2.monster_formation_id = mf.id
JOIN monster_amounts ma ON j2.monster_amount_id = ma.id
JOIN monsters m ON ma.monster_id = m.id
WHERE a.id = $1
ORDER BY m.id
`

func (q *Queries) GetAreaMonsterIDs(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaMonsterIDs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaQuestIDs = `-- name: GetAreaQuestIDs :many
SELECT DISTINCT q.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN completion_locations cl ON cl.area_id = a.id
JOIN quest_completions qc ON cl.completion_id = qc.id
JOIN quests q ON qc.quest_id = q.id
WHERE a.id = $1
ORDER BY q.id
`

func (q *Queries) GetAreaQuestIDs(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaQuestIDs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaShopIDs = `-- name: GetAreaShopIDs :many
SELECT id FROM shops WHERE area_id = $1 ORDER BY id
`

func (q *Queries) GetAreaShopIDs(ctx context.Context, areaID int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaShopIDs, areaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaTreasureIDs = `-- name: GetAreaTreasureIDs :many
SELECT id FROM treasures WHERE area_id = $1 ORDER BY id
`

func (q *Queries) GetAreaTreasureIDs(ctx context.Context, areaID int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreaTreasureIDs, areaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreas = `-- name: GetAreas :many
SELECT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id 
JOIN locations l ON s.location_id = l.id
`

func (q *Queries) GetAreas(ctx context.Context) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAreas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocationAreaByAreaName = `-- name: GetLocationAreaByAreaName :one
SELECT l.name, s.name, a.name, a.version FROM locations l JOIN sublocations s ON s.location_id = l.id JOIN areas a ON a.sublocation_id = a.id
WHERE l.id = $1 AND s.id = $2 AND a.name = $3 AND a.version = $4
`

type GetLocationAreaByAreaNameParams struct {
	ID      int32
	ID_2    int32
	Name    string
	Version sql.NullInt32
}

type GetLocationAreaByAreaNameRow struct {
	Name    string
	Name_2  string
	Name_3  string
	Version sql.NullInt32
}

func (q *Queries) GetLocationAreaByAreaName(ctx context.Context, arg GetLocationAreaByAreaNameParams) (GetLocationAreaByAreaNameRow, error) {
	row := q.db.QueryRowContext(ctx, getLocationAreaByAreaName,
		arg.ID,
		arg.ID_2,
		arg.Name,
		arg.Version,
	)
	var i GetLocationAreaByAreaNameRow
	err := row.Scan(
		&i.Name,
		&i.Name_2,
		&i.Name_3,
		&i.Version,
	)
	return i, err
}

const getLocationAreaIDs = `-- name: GetLocationAreaIDs :many
SELECT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id 
JOIN locations l ON s.location_id = l.id
WHERE l.id = $1
ORDER BY a.id
`

func (q *Queries) GetLocationAreaIDs(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getLocationAreaIDs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocationConnections = `-- name: GetLocationConnections :many
SELECT
    ac.id, ac.data_hash, ac.area_id, ac.connection_type, ac.story_only, ac.notes,
    l.id AS location_id,
    l.name AS location,
    s.id AS sublocation_id,
    s.name AS sublocation,
    a.name AS area,
    a.version AS version,
    a.specification AS specification
FROM area_connections ac
JOIN j_area_connected_areas j ON j.connection_id = ac.id
JOIN areas a ON ac.area_id = a.id
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN areas a2 ON j.area_id = a2.id
JOIN sublocations s2 ON a2.sublocation_id = s2.id
JOIN locations l2 ON s2.location_id = l2.id
WHERE l2.id = $1 AND l2.id != l.id
ORDER BY ac.id
`

type GetLocationConnectionsRow struct {
	ID             int32
	DataHash       string
	AreaID         int32
	ConnectionType AreaConnectionType
	StoryOnly      bool
	Notes          sql.NullString
	LocationID     int32
	Location       string
	SublocationID  int32
	Sublocation    string
	Area           string
	Version        sql.NullInt32
	Specification  sql.NullString
}

func (q *Queries) GetLocationConnections(ctx context.Context, id int32) ([]GetLocationConnectionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLocationConnections, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLocationConnectionsRow
	for rows.Next() {
		var i GetLocationConnectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.AreaID,
			&i.ConnectionType,
			&i.StoryOnly,
			&i.Notes,
			&i.LocationID,
			&i.Location,
			&i.SublocationID,
			&i.Sublocation,
			&i.Area,
			&i.Version,
			&i.Specification,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocationMonsterIDs = `-- name: GetLocationMonsterIDs :many
SELECT DISTINCT m.id
FROM monsters m
LEFT JOIN monster_amounts ma ON ma.monster_id = m.id
LEFT JOIN j_monster_formations_monsters j1 ON j1.monster_amount_id = ma.id
LEFT JOIN monster_formations mf ON j1.monster_formation_id = mf.id
LEFT JOIN j_encounter_location_formations j2 ON j2.monster_formation_id = mf.id
LEFT JOIN encounter_locations el ON j2.encounter_location_id = el.id
LEFT JOIN areas a ON el.area_id = a.id
LEFT JOIN sublocations s ON a.sublocation_id = s.id
LEFT JOIN locations l ON s.location_id = l.id
WHERE location_id = $1
ORDER BY m.id
`

func (q *Queries) GetLocationMonsterIDs(ctx context.Context, locationID int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getLocationMonsterIDs, locationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSublocationAreaIDs = `-- name: GetSublocationAreaIDs :many
SELECT a.id
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id 
JOIN locations l ON s.location_id = l.id
WHERE s.id = $1
ORDER BY a.id
`

func (q *Queries) GetSublocationAreaIDs(ctx context.Context, id int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getSublocationAreaIDs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSublocationConnections = `-- name: GetSublocationConnections :many
SELECT
    ac.id, ac.data_hash, ac.area_id, ac.connection_type, ac.story_only, ac.notes,
    l.id AS location_id,
    l.name AS location,
    s.id AS sublocation_id,
    s.name AS sublocation,
    a.name AS area,
    a.version AS version,
    a.specification AS specification
FROM area_connections ac
JOIN j_area_connected_areas j ON j.connection_id = ac.id
JOIN areas a ON ac.area_id = a.id
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN areas a2 ON j.area_id = a2.id
JOIN sublocations s2 ON a2.sublocation_id = s2.id
WHERE s2.id = $1 AND s2.id != s.id
ORDER BY ac.id
`

type GetSublocationConnectionsRow struct {
	ID             int32
	DataHash       string
	AreaID         int32
	ConnectionType AreaConnectionType
	StoryOnly      bool
	Notes          sql.NullString
	LocationID     int32
	Location       string
	SublocationID  int32
	Sublocation    string
	Area           string
	Version        sql.NullInt32
	Specification  sql.NullString
}

func (q *Queries) GetSublocationConnections(ctx context.Context, id int32) ([]GetSublocationConnectionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSublocationConnections, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSublocationConnectionsRow
	for rows.Next() {
		var i GetSublocationConnectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.AreaID,
			&i.ConnectionType,
			&i.StoryOnly,
			&i.Notes,
			&i.LocationID,
			&i.Location,
			&i.SublocationID,
			&i.Sublocation,
			&i.Area,
			&i.Version,
			&i.Specification,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSublocationMonsterIDs = `-- name: GetSublocationMonsterIDs :many
SELECT DISTINCT m.id
FROM monsters m
LEFT JOIN monster_amounts ma ON ma.monster_id = m.id
LEFT JOIN j_monster_formations_monsters j1 ON j1.monster_amount_id = ma.id
LEFT JOIN monster_formations mf ON j1.monster_formation_id = mf.id
LEFT JOIN j_encounter_location_formations j2 ON j2.monster_formation_id = mf.id
LEFT JOIN encounter_locations el ON j2.encounter_location_id = el.id
LEFT JOIN areas a ON el.area_id = a.id
LEFT JOIN sublocations s ON a.sublocation_id = s.id
LEFT JOIN locations l ON s.location_id = l.id
WHERE sublocation_id = $1
ORDER BY m.id
`

func (q *Queries) GetSublocationMonsterIDs(ctx context.Context, sublocationID int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getSublocationMonsterIDs, sublocationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTreasure = `-- name: UpdateTreasure :exec
UPDATE treasures
SET data_hash = $1,
    found_equipment_id = $2
WHERE id = $3
`

type UpdateTreasureParams struct {
	DataHash         string
	FoundEquipmentID sql.NullInt32
	ID               int32
}

func (q *Queries) UpdateTreasure(ctx context.Context, arg UpdateTreasureParams) error {
	_, err := q.db.ExecContext(ctx, updateTreasure, arg.DataHash, arg.FoundEquipmentID, arg.ID)
	return err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: locations.sql

package database

import (
	"context"
	"database/sql"
)

const createArea = `-- name: CreateArea :one
INSERT INTO areas (data_hash, sublocation_id, name, version, specification, story_only, has_save_sphere, airship_drop_off, has_compilation_sphere, can_ride_chocobo)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = areas.data_hash
RETURNING id, data_hash, sublocation_id, name, version, specification, story_only, has_save_sphere, airship_drop_off, has_compilation_sphere, can_ride_chocobo
`

type CreateAreaParams struct {
	DataHash             string
	SublocationID        int32
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	StoryOnly            bool
	HasSaveSphere        bool
	AirshipDropOff       bool
	HasCompilationSphere bool
	CanRideChocobo       bool
}

func (q *Queries) CreateArea(ctx context.Context, arg CreateAreaParams) (Area, error) {
	row := q.db.QueryRowContext(ctx, createArea,
		arg.DataHash,
		arg.SublocationID,
		arg.Name,
		arg.Version,
		arg.Specification,
		arg.StoryOnly,
		arg.HasSaveSphere,
		arg.AirshipDropOff,
		arg.HasCompilationSphere,
		arg.CanRideChocobo,
	)
	var i Area
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.SublocationID,
		&i.Name,
		&i.Version,
		&i.Specification,
		&i.StoryOnly,
		&i.HasSaveSphere,
		&i.AirshipDropOff,
		&i.HasCompilationSphere,
		&i.CanRideChocobo,
	)
	return i, err
}

const createAreaConnectedAreasJunction = `-- name: CreateAreaConnectedAreasJunction :exec
INSERT INTO j_area_connected_areas (data_hash, area_id, connection_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAreaConnectedAreasJunctionParams struct {
	DataHash     string
	AreaID       int32
	ConnectionID int32
}

func (q *Queries) CreateAreaConnectedAreasJunction(ctx context.Context, arg CreateAreaConnectedAreasJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAreaConnectedAreasJunction, arg.DataHash, arg.AreaID, arg.ConnectionID)
	return err
}

const createAreaConnection = `-- name: CreateAreaConnection :one
INSERT INTO area_connections (data_hash, area_id, connection_type, story_only, notes)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = area_connections.data_hash
RETURNING id, data_hash, area_id, connection_type, story_only, notes
`

type CreateAreaConnectionParams struct {
	DataHash       string
	AreaID         int32
	ConnectionType AreaConnectionType
	StoryOnly      bool
	Notes          sql.NullString
}

func (q *Queries) CreateAreaConnection(ctx context.Context, arg CreateAreaConnectionParams) (AreaConnection, error) {
	row := q.db.QueryRowContext(ctx, createAreaConnection,
		arg.DataHash,
		arg.AreaID,
		arg.ConnectionType,
		arg.StoryOnly,
		arg.Notes,
	)
	var i AreaConnection
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.AreaID,
		&i.ConnectionType,
		&i.StoryOnly,
		&i.Notes,
	)
	return i, err
}

const createEncounterLocation = `-- name: CreateEncounterLocation :one
INSERT INTO encounter_locations (data_hash, version, area_id, notes)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = encounter_locations.data_hash
RETURNING id, data_hash, version, area_id, notes
`

type CreateEncounterLocationParams struct {
	DataHash string
	Version  sql.NullInt32
	AreaID   int32
	Notes    sql.NullString
}

func (q *Queries) CreateEncounterLocation(ctx context.Context, arg CreateEncounterLocationParams) (EncounterLocation, error) {
	row := q.db.QueryRowContext(ctx, createEncounterLocation,
		arg.DataHash,
		arg.Version,
		arg.AreaID,
		arg.Notes,
	)
	var i EncounterLocation
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Version,
		&i.AreaID,
		&i.Notes,
	)
	return i, err
}

const createEncounterLocationFormationsJunction = `-- name: CreateEncounterLocationFormationsJunction :exec
INSERT INTO j_encounter_location_formations (data_hash, encounter_location_id, monster_formation_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateEncounterLocationFormationsJunctionParams struct {
	DataHash            string
	EncounterLocationID int32
	MonsterFormationID  int32
}

func (q *Queries) CreateEncounterLocationFormationsJunction(ctx context.Context, arg CreateEncounterLocationFormationsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createEncounterLocationFormationsJunction, arg.DataHash, arg.EncounterLocationID, arg.MonsterFormationID)
	return err
}

const createFormationBossSong = `-- name: CreateFormationBossSong :one
INSERT INTO formation_boss_songs (data_hash, song_id, celebrate_victory)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = formation_boss_songs.data_hash
RETURNING id, data_hash, song_id, celebrate_victory
`

type CreateFormationBossSongParams struct {
	DataHash         string
	SongID           int32
	CelebrateVictory bool
}

func (q *Queries) CreateFormationBossSong(ctx context.Context, arg CreateFormationBossSongParams) (FormationBossSong, error) {
	row := q.db.QueryRowContext(ctx, createFormationBossSong, arg.DataHash, arg.SongID, arg.CelebrateVictory)
	var i FormationBossSong
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.SongID,
		&i.CelebrateVictory,
	)
	return i, err
}

const createFoundEquipmentAbilitiesJunction = `-- name: CreateFoundEquipmentAbilitiesJunction :exec
INSERT INTO j_found_equipment_abilities (data_hash, found_equipment_id, auto_ability_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateFoundEquipmentAbilitiesJunctionParams struct {
	DataHash         string
	FoundEquipmentID int32
	AutoAbilityID    int32
}

func (q *Queries) CreateFoundEquipmentAbilitiesJunction(ctx context.Context, arg CreateFoundEquipmentAbilitiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createFoundEquipmentAbilitiesJunction, arg.DataHash, arg.FoundEquipmentID, arg.AutoAbilityID)
	return err
}

const createFoundEquipmentPiece = `-- name: CreateFoundEquipmentPiece :one
INSERT INTO found_equipment_pieces (data_hash, equipment_name_id, empty_slots_amount)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = found_equipment_pieces.data_hash
RETURNING id, data_hash, equipment_name_id, empty_slots_amount
`

type CreateFoundEquipmentPieceParams struct {
	DataHash         string
	EquipmentNameID  int32
	EmptySlotsAmount interface{}
}

func (q *Queries) CreateFoundEquipmentPiece(ctx context.Context, arg CreateFoundEquipmentPieceParams) (FoundEquipmentPiece, error) {
	row := q.db.QueryRowContext(ctx, createFoundEquipmentPiece, arg.DataHash, arg.EquipmentNameID, arg.EmptySlotsAmount)
	var i FoundEquipmentPiece
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.EquipmentNameID,
		&i.EmptySlotsAmount,
	)
	return i, err
}

const createLocation = `-- name: CreateLocation :one
INSERT INTO locations (data_hash, name)
VALUES ($1, $2)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = locations.data_hash
RETURNING id, data_hash, name
`

type CreateLocationParams struct {
	DataHash string
	Name     string
}

func (q *Queries) CreateLocation(ctx context.Context, arg CreateLocationParams) (Location, error) {
	row := q.db.QueryRowContext(ctx, createLocation, arg.DataHash, arg.Name)
	var i Location
	err := row.Scan(&i.ID, &i.DataHash, &i.Name)
	return i, err
}

const createMonsterFormation = `-- name: CreateMonsterFormation :one
INSERT INTO monster_formations (data_hash, category, is_forced_ambush, can_escape, boss_song_id, notes)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monster_formations.data_hash
RETURNING id, data_hash, category, is_forced_ambush, can_escape, boss_song_id, notes
`

type CreateMonsterFormationParams struct {
	DataHash       string
	Category       MonsterFormationCategory
	IsForcedAmbush bool
	CanEscape      bool
	BossSongID     sql.NullInt32
	Notes          sql.NullString
}

func (q *Queries) CreateMonsterFormation(ctx context.Context, arg CreateMonsterFormationParams) (MonsterFormation, error) {
	row := q.db.QueryRowContext(ctx, createMonsterFormation,
		arg.DataHash,
		arg.Category,
		arg.IsForcedAmbush,
		arg.CanEscape,
		arg.BossSongID,
		arg.Notes,
	)
	var i MonsterFormation
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Category,
		&i.IsForcedAmbush,
		&i.CanEscape,
		&i.BossSongID,
		&i.Notes,
	)
	return i, err
}

const createMonsterFormationsMonstersJunction = `-- name: CreateMonsterFormationsMonstersJunction :exec
INSERT INTO j_monster_formations_monsters (data_hash, monster_formation_id, monster_amount_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterFormationsMonstersJunctionParams struct {
	DataHash           string
	MonsterFormationID int32
	MonsterAmountID    int32
}

func (q *Queries) CreateMonsterFormationsMonstersJunction(ctx context.Context, arg CreateMonsterFormationsMonstersJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterFormationsMonstersJunction, arg.DataHash, arg.MonsterFormationID, arg.MonsterAmountID)
	return err
}

const createMonsterFormationsTriggerCommandsJunction = `-- name: CreateMonsterFormationsTriggerCommandsJunction :exec
INSERT INTO j_monster_formations_trigger_commands (data_hash, monster_formation_id, trigger_command_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterFormationsTriggerCommandsJunctionParams struct {
	DataHash           string
	MonsterFormationID int32
	TriggerCommandID   int32
}

func (q *Queries) CreateMonsterFormationsTriggerCommandsJunction(ctx context.Context, arg CreateMonsterFormationsTriggerCommandsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterFormationsTriggerCommandsJunction, arg.DataHash, arg.MonsterFormationID, arg.TriggerCommandID)
	return err
}

const createShop = `-- name: CreateShop :one
INSERT INTO shops (data_hash, version, area_id, notes, category)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = shops.data_hash
RETURNING id, data_hash, version, area_id, notes, category
`

type CreateShopParams struct {
	DataHash string
	Version  sql.NullInt32
	AreaID   int32
	Notes    sql.NullString
	Category ShopCategory
}

func (q *Queries) CreateShop(ctx context.Context, arg CreateShopParams) (Shop, error) {
	row := q.db.QueryRowContext(ctx, createShop,
		arg.DataHash,
		arg.Version,
		arg.AreaID,
		arg.Notes,
		arg.Category,
	)
	var i Shop
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Version,
		&i.AreaID,
		&i.Notes,
		&i.Category,
	)
	return i, err
}

const createShopEquipmentPiece = `-- name: CreateShopEquipmentPiece :one
INSERT INTO shop_equipment_pieces (data_hash, found_equipment_id, price)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = shop_equipment_pieces.data_hash
RETURNING id, data_hash, found_equipment_id, price
`

type CreateShopEquipmentPieceParams struct {
	DataHash         string
	FoundEquipmentID int32
	Price            int32
}

func (q *Queries) CreateShopEquipmentPiece(ctx context.Context, arg CreateShopEquipmentPieceParams) (ShopEquipmentPiece, error) {
	row := q.db.QueryRowContext(ctx, createShopEquipmentPiece, arg.DataHash, arg.FoundEquipmentID, arg.Price)
	var i ShopEquipmentPiece
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.FoundEquipmentID,
		&i.Price,
	)
	return i, err
}

const createShopItem = `-- name: CreateShopItem :one
INSERT INTO shop_items (data_hash, item_id, price)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = shop_items.data_hash
RETURNING id, data_hash, item_id, price
`

type CreateShopItemParams struct {
	DataHash string
	ItemID   int32
	Price    int32
}

func (q *Queries) CreateShopItem(ctx context.Context, arg CreateShopItemParams) (ShopItem, error) {
	row := q.db.QueryRowContext(ctx, createShopItem, arg.DataHash, arg.ItemID, arg.Price)
	var i ShopItem
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.ItemID,
		&i.Price,
	)
	return i, err
}

const createShopsEquipmentJunction = `-- name: CreateShopsEquipmentJunction :exec
INSERT INTO j_shops_equipment (data_hash, shop_id, shop_equipment_id, shop_type)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateShopsEquipmentJunctionParams struct {
	DataHash        string
	ShopID          int32
	ShopEquipmentID int32
	ShopType        ShopType
}

func (q *Queries) CreateShopsEquipmentJunction(ctx context.Context, arg CreateShopsEquipmentJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createShopsEquipmentJunction,
		arg.DataHash,
		arg.ShopID,
		arg.ShopEquipmentID,
		arg.ShopType,
	)
	return err
}

const createShopsItemsJunction = `-- name: CreateShopsItemsJunction :exec
INSERT INTO j_shops_items (data_hash, shop_id, shop_item_id, shop_type)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateShopsItemsJunctionParams struct {
	DataHash   string
	ShopID     int32
	ShopItemID int32
	ShopType   ShopType
}

func (q *Queries) CreateShopsItemsJunction(ctx context.Context, arg CreateShopsItemsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createShopsItemsJunction,
		arg.DataHash,
		arg.ShopID,
		arg.ShopItemID,
		arg.ShopType,
	)
	return err
}

const createSubLocation = `-- name: CreateSubLocation :one
INSERT INTO sublocations (data_hash, location_id, name, specification)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = sublocations.data_hash
RETURNING id, data_hash, location_id, name, specification
`

type CreateSubLocationParams struct {
	DataHash      string
	LocationID    int32
	Name          string
	Specification sql.NullString
}

func (q *Queries) CreateSubLocation(ctx context.Context, arg CreateSubLocationParams) (Sublocation, error) {
	row := q.db.QueryRowContext(ctx, createSubLocation,
		arg.DataHash,
		arg.LocationID,
		arg.Name,
		arg.Specification,
	)
	var i Sublocation
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.LocationID,
		&i.Name,
		&i.Specification,
	)
	return i, err
}

const createTreasure = `-- name: CreateTreasure :one
INSERT INTO treasures (data_hash, area_id, version, treasure_type, loot_type, is_post_airship, is_anima_treasure, notes, gil_amount)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = treasures.data_hash
RETURNING id, data_hash, area_id, version, treasure_type, loot_type, is_post_airship, is_anima_treasure, notes, gil_amount, found_equipment_id
`

type CreateTreasureParams struct {
	DataHash        string
	AreaID          int32
	Version         int32
	TreasureType    TreasureType
	LootType        LootType
	IsPostAirship   bool
	IsAnimaTreasure bool
	Notes           sql.NullString
	GilAmount       sql.NullInt32
}

func (q *Queries) CreateTreasure(ctx context.Context, arg CreateTreasureParams) (Treasure, error) {
	row := q.db.QueryRowContext(ctx, createTreasure,
		arg.DataHash,
		arg.AreaID,
		arg.Version,
		arg.TreasureType,
		arg.LootType,
		arg.IsPostAirship,
		arg.IsAnimaTreasure,
		arg.Notes,
		arg.GilAmount,
	)
	var i Treasure
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.AreaID,
		&i.Version,
		&i.TreasureType,
		&i.LootType,
		&i.IsPostAirship,
		&i.IsAnimaTreasure,
		&i.Notes,
		&i.GilAmount,
		&i.FoundEquipmentID,
	)
	return i, err
}

const createTreasuresItemsJunction = `-- name: CreateTreasuresItemsJunction :exec
INSERT INTO j_treasures_items (data_hash, treasure_id, item_amount_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateTreasuresItemsJunctionParams struct {
	DataHash     string
	TreasureID   int32
	ItemAmountID int32
}

func (q *Queries) CreateTreasuresItemsJunction(ctx context.Context, arg CreateTreasuresItemsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createTreasuresItemsJunction, arg.DataHash, arg.TreasureID, arg.ItemAmountID)
	return err
}

const getArea = `-- name: GetArea :one
SELECT
    l.id AS location_id,
    l.name AS location,
    s.name AS sublocation,
    a.id, a.data_hash, a.sublocation_id, a.name, a.version, a.specification, a.story_only, a.has_save_sphere, a.airship_drop_off, a.has_compilation_sphere, a.can_ride_chocobo FROM areas a
LEFT JOIN sublocations s ON a.sublocation_id = s.id 
LEFT JOIN locations l ON s.location_id = l.id
WHERE a.id = $1
`

type GetAreaRow struct {
	LocationID           sql.NullInt32
	Location             sql.NullString
	Sublocation          sql.NullString
	ID                   int32
	DataHash             string
	SublocationID        int32
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	StoryOnly            bool
	HasSaveSphere        bool
	AirshipDropOff       bool
	HasCompilationSphere bool
	CanRideChocobo       bool
}

func (q *Queries) GetArea(ctx context.Context, id int32) (GetAreaRow, error) {
	row := q.db.QueryRowContext(ctx, getArea, id)
	var i GetAreaRow
	err := row.Scan(
		&i.LocationID,
		&i.Location,
		&i.Sublocation,
		&i.ID,
		&i.DataHash,
		&i.SublocationID,
		&i.Name,
		&i.Version,
		&i.Specification,
		&i.StoryOnly,
		&i.HasSaveSphere,
		&i.AirshipDropOff,
		&i.HasCompilationSphere,
		&i.CanRideChocobo,
	)
	return i, err
}

const getAreaBackgroundMusic = `-- name: GetAreaBackgroundMusic :many
SELECT
    so.id, so.data_hash, so.name, so.streaming_name, so.in_game_name, so.ost_name, so.translation, so.streaming_track_number, so.music_sphere_id, so.ost_disc, so.ost_track_number, so.duration_in_seconds, so.can_loop, so.special_use_case, so.credits_id,
    l.name AS location,
    s.name As sublocation,
    a.name AS area,
    a.version AS area_version
FROM background_music bm
LEFT JOIN j_songs_background_music j ON j.bm_id = bm.id
LEFT JOIN songs so ON j.song_id = so.id
LEFT JOIN areas a ON j.area_id = a.id
LEFT JOIN sublocations s ON a.sublocation_id = s.id
LEFT JOIN locations l ON s.location_id = l.id
WHERE j.area_id = $1
ORDER BY so.id
`

type GetAreaBackgroundMusicRow struct {
	ID                   sql.NullInt32
	DataHash             sql.NullString
	Name                 sql.NullString
	StreamingName        sql.NullString
	InGameName           sql.NullString
	OstName              sql.NullString
	Translation          sql.NullString
	StreamingTrackNumber sql.NullInt32
	MusicSphereID        sql.NullInt32
	OstDisc              interface{}
	OstTrackNumber       sql.NullInt32
	DurationInSeconds    sql.NullInt32
	CanLoop              sql.NullBool
	SpecialUseCase       NullMusicUseCase
	CreditsID            sql.NullInt32
	Location             sql.NullString
	Sublocation          sql.NullString
	Area                 sql.NullString
	AreaVersion          sql.NullInt32
}

func (q *Queries) GetAreaBackgroundMusic(ctx context.Context, areaID int32) ([]GetAreaBackgroundMusicRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreaBackgroundMusic, areaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreaBackgroundMusicRow
	for rows.Next() {
		var i GetAreaBackgroundMusicRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Name,
			&i.StreamingName,
			&i.InGameName,
			&i.OstName,
			&i.Translation,
			&i.StreamingTrackNumber,
			&i.MusicSphereID,
			&i.OstDisc,
			&i.OstTrackNumber,
			&i.DurationInSeconds,
			&i.CanLoop,
			&i.SpecialUseCase,
			&i.CreditsID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaBossSongs = `-- name: GetAreaBossSongs :many
SELECT DISTINCT
    so.id, so.data_hash, so.name, so.streaming_name, so.in_game_name, so.ost_name, so.translation, so.streaming_track_number, so.music_sphere_id, so.ost_disc, so.ost_track_number, so.duration_in_seconds, so.can_loop, so.special_use_case, so.credits_id,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version AS area_version
FROM songs so
LEFT JOIN formation_boss_songs bs ON bs.song_id = so.id
LEFT JOIN monster_formations mf ON mf.boss_song_id = bs.id
LEFT JOIN j_encounter_location_formations j ON j.monster_formation_id = mf.id
LEFT JOIN encounter_locations el ON j.encounter_location_id = el.id
LEFT JOIN areas a ON el.area_id = a.id
LEFT JOIN sublocations s ON a.sublocation_id = s.id
LEFT JOIN locations l ON s.location_id = l.id
WHERE area_id = $1
ORDER BY so.id
`

type GetAreaBossSongsRow struct {
	ID                   int32
	DataHash             string
	Name                 string
	StreamingName        sql.NullString
	InGameName           sql.NullString
	OstName              sql.NullString
	Translation          sql.NullString
	StreamingTrackNumber sql.NullInt32
	MusicSphereID        sql.NullInt32
	OstDisc              interface{}
	OstTrackNumber       sql.NullInt32
	DurationInSeconds    int32
	CanLoop              bool
	SpecialUseCase       NullMusicUseCase
	CreditsID            sql.NullInt32
	Location             sql.NullString
	Sublocation          sql.NullString
	Area                 sql.NullString
	AreaVersion          sql.NullInt32
}

func (q *Queries) GetAreaBossSongs(ctx context.Context, areaID int32) ([]GetAreaBossSongsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreaBossSongs, areaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreaBossSongsRow
	for rows.Next() {
		var i GetAreaBossSongsRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Name,
			&i.StreamingName,
			&i.InGameName,
			&i.OstName,
			&i.Translation,
			&i.StreamingTrackNumber,
			&i.MusicSphereID,
			&i.OstDisc,
			&i.OstTrackNumber,
			&i.DurationInSeconds,
			&i.CanLoop,
			&i.SpecialUseCase,
			&i.CreditsID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaConnections = `-- name: GetAreaConnections :many
SELECT
    ac.id, ac.data_hash, ac.area_id, ac.connection_type, ac.story_only, ac.notes,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version AS version,
    a.specification AS specification
FROM area_connections ac
LEFT JOIN j_area_connected_areas j ON j.connection_id = ac.id
LEFT JOIN areas a ON ac.area_id = a.id
LEFT JOIN sublocations s ON a.sublocation_id = s.id
LEFT JOIN locations l ON s.location_id = l.id
WHERE j.area_id = $1
ORDER BY ac.id
`

type GetAreaConnectionsRow struct {
	ID             int32
	DataHash       string
	AreaID         int32
	ConnectionType AreaConnectionType
	StoryOnly      bool
	Notes          sql.NullString
	Location       sql.NullString
	Sublocation    sql.NullString
	Area           sql.NullString
	Version        sql.NullInt32
	Specification  sql.NullString
}

func (q *Queries) GetAreaConnections(ctx context.Context, areaID int32) ([]GetAreaConnectionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreaConnections, areaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreaConnectionsRow
	for rows.Next() {
		var i GetAreaConnectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.AreaID,
			&i.ConnectionType,
			&i.StoryOnly,
			&i.Notes,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.Version,
			&i.Specification,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaCount = `-- name: GetAreaCount :one
SELECT COUNT(id) FROM areas
`

func (q *Queries) GetAreaCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getAreaCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAreaCues = `-- name: GetAreaCues :many
SELECT DISTINCT
    so.id, so.data_hash, so.name, so.streaming_name, so.in_game_name, so.ost_name, so.translation, so.streaming_track_number, so.music_sphere_id, so.ost_disc, so.ost_track_number, so.duration_in_seconds, so.can_loop, so.special_use_case, so.credits_id,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version AS area_version
FROM cues c
LEFT JOIN songs so ON c.song_id = so.id
LEFT JOIN j_songs_cues j ON j.cue_id = c.id
LEFT JOIN areas a ON COALESCE(c.trigger_area_id, j.included_area_id) = a.id
LEFT JOIN sublocations s ON a.sublocation_id = s.id
LEFT JOIN locations l ON s.location_id = l.id
WHERE j.included_area_id = $1 OR c.trigger_area_id = $1
ORDER BY so.id
`

type GetAreaCuesRow struct {
	ID                   sql.NullInt32
	DataHash             sql.NullString
	Name                 sql.NullString
	StreamingName        sql.NullString
	InGameName           sql.NullString
	OstName              sql.NullString
	Translation          sql.NullString
	StreamingTrackNumber sql.NullInt32
	MusicSphereID        sql.NullInt32
	OstDisc              interface{}
	OstTrackNumber       sql.NullInt32
	DurationInSeconds    sql.NullInt32
	CanLoop              sql.NullBool
	SpecialUseCase       NullMusicUseCase
	CreditsID            sql.NullInt32
	Location             sql.NullString
	Sublocation          sql.NullString
	Area                 sql.NullString
	AreaVersion          sql.NullInt32
}

func (q *Queries) GetAreaCues(ctx context.Context, includedAreaID int32) ([]GetAreaCuesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreaCues, includedAreaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreaCuesRow
	for rows.Next() {
		var i GetAreaCuesRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Name,
			&i.StreamingName,
			&i.InGameName,
			&i.OstName,
			&i.Translation,
			&i.StreamingTrackNumber,
			&i.MusicSphereID,
			&i.OstDisc,
			&i.OstTrackNumber,
			&i.DurationInSeconds,
			&i.CanLoop,
			&i.SpecialUseCase,
			&i.CreditsID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaFMVSongs = `-- name: GetAreaFMVSongs :many
SELECT DISTINCT
    so.id, so.data_hash, so.name, so.streaming_name, so.in_game_name, so.ost_name, so.translation, so.streaming_track_number, so.music_sphere_id, so.ost_disc, so.ost_track_number, so.duration_in_seconds, so.can_loop, so.special_use_case, so.credits_id,
    l.name AS location,
    s.name As sublocation,
    a.name AS area,
    a.version AS area_version
FROM songs so
LEFT JOIN fmvs f ON f.song_id = so.id
LEFT JOIN areas a ON f.area_id = a.id
LEFT JOIN sublocations s ON a.sublocation_id = s.id
LEFT JOIN locations l ON s.location_id = l.id
WHERE f.area_id = $1
ORDER BY so.id
`

type GetAreaFMVSongsRow struct {
	ID                   int32
	DataHash             string
	Name                 string
	StreamingName        sql.NullString
	InGameName           sql.NullString
	OstName              sql.NullString
	Translation          sql.NullString
	StreamingTrackNumber sql.NullInt32
	MusicSphereID        sql.NullInt32
	OstDisc              interface{}
	OstTrackNumber       sql.NullInt32
	DurationInSeconds    int32
	CanLoop              bool
	SpecialUseCase       NullMusicUseCase
	CreditsID            sql.NullInt32
	Location             sql.NullString
	Sublocation          sql.NullString
	Area                 sql.NullString
	AreaVersion          sql.NullInt32
}

func (q *Queries) GetAreaFMVSongs(ctx context.Context, areaID int32) ([]GetAreaFMVSongsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreaFMVSongs, areaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreaFMVSongsRow
	for rows.Next() {
		var i GetAreaFMVSongsRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Name,
			&i.StreamingName,
			&i.InGameName,
			&i.OstName,
			&i.Translation,
			&i.StreamingTrackNumber,
			&i.MusicSphereID,
			&i.OstDisc,
			&i.OstTrackNumber,
			&i.DurationInSeconds,
			&i.CanLoop,
			&i.SpecialUseCase,
			&i.CreditsID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaFMVs = `-- name: GetAreaFMVs :many
SELECT
    f.id, f.data_hash, f.name, f.translation, f.cutscene_description, f.song_id, f.area_id,
    l.name AS location,
    s.name As sublocation,
    a.name AS area,
    a.version AS area_version
FROM fmvs f
LEFT JOIN areas a ON f.area_id = a.id
LEFT JOIN sublocations s ON a.sublocation_id = s.id
LEFT JOIN locations l ON s.location_id = l.id
WHERE f.area_id = $1
ORDER BY f.id
`

type GetAreaFMVsRow struct {
	ID                  int32
	DataHash            string
	Name                string
	Translation         sql.NullString
	CutsceneDescription string
	SongID              sql.NullInt32
	AreaID              int32
	Location            sql.NullString
	Sublocation         sql.NullString
	Area                sql.NullString
	AreaVersion         sql.NullInt32
}

func (q *Queries) GetAreaFMVs(ctx context.Context, areaID int32) ([]GetAreaFMVsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreaFMVs, areaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreaFMVsRow
	for rows.Next() {
		var i GetAreaFMVsRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Name,
			&i.Translation,
			&i.CutsceneDescription,
			&i.SongID,
			&i.AreaID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaMonsterFormations = `-- name: GetAreaMonsterFormations :many
SELECT DISTINCT
    mf.id, mf.data_hash, mf.category, mf.is_forced_ambush, mf.can_escape, mf.boss_song_id, mf.notes,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version AS area_version
FROM monster_formations mf
LEFT JOIN j_encounter_location_formations j ON j.monster_formation_id = mf.id
LEFT JOIN encounter_locations el ON j.encounter_location_id = el.id
LEFT JOIN areas a ON el.area_id = a.id
LEFT JOIN sublocations s ON a.sublocation_id = s.id
LEFT JOIN locations l ON s.location_id = l.id
WHERE area_id = $1
ORDER BY mf.id
`

type GetAreaMonsterFormationsRow struct {
	ID             int32
	DataHash       string
	Category       MonsterFormationCategory
	IsForcedAmbush bool
	CanEscape      bool
	BossSongID     sql.NullInt32
	Notes          sql.NullString
	Location       sql.NullString
	Sublocation    sql.NullString
	Area           sql.NullString
	AreaVersion    sql.NullInt32
}

func (q *Queries) GetAreaMonsterFormations(ctx context.Context, areaID int32) ([]GetAreaMonsterFormationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreaMonsterFormations, areaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreaMonsterFormationsRow
	for rows.Next() {
		var i GetAreaMonsterFormationsRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Category,
			&i.IsForcedAmbush,
			&i.CanEscape,
			&i.BossSongID,
			&i.Notes,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaMonsters = `-- name: GetAreaMonsters :many
SELECT DISTINCT
    m.id, m.data_hash, m.name, m.version, m.specification, m.notes, m.species, m.is_story_based, m.is_repeatable, m.can_be_captured, m.area_conquest_location, m.ctb_icon_type, m.has_overdrive, m.is_underwater, m.is_zombie, m.distance, m.ap, m.ap_overkill, m.overkill_damage, m.gil, m.steal_gil, m.doom_countdown, m.poison_rate, m.threaten_chance, m.zanmato_level, m.monster_arena_price, m.sensor_text, m.scan_text,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version AS area_version
FROM monsters m
LEFT JOIN monster_amounts ma ON ma.monster_id = m.id
LEFT JOIN j_monster_formations_monsters j1 ON j1.monster_amount_id = ma.id
LEFT JOIN monster_formations mf ON j1.monster_formation_id = mf.id
LEFT JOIN j_encounter_location_formations j2 ON j2.monster_formation_id = mf.id
LEFT JOIN encounter_locations el ON j2.encounter_location_id = el.id
LEFT JOIN areas a ON el.area_id = a.id
LEFT JOIN sublocations s ON a.sublocation_id = s.id
LEFT JOIN locations l ON s.location_id = l.id
WHERE area_id = $1
ORDER BY m.id
`

type GetAreaMonstersRow struct {
	ID                   int32
	DataHash             string
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	Notes                sql.NullString
	Species              MonsterSpecies
	IsStoryBased         bool
	IsRepeatable         bool
	CanBeCaptured        bool
	AreaConquestLocation NullMaCreationArea
	CtbIconType          CtbIconType
	HasOverdrive         bool
	IsUnderwater         bool
	IsZombie             bool
	Distance             interface{}
	Ap                   int32
	ApOverkill           int32
	OverkillDamage       int32
	Gil                  int32
	StealGil             sql.NullInt32
	DoomCountdown        interface{}
	PoisonRate           interface{}
	ThreatenChance       interface{}
	ZanmatoLevel         interface{}
	MonsterArenaPrice    sql.NullInt32
	SensorText           sql.NullString
	ScanText             sql.NullString
	Location             sql.NullString
	Sublocation          sql.NullString
	Area                 sql.NullString
	AreaVersion          sql.NullInt32
}

func (q *Queries) GetAreaMonsters(ctx context.Context, areaID int32) ([]GetAreaMonstersRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreaMonsters, areaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreaMonstersRow
	for rows.Next() {
		var i GetAreaMonstersRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Name,
			&i.Version,
			&i.Specification,
			&i.Notes,
			&i.Species,
			&i.IsStoryBased,
			&i.IsRepeatable,
			&i.CanBeCaptured,
			&i.AreaConquestLocation,
			&i.CtbIconType,
			&i.HasOverdrive,
			&i.IsUnderwater,
			&i.IsZombie,
			&i.Distance,
			&i.Ap,
			&i.ApOverkill,
			&i.OverkillDamage,
			&i.Gil,
			&i.StealGil,
			&i.DoomCountdown,
			&i.PoisonRate,
			&i.ThreatenChance,
			&i.ZanmatoLevel,
			&i.MonsterArenaPrice,
			&i.SensorText,
			&i.ScanText,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaShops = `-- name: GetAreaShops :many
SELECT id, data_hash, version, area_id, notes, category FROM shops WHERE area_id = $1 ORDER BY id
`

func (q *Queries) GetAreaShops(ctx context.Context, areaID int32) ([]Shop, error) {
	rows, err := q.db.QueryContext(ctx, getAreaShops, areaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shop
	for rows.Next() {
		var i Shop
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Version,
			&i.AreaID,
			&i.Notes,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaTreasures = `-- name: GetAreaTreasures :many
SELECT id, data_hash, area_id, version, treasure_type, loot_type, is_post_airship, is_anima_treasure, notes, gil_amount, found_equipment_id FROM treasures WHERE area_id = $1 ORDER BY id
`

func (q *Queries) GetAreaTreasures(ctx context.Context, areaID int32) ([]Treasure, error) {
	rows, err := q.db.QueryContext(ctx, getAreaTreasures, areaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Treasure
	for rows.Next() {
		var i Treasure
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.AreaID,
			&i.Version,
			&i.TreasureType,
			&i.LootType,
			&i.IsPostAirship,
			&i.IsAnimaTreasure,
			&i.Notes,
			&i.GilAmount,
			&i.FoundEquipmentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreas = `-- name: GetAreas :many
SELECT
    l.id AS location_id,
    l.name AS location,
    s.id AS sublocation_id,
    s.name AS sublocation,
    a.id, a.data_hash, a.sublocation_id, a.name, a.version, a.specification, a.story_only, a.has_save_sphere, a.airship_drop_off, a.has_compilation_sphere, a.can_ride_chocobo FROM areas a
LEFT JOIN sublocations s ON a.sublocation_id = s.id 
LEFT JOIN locations l ON s.location_id = l.id
`

type GetAreasRow struct {
	LocationID           sql.NullInt32
	Location             sql.NullString
	SublocationID        sql.NullInt32
	Sublocation          sql.NullString
	ID                   int32
	DataHash             string
	SublocationID_2      int32
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	StoryOnly            bool
	HasSaveSphere        bool
	AirshipDropOff       bool
	HasCompilationSphere bool
	CanRideChocobo       bool
}

func (q *Queries) GetAreas(ctx context.Context) ([]GetAreasRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreasRow
	for rows.Next() {
		var i GetAreasRow
		if err := rows.Scan(
			&i.LocationID,
			&i.Location,
			&i.SublocationID,
			&i.Sublocation,
			&i.ID,
			&i.DataHash,
			&i.SublocationID_2,
			&i.Name,
			&i.Version,
			&i.Specification,
			&i.StoryOnly,
			&i.HasSaveSphere,
			&i.AirshipDropOff,
			&i.HasCompilationSphere,
			&i.CanRideChocobo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocationAreaByAreaName = `-- name: GetLocationAreaByAreaName :one
SELECT l.name, s.name, a.name, a.version FROM locations l LEFT JOIN sublocations s ON s.location_id = l.id LEFT JOIN areas a ON a.sublocation_id = a.id
WHERE l.id = $1 AND s.id = $2 AND a.name = $3 AND a.version = $4
`

type GetLocationAreaByAreaNameParams struct {
	ID      int32
	ID_2    int32
	Name    string
	Version sql.NullInt32
}

type GetLocationAreaByAreaNameRow struct {
	Name    string
	Name_2  sql.NullString
	Name_3  sql.NullString
	Version sql.NullInt32
}

func (q *Queries) GetLocationAreaByAreaName(ctx context.Context, arg GetLocationAreaByAreaNameParams) (GetLocationAreaByAreaNameRow, error) {
	row := q.db.QueryRowContext(ctx, getLocationAreaByAreaName,
		arg.ID,
		arg.ID_2,
		arg.Name,
		arg.Version,
	)
	var i GetLocationAreaByAreaNameRow
	err := row.Scan(
		&i.Name,
		&i.Name_2,
		&i.Name_3,
		&i.Version,
	)
	return i, err
}

const getLocationMonsterFormations = `-- name: GetLocationMonsterFormations :many
SELECT DISTINCT
    mf.id, mf.data_hash, mf.category, mf.is_forced_ambush, mf.can_escape, mf.boss_song_id, mf.notes,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version AS area_version
FROM monster_formations mf
LEFT JOIN j_encounter_location_formations j ON j.monster_formation_id = mf.id
LEFT JOIN encounter_locations el ON j.encounter_location_id = el.id
LEFT JOIN areas a ON el.area_id = a.id
LEFT JOIN sublocations s ON a.sublocation_id = s.id
LEFT JOIN locations l ON s.location_id = l.id
WHERE location_id = $1
ORDER BY mf.id
`

type GetLocationMonsterFormationsRow struct {
	ID             int32
	DataHash       string
	Category       MonsterFormationCategory
	IsForcedAmbush bool
	CanEscape      bool
	BossSongID     sql.NullInt32
	Notes          sql.NullString
	Location       sql.NullString
	Sublocation    sql.NullString
	Area           sql.NullString
	AreaVersion    sql.NullInt32
}

func (q *Queries) GetLocationMonsterFormations(ctx context.Context, locationID int32) ([]GetLocationMonsterFormationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLocationMonsterFormations, locationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLocationMonsterFormationsRow
	for rows.Next() {
		var i GetLocationMonsterFormationsRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Category,
			&i.IsForcedAmbush,
			&i.CanEscape,
			&i.BossSongID,
			&i.Notes,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocationMonsters = `-- name: GetLocationMonsters :many
SELECT DISTINCT
    m.id, m.data_hash, m.name, m.version, m.specification, m.notes, m.species, m.is_story_based, m.is_repeatable, m.can_be_captured, m.area_conquest_location, m.ctb_icon_type, m.has_overdrive, m.is_underwater, m.is_zombie, m.distance, m.ap, m.ap_overkill, m.overkill_damage, m.gil, m.steal_gil, m.doom_countdown, m.poison_rate, m.threaten_chance, m.zanmato_level, m.monster_arena_price, m.sensor_text, m.scan_text,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version AS area_version
FROM monsters m
LEFT JOIN monster_amounts ma ON ma.monster_id = m.id
LEFT JOIN j_monster_formations_monsters j1 ON j1.monster_amount_id = ma.id
LEFT JOIN monster_formations mf ON j1.monster_formation_id = mf.id
LEFT JOIN j_encounter_location_formations j2 ON j2.monster_formation_id = mf.id
LEFT JOIN encounter_locations el ON j2.encounter_location_id = el.id
LEFT JOIN areas a ON el.area_id = a.id
LEFT JOIN sublocations s ON a.sublocation_id = s.id
LEFT JOIN locations l ON s.location_id = l.id
WHERE location_id = $1
ORDER BY m.id
`

type GetLocationMonstersRow struct {
	ID                   int32
	DataHash             string
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	Notes                sql.NullString
	Species              MonsterSpecies
	IsStoryBased         bool
	IsRepeatable         bool
	CanBeCaptured        bool
	AreaConquestLocation NullMaCreationArea
	CtbIconType          CtbIconType
	HasOverdrive         bool
	IsUnderwater         bool
	IsZombie             bool
	Distance             interface{}
	Ap                   int32
	ApOverkill           int32
	OverkillDamage       int32
	Gil                  int32
	StealGil             sql.NullInt32
	DoomCountdown        interface{}
	PoisonRate           interface{}
	ThreatenChance       interface{}
	ZanmatoLevel         interface{}
	MonsterArenaPrice    sql.NullInt32
	SensorText           sql.NullString
	ScanText             sql.NullString
	Location             sql.NullString
	Sublocation          sql.NullString
	Area                 sql.NullString
	AreaVersion          sql.NullInt32
}

func (q *Queries) GetLocationMonsters(ctx context.Context, locationID int32) ([]GetLocationMonstersRow, error) {
	rows, err := q.db.QueryContext(ctx, getLocationMonsters, locationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLocationMonstersRow
	for rows.Next() {
		var i GetLocationMonstersRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Name,
			&i.Version,
			&i.Specification,
			&i.Notes,
			&i.Species,
			&i.IsStoryBased,
			&i.IsRepeatable,
			&i.CanBeCaptured,
			&i.AreaConquestLocation,
			&i.CtbIconType,
			&i.HasOverdrive,
			&i.IsUnderwater,
			&i.IsZombie,
			&i.Distance,
			&i.Ap,
			&i.ApOverkill,
			&i.OverkillDamage,
			&i.Gil,
			&i.StealGil,
			&i.DoomCountdown,
			&i.PoisonRate,
			&i.ThreatenChance,
			&i.ZanmatoLevel,
			&i.MonsterArenaPrice,
			&i.SensorText,
			&i.ScanText,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocationShops = `-- name: GetLocationShops :many
SELECT
    sh.id, sh.data_hash, sh.version, sh.area_id, sh.notes, sh.category,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version AS area_version
FROM shops sh
LEFT JOIN areas a ON sh.area_id = a.id
LEFT JOIN sublocations s ON a.sublocation_id = s.id
LEFT JOIN locations l ON s.location_id = l.id
WHERE s.location_id = $1
ORDER BY sh.id
`

type GetLocationShopsRow struct {
	ID          int32
	DataHash    string
	Version     sql.NullInt32
	AreaID      int32
	Notes       sql.NullString
	Category    ShopCategory
	Location    sql.NullString
	Sublocation sql.NullString
	Area        sql.NullString
	AreaVersion sql.NullInt32
}

func (q *Queries) GetLocationShops(ctx context.Context, locationID int32) ([]GetLocationShopsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLocationShops, locationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLocationShopsRow
	for rows.Next() {
		var i GetLocationShopsRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Version,
			&i.AreaID,
			&i.Notes,
			&i.Category,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocationTreasures = `-- name: GetLocationTreasures :many
SELECT
    t.id, t.data_hash, t.area_id, t.version, t.treasure_type, t.loot_type, t.is_post_airship, t.is_anima_treasure, t.notes, t.gil_amount, t.found_equipment_id,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version AS area_version
FROM treasures t
LEFT JOIN areas a ON t.area_id = a.id
LEFT JOIN sublocations s ON a.sublocation_id = s.id
LEFT JOIN locations l ON s.location_id = l.id
WHERE s.location_id = $1
ORDER BY t.id
`

type GetLocationTreasuresRow struct {
	ID               int32
	DataHash         string
	AreaID           int32
	Version          int32
	TreasureType     TreasureType
	LootType         LootType
	IsPostAirship    bool
	IsAnimaTreasure  bool
	Notes            sql.NullString
	GilAmount        sql.NullInt32
	FoundEquipmentID sql.NullInt32
	Location         sql.NullString
	Sublocation      sql.NullString
	Area             sql.NullString
	AreaVersion      sql.NullInt32
}

func (q *Queries) GetLocationTreasures(ctx context.Context, locationID int32) ([]GetLocationTreasuresRow, error) {
	rows, err := q.db.QueryContext(ctx, getLocationTreasures, locationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLocationTreasuresRow
	for rows.Next() {
		var i GetLocationTreasuresRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.AreaID,
			&i.Version,
			&i.TreasureType,
			&i.LootType,
			&i.IsPostAirship,
			&i.IsAnimaTreasure,
			&i.Notes,
			&i.GilAmount,
			&i.FoundEquipmentID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSublocationMonsterFormations = `-- name: GetSublocationMonsterFormations :many
SELECT DISTINCT
    mf.id, mf.data_hash, mf.category, mf.is_forced_ambush, mf.can_escape, mf.boss_song_id, mf.notes,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version AS area_version
FROM monster_formations mf
LEFT JOIN j_encounter_location_formations j ON j.monster_formation_id = mf.id
LEFT JOIN encounter_locations el ON j.encounter_location_id = el.id
LEFT JOIN areas a ON el.area_id = a.id
LEFT JOIN sublocations s ON a.sublocation_id = s.id
LEFT JOIN locations l ON s.location_id = l.id
WHERE sublocation_id = $1
ORDER BY mf.id
`

type GetSublocationMonsterFormationsRow struct {
	ID             int32
	DataHash       string
	Category       MonsterFormationCategory
	IsForcedAmbush bool
	CanEscape      bool
	BossSongID     sql.NullInt32
	Notes          sql.NullString
	Location       sql.NullString
	Sublocation    sql.NullString
	Area           sql.NullString
	AreaVersion    sql.NullInt32
}

func (q *Queries) GetSublocationMonsterFormations(ctx context.Context, sublocationID int32) ([]GetSublocationMonsterFormationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSublocationMonsterFormations, sublocationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSublocationMonsterFormationsRow
	for rows.Next() {
		var i GetSublocationMonsterFormationsRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Category,
			&i.IsForcedAmbush,
			&i.CanEscape,
			&i.BossSongID,
			&i.Notes,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSublocationMonsters = `-- name: GetSublocationMonsters :many
SELECT DISTINCT
    m.id, m.data_hash, m.name, m.version, m.specification, m.notes, m.species, m.is_story_based, m.is_repeatable, m.can_be_captured, m.area_conquest_location, m.ctb_icon_type, m.has_overdrive, m.is_underwater, m.is_zombie, m.distance, m.ap, m.ap_overkill, m.overkill_damage, m.gil, m.steal_gil, m.doom_countdown, m.poison_rate, m.threaten_chance, m.zanmato_level, m.monster_arena_price, m.sensor_text, m.scan_text,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version AS area_version
FROM monsters m
LEFT JOIN monster_amounts ma ON ma.monster_id = m.id
LEFT JOIN j_monster_formations_monsters j1 ON j1.monster_amount_id = ma.id
LEFT JOIN monster_formations mf ON j1.monster_formation_id = mf.id
LEFT JOIN j_encounter_location_formations j2 ON j2.monster_formation_id = mf.id
LEFT JOIN encounter_locations el ON j2.encounter_location_id = el.id
LEFT JOIN areas a ON el.area_id = a.id
LEFT JOIN sublocations s ON a.sublocation_id = s.id
LEFT JOIN locations l ON s.location_id = l.id
WHERE sublocation_id = $1
ORDER BY m.id
`

type GetSublocationMonstersRow struct {
	ID                   int32
	DataHash             string
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	Notes                sql.NullString
	Species              MonsterSpecies
	IsStoryBased         bool
	IsRepeatable         bool
	CanBeCaptured        bool
	AreaConquestLocation NullMaCreationArea
	CtbIconType          CtbIconType
	HasOverdrive         bool
	IsUnderwater         bool
	IsZombie             bool
	Distance             interface{}
	Ap                   int32
	ApOverkill           int32
	OverkillDamage       int32
	Gil                  int32
	StealGil             sql.NullInt32
	DoomCountdown        interface{}
	PoisonRate           interface{}
	ThreatenChance       interface{}
	ZanmatoLevel         interface{}
	MonsterArenaPrice    sql.NullInt32
	SensorText           sql.NullString
	ScanText             sql.NullString
	Location             sql.NullString
	Sublocation          sql.NullString
	Area                 sql.NullString
	AreaVersion          sql.NullInt32
}

func (q *Queries) GetSublocationMonsters(ctx context.Context, sublocationID int32) ([]GetSublocationMonstersRow, error) {
	rows, err := q.db.QueryContext(ctx, getSublocationMonsters, sublocationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSublocationMonstersRow
	for rows.Next() {
		var i GetSublocationMonstersRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Name,
			&i.Version,
			&i.Specification,
			&i.Notes,
			&i.Species,
			&i.IsStoryBased,
			&i.IsRepeatable,
			&i.CanBeCaptured,
			&i.AreaConquestLocation,
			&i.CtbIconType,
			&i.HasOverdrive,
			&i.IsUnderwater,
			&i.IsZombie,
			&i.Distance,
			&i.Ap,
			&i.ApOverkill,
			&i.OverkillDamage,
			&i.Gil,
			&i.StealGil,
			&i.DoomCountdown,
			&i.PoisonRate,
			&i.ThreatenChance,
			&i.ZanmatoLevel,
			&i.MonsterArenaPrice,
			&i.SensorText,
			&i.ScanText,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSublocationShops = `-- name: GetSublocationShops :many
SELECT
    sh.id, sh.data_hash, sh.version, sh.area_id, sh.notes, sh.category,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version area_version
FROM shops sh
LEFT JOIN areas a ON sh.area_id = a.id
LEFT JOIN sublocations s ON a.sublocation_id = s.id
LEFT JOIN locations l ON s.location_id = l.id
WHERE a.sublocation_id = $1
ORDER BY sh.id
`

type GetSublocationShopsRow struct {
	ID          int32
	DataHash    string
	Version     sql.NullInt32
	AreaID      int32
	Notes       sql.NullString
	Category    ShopCategory
	Location    sql.NullString
	Sublocation sql.NullString
	Area        sql.NullString
	AreaVersion sql.NullInt32
}

func (q *Queries) GetSublocationShops(ctx context.Context, sublocationID int32) ([]GetSublocationShopsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSublocationShops, sublocationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSublocationShopsRow
	for rows.Next() {
		var i GetSublocationShopsRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Version,
			&i.AreaID,
			&i.Notes,
			&i.Category,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSublocationTreasures = `-- name: GetSublocationTreasures :many
SELECT
    t.id, t.data_hash, t.area_id, t.version, t.treasure_type, t.loot_type, t.is_post_airship, t.is_anima_treasure, t.notes, t.gil_amount, t.found_equipment_id,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version AS area_version
FROM treasures t
LEFT JOIN areas a ON t.area_id = a.id
LEFT JOIN sublocations s ON a.sublocation_id = s.id
LEFT JOIN locations l ON s.location_id = l.id
WHERE a.sublocation_id = $1
ORDER BY t.id
`

type GetSublocationTreasuresRow struct {
	ID               int32
	DataHash         string
	AreaID           int32
	Version          int32
	TreasureType     TreasureType
	LootType         LootType
	IsPostAirship    bool
	IsAnimaTreasure  bool
	Notes            sql.NullString
	GilAmount        sql.NullInt32
	FoundEquipmentID sql.NullInt32
	Location         sql.NullString
	Sublocation      sql.NullString
	Area             sql.NullString
	AreaVersion      sql.NullInt32
}

func (q *Queries) GetSublocationTreasures(ctx context.Context, sublocationID int32) ([]GetSublocationTreasuresRow, error) {
	rows, err := q.db.QueryContext(ctx, getSublocationTreasures, sublocationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSublocationTreasuresRow
	for rows.Next() {
		var i GetSublocationTreasuresRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.AreaID,
			&i.Version,
			&i.TreasureType,
			&i.LootType,
			&i.IsPostAirship,
			&i.IsAnimaTreasure,
			&i.Notes,
			&i.GilAmount,
			&i.FoundEquipmentID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTreasure = `-- name: UpdateTreasure :exec
UPDATE treasures
SET data_hash = $1,
    found_equipment_id = $2
WHERE id = $3
`

type UpdateTreasureParams struct {
	DataHash         string
	FoundEquipmentID sql.NullInt32
	ID               int32
}

func (q *Queries) UpdateTreasure(ctx context.Context, arg UpdateTreasureParams) error {
	_, err := q.db.ExecContext(ctx, updateTreasure, arg.DataHash, arg.FoundEquipmentID, arg.ID)
	return err
}

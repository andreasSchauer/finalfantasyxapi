// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: locations.sql

package database

import (
	"context"
	"database/sql"
)

const createArea = `-- name: CreateArea :one
INSERT INTO areas (data_hash, sub_location_id, name, version, specification, story_only, has_save_sphere, airship_drop_off, has_compilation_sphere, can_ride_chocobo)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = areas.data_hash
RETURNING id, data_hash, sub_location_id, name, version, specification, story_only, has_save_sphere, airship_drop_off, has_compilation_sphere, can_ride_chocobo
`

type CreateAreaParams struct {
	DataHash             string
	SubLocationID        int32
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	StoryOnly            bool
	HasSaveSphere        bool
	AirshipDropOff       bool
	HasCompilationSphere bool
	CanRideChocobo       bool
}

func (q *Queries) CreateArea(ctx context.Context, arg CreateAreaParams) (Area, error) {
	row := q.db.QueryRowContext(ctx, createArea,
		arg.DataHash,
		arg.SubLocationID,
		arg.Name,
		arg.Version,
		arg.Specification,
		arg.StoryOnly,
		arg.HasSaveSphere,
		arg.AirshipDropOff,
		arg.HasCompilationSphere,
		arg.CanRideChocobo,
	)
	var i Area
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.SubLocationID,
		&i.Name,
		&i.Version,
		&i.Specification,
		&i.StoryOnly,
		&i.HasSaveSphere,
		&i.AirshipDropOff,
		&i.HasCompilationSphere,
		&i.CanRideChocobo,
	)
	return i, err
}

const createAreaConnection = `-- name: CreateAreaConnection :one
INSERT INTO area_connections (data_hash, area_id, connection_type, story_only, notes)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = area_connections.data_hash
RETURNING id, data_hash, area_id, connection_type, story_only, notes
`

type CreateAreaConnectionParams struct {
	DataHash       string
	AreaID         int32
	ConnectionType AreaConnectionType
	StoryOnly      bool
	Notes          sql.NullString
}

func (q *Queries) CreateAreaConnection(ctx context.Context, arg CreateAreaConnectionParams) (AreaConnection, error) {
	row := q.db.QueryRowContext(ctx, createAreaConnection,
		arg.DataHash,
		arg.AreaID,
		arg.ConnectionType,
		arg.StoryOnly,
		arg.Notes,
	)
	var i AreaConnection
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.AreaID,
		&i.ConnectionType,
		&i.StoryOnly,
		&i.Notes,
	)
	return i, err
}

const createAreaConnectionJunction = `-- name: CreateAreaConnectionJunction :exec
INSERT INTO j_area_connection (data_hash, area_id, connection_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAreaConnectionJunctionParams struct {
	DataHash     string
	AreaID       int32
	ConnectionID int32
}

func (q *Queries) CreateAreaConnectionJunction(ctx context.Context, arg CreateAreaConnectionJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAreaConnectionJunction, arg.DataHash, arg.AreaID, arg.ConnectionID)
	return err
}

const createFormationBossSong = `-- name: CreateFormationBossSong :one
INSERT INTO formation_boss_songs (data_hash, song_id, celebrate_victory)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = formation_boss_songs.data_hash
RETURNING id, data_hash, song_id, celebrate_victory
`

type CreateFormationBossSongParams struct {
	DataHash         string
	SongID           int32
	CelebrateVictory bool
}

func (q *Queries) CreateFormationBossSong(ctx context.Context, arg CreateFormationBossSongParams) (FormationBossSong, error) {
	row := q.db.QueryRowContext(ctx, createFormationBossSong, arg.DataHash, arg.SongID, arg.CelebrateVictory)
	var i FormationBossSong
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.SongID,
		&i.CelebrateVictory,
	)
	return i, err
}

const createFormationLocation = `-- name: CreateFormationLocation :one
INSERT INTO formation_locations (data_hash, version, area_id, notes)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = formation_locations.data_hash
RETURNING id, data_hash, version, area_id, notes
`

type CreateFormationLocationParams struct {
	DataHash string
	Version  sql.NullInt32
	AreaID   int32
	Notes    sql.NullString
}

func (q *Queries) CreateFormationLocation(ctx context.Context, arg CreateFormationLocationParams) (FormationLocation, error) {
	row := q.db.QueryRowContext(ctx, createFormationLocation,
		arg.DataHash,
		arg.Version,
		arg.AreaID,
		arg.Notes,
	)
	var i FormationLocation
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Version,
		&i.AreaID,
		&i.Notes,
	)
	return i, err
}

const createLocation = `-- name: CreateLocation :one
INSERT INTO locations (data_hash, name)
VALUES ($1, $2)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = locations.data_hash
RETURNING id, data_hash, name
`

type CreateLocationParams struct {
	DataHash string
	Name     string
}

func (q *Queries) CreateLocation(ctx context.Context, arg CreateLocationParams) (Location, error) {
	row := q.db.QueryRowContext(ctx, createLocation, arg.DataHash, arg.Name)
	var i Location
	err := row.Scan(&i.ID, &i.DataHash, &i.Name)
	return i, err
}

const createLocationMonsterFormationJunction = `-- name: CreateLocationMonsterFormationJunction :exec
INSERT INTO j_location_monster_formation (data_hash, formation_location_id, monster_formation_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateLocationMonsterFormationJunctionParams struct {
	DataHash            string
	FormationLocationID int32
	MonsterFormationID  int32
}

func (q *Queries) CreateLocationMonsterFormationJunction(ctx context.Context, arg CreateLocationMonsterFormationJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createLocationMonsterFormationJunction, arg.DataHash, arg.FormationLocationID, arg.MonsterFormationID)
	return err
}

const createMonsterFormation = `-- name: CreateMonsterFormation :one
INSERT INTO monster_formations (data_hash, formation_location_id, category, is_forced_ambush, can_escape, boss_song_id, notes)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monster_formations.data_hash
RETURNING id, data_hash, formation_location_id, category, is_forced_ambush, can_escape, boss_song_id, notes
`

type CreateMonsterFormationParams struct {
	DataHash            string
	FormationLocationID int32
	Category            MonsterFormationCategory
	IsForcedAmbush      bool
	CanEscape           bool
	BossSongID          sql.NullInt32
	Notes               sql.NullString
}

func (q *Queries) CreateMonsterFormation(ctx context.Context, arg CreateMonsterFormationParams) (MonsterFormation, error) {
	row := q.db.QueryRowContext(ctx, createMonsterFormation,
		arg.DataHash,
		arg.FormationLocationID,
		arg.Category,
		arg.IsForcedAmbush,
		arg.CanEscape,
		arg.BossSongID,
		arg.Notes,
	)
	var i MonsterFormation
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.FormationLocationID,
		&i.Category,
		&i.IsForcedAmbush,
		&i.CanEscape,
		&i.BossSongID,
		&i.Notes,
	)
	return i, err
}

const createMonsterFormationMonsterAmountJunction = `-- name: CreateMonsterFormationMonsterAmountJunction :exec
INSERT INTO j_monster_formation_monster_amount (data_hash, monster_formation_id, monster_amount_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterFormationMonsterAmountJunctionParams struct {
	DataHash           string
	MonsterFormationID int32
	MonsterAmountID    int32
}

func (q *Queries) CreateMonsterFormationMonsterAmountJunction(ctx context.Context, arg CreateMonsterFormationMonsterAmountJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterFormationMonsterAmountJunction, arg.DataHash, arg.MonsterFormationID, arg.MonsterAmountID)
	return err
}

const createMonsterFormationTriggerCommandJunction = `-- name: CreateMonsterFormationTriggerCommandJunction :exec
INSERT INTO j_monster_formation_trigger_command (data_hash, monster_formation_id, trigger_command_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterFormationTriggerCommandJunctionParams struct {
	DataHash           string
	MonsterFormationID int32
	TriggerCommandID   int32
}

func (q *Queries) CreateMonsterFormationTriggerCommandJunction(ctx context.Context, arg CreateMonsterFormationTriggerCommandJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterFormationTriggerCommandJunction, arg.DataHash, arg.MonsterFormationID, arg.TriggerCommandID)
	return err
}

const createShop = `-- name: CreateShop :exec
INSERT INTO shops (data_hash, version, area_id, notes, category)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateShopParams struct {
	DataHash string
	Version  sql.NullInt32
	AreaID   int32
	Notes    sql.NullString
	Category ShopCategory
}

func (q *Queries) CreateShop(ctx context.Context, arg CreateShopParams) error {
	_, err := q.db.ExecContext(ctx, createShop,
		arg.DataHash,
		arg.Version,
		arg.AreaID,
		arg.Notes,
		arg.Category,
	)
	return err
}

const createSubLocation = `-- name: CreateSubLocation :one
INSERT INTO sub_locations (data_hash, location_id, name, specification)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = sub_locations.data_hash
RETURNING id, data_hash, location_id, name, specification
`

type CreateSubLocationParams struct {
	DataHash      string
	LocationID    int32
	Name          string
	Specification sql.NullString
}

func (q *Queries) CreateSubLocation(ctx context.Context, arg CreateSubLocationParams) (SubLocation, error) {
	row := q.db.QueryRowContext(ctx, createSubLocation,
		arg.DataHash,
		arg.LocationID,
		arg.Name,
		arg.Specification,
	)
	var i SubLocation
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.LocationID,
		&i.Name,
		&i.Specification,
	)
	return i, err
}

const createTreasure = `-- name: CreateTreasure :exec
INSERT INTO treasures (data_hash, area_id, version, treasure_type, loot_type, is_post_airship, is_anima_treasure, notes, gil_amount)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateTreasureParams struct {
	DataHash        string
	AreaID          int32
	Version         int32
	TreasureType    TreasureType
	LootType        LootType
	IsPostAirship   bool
	IsAnimaTreasure bool
	Notes           sql.NullString
	GilAmount       sql.NullInt32
}

func (q *Queries) CreateTreasure(ctx context.Context, arg CreateTreasureParams) error {
	_, err := q.db.ExecContext(ctx, createTreasure,
		arg.DataHash,
		arg.AreaID,
		arg.Version,
		arg.TreasureType,
		arg.LootType,
		arg.IsPostAirship,
		arg.IsAnimaTreasure,
		arg.Notes,
		arg.GilAmount,
	)
	return err
}

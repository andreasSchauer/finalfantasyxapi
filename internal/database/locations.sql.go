// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: locations.sql

package database

import (
	"context"
	"database/sql"
)

const createArea = `-- name: CreateArea :one
INSERT INTO areas (data_hash, sublocation_id, name, version, specification, story_only, has_save_sphere, airship_drop_off, has_compilation_sphere, can_ride_chocobo)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = areas.data_hash
RETURNING id, data_hash, sublocation_id, name, version, specification, story_only, has_save_sphere, airship_drop_off, has_compilation_sphere, can_ride_chocobo
`

type CreateAreaParams struct {
	DataHash             string
	SublocationID        int32
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	StoryOnly            bool
	HasSaveSphere        bool
	AirshipDropOff       bool
	HasCompilationSphere bool
	CanRideChocobo       bool
}

func (q *Queries) CreateArea(ctx context.Context, arg CreateAreaParams) (Area, error) {
	row := q.db.QueryRowContext(ctx, createArea,
		arg.DataHash,
		arg.SublocationID,
		arg.Name,
		arg.Version,
		arg.Specification,
		arg.StoryOnly,
		arg.HasSaveSphere,
		arg.AirshipDropOff,
		arg.HasCompilationSphere,
		arg.CanRideChocobo,
	)
	var i Area
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.SublocationID,
		&i.Name,
		&i.Version,
		&i.Specification,
		&i.StoryOnly,
		&i.HasSaveSphere,
		&i.AirshipDropOff,
		&i.HasCompilationSphere,
		&i.CanRideChocobo,
	)
	return i, err
}

const createAreaConnectedAreasJunction = `-- name: CreateAreaConnectedAreasJunction :exec
INSERT INTO j_area_connected_areas (data_hash, area_id, connection_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateAreaConnectedAreasJunctionParams struct {
	DataHash     string
	AreaID       int32
	ConnectionID int32
}

func (q *Queries) CreateAreaConnectedAreasJunction(ctx context.Context, arg CreateAreaConnectedAreasJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createAreaConnectedAreasJunction, arg.DataHash, arg.AreaID, arg.ConnectionID)
	return err
}

const createAreaConnection = `-- name: CreateAreaConnection :one
INSERT INTO area_connections (data_hash, area_id, connection_type, story_only, notes)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = area_connections.data_hash
RETURNING id, data_hash, area_id, connection_type, story_only, notes
`

type CreateAreaConnectionParams struct {
	DataHash       string
	AreaID         int32
	ConnectionType AreaConnectionType
	StoryOnly      bool
	Notes          sql.NullString
}

func (q *Queries) CreateAreaConnection(ctx context.Context, arg CreateAreaConnectionParams) (AreaConnection, error) {
	row := q.db.QueryRowContext(ctx, createAreaConnection,
		arg.DataHash,
		arg.AreaID,
		arg.ConnectionType,
		arg.StoryOnly,
		arg.Notes,
	)
	var i AreaConnection
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.AreaID,
		&i.ConnectionType,
		&i.StoryOnly,
		&i.Notes,
	)
	return i, err
}

const createEncounterLocation = `-- name: CreateEncounterLocation :one
INSERT INTO encounter_locations (data_hash, version, area_id, notes)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = encounter_locations.data_hash
RETURNING id, data_hash, version, area_id, notes
`

type CreateEncounterLocationParams struct {
	DataHash string
	Version  sql.NullInt32
	AreaID   int32
	Notes    sql.NullString
}

func (q *Queries) CreateEncounterLocation(ctx context.Context, arg CreateEncounterLocationParams) (EncounterLocation, error) {
	row := q.db.QueryRowContext(ctx, createEncounterLocation,
		arg.DataHash,
		arg.Version,
		arg.AreaID,
		arg.Notes,
	)
	var i EncounterLocation
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Version,
		&i.AreaID,
		&i.Notes,
	)
	return i, err
}

const createEncounterLocationFormationsJunction = `-- name: CreateEncounterLocationFormationsJunction :exec
INSERT INTO j_encounter_location_formations (data_hash, encounter_location_id, monster_formation_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateEncounterLocationFormationsJunctionParams struct {
	DataHash            string
	EncounterLocationID int32
	MonsterFormationID  int32
}

func (q *Queries) CreateEncounterLocationFormationsJunction(ctx context.Context, arg CreateEncounterLocationFormationsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createEncounterLocationFormationsJunction, arg.DataHash, arg.EncounterLocationID, arg.MonsterFormationID)
	return err
}

const createFormationBossSong = `-- name: CreateFormationBossSong :one
INSERT INTO formation_boss_songs (data_hash, song_id, celebrate_victory)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = formation_boss_songs.data_hash
RETURNING id, data_hash, song_id, celebrate_victory
`

type CreateFormationBossSongParams struct {
	DataHash         string
	SongID           int32
	CelebrateVictory bool
}

func (q *Queries) CreateFormationBossSong(ctx context.Context, arg CreateFormationBossSongParams) (FormationBossSong, error) {
	row := q.db.QueryRowContext(ctx, createFormationBossSong, arg.DataHash, arg.SongID, arg.CelebrateVictory)
	var i FormationBossSong
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.SongID,
		&i.CelebrateVictory,
	)
	return i, err
}

const createFoundEquipmentAbilitiesJunction = `-- name: CreateFoundEquipmentAbilitiesJunction :exec
INSERT INTO j_found_equipment_abilities (data_hash, found_equipment_id, auto_ability_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateFoundEquipmentAbilitiesJunctionParams struct {
	DataHash         string
	FoundEquipmentID int32
	AutoAbilityID    int32
}

func (q *Queries) CreateFoundEquipmentAbilitiesJunction(ctx context.Context, arg CreateFoundEquipmentAbilitiesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createFoundEquipmentAbilitiesJunction, arg.DataHash, arg.FoundEquipmentID, arg.AutoAbilityID)
	return err
}

const createFoundEquipmentPiece = `-- name: CreateFoundEquipmentPiece :one
INSERT INTO found_equipment_pieces (data_hash, equipment_name_id, empty_slots_amount)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = found_equipment_pieces.data_hash
RETURNING id, data_hash, equipment_name_id, empty_slots_amount
`

type CreateFoundEquipmentPieceParams struct {
	DataHash         string
	EquipmentNameID  int32
	EmptySlotsAmount interface{}
}

func (q *Queries) CreateFoundEquipmentPiece(ctx context.Context, arg CreateFoundEquipmentPieceParams) (FoundEquipmentPiece, error) {
	row := q.db.QueryRowContext(ctx, createFoundEquipmentPiece, arg.DataHash, arg.EquipmentNameID, arg.EmptySlotsAmount)
	var i FoundEquipmentPiece
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.EquipmentNameID,
		&i.EmptySlotsAmount,
	)
	return i, err
}

const createLocation = `-- name: CreateLocation :one
INSERT INTO locations (data_hash, name)
VALUES ($1, $2)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = locations.data_hash
RETURNING id, data_hash, name
`

type CreateLocationParams struct {
	DataHash string
	Name     string
}

func (q *Queries) CreateLocation(ctx context.Context, arg CreateLocationParams) (Location, error) {
	row := q.db.QueryRowContext(ctx, createLocation, arg.DataHash, arg.Name)
	var i Location
	err := row.Scan(&i.ID, &i.DataHash, &i.Name)
	return i, err
}

const createMonsterFormation = `-- name: CreateMonsterFormation :one
INSERT INTO monster_formations (data_hash, category, is_forced_ambush, can_escape, boss_song_id, notes)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = monster_formations.data_hash
RETURNING id, data_hash, category, is_forced_ambush, can_escape, boss_song_id, notes
`

type CreateMonsterFormationParams struct {
	DataHash       string
	Category       MonsterFormationCategory
	IsForcedAmbush bool
	CanEscape      bool
	BossSongID     sql.NullInt32
	Notes          sql.NullString
}

func (q *Queries) CreateMonsterFormation(ctx context.Context, arg CreateMonsterFormationParams) (MonsterFormation, error) {
	row := q.db.QueryRowContext(ctx, createMonsterFormation,
		arg.DataHash,
		arg.Category,
		arg.IsForcedAmbush,
		arg.CanEscape,
		arg.BossSongID,
		arg.Notes,
	)
	var i MonsterFormation
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Category,
		&i.IsForcedAmbush,
		&i.CanEscape,
		&i.BossSongID,
		&i.Notes,
	)
	return i, err
}

const createMonsterFormationsMonstersJunction = `-- name: CreateMonsterFormationsMonstersJunction :exec
INSERT INTO j_monster_formations_monsters (data_hash, monster_formation_id, monster_amount_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterFormationsMonstersJunctionParams struct {
	DataHash           string
	MonsterFormationID int32
	MonsterAmountID    int32
}

func (q *Queries) CreateMonsterFormationsMonstersJunction(ctx context.Context, arg CreateMonsterFormationsMonstersJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterFormationsMonstersJunction, arg.DataHash, arg.MonsterFormationID, arg.MonsterAmountID)
	return err
}

const createMonsterFormationsTriggerCommandsJunction = `-- name: CreateMonsterFormationsTriggerCommandsJunction :exec
INSERT INTO j_monster_formations_trigger_commands (data_hash, monster_formation_id, trigger_command_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateMonsterFormationsTriggerCommandsJunctionParams struct {
	DataHash           string
	MonsterFormationID int32
	TriggerCommandID   int32
}

func (q *Queries) CreateMonsterFormationsTriggerCommandsJunction(ctx context.Context, arg CreateMonsterFormationsTriggerCommandsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createMonsterFormationsTriggerCommandsJunction, arg.DataHash, arg.MonsterFormationID, arg.TriggerCommandID)
	return err
}

const createShop = `-- name: CreateShop :one
INSERT INTO shops (data_hash, version, area_id, notes, category)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = shops.data_hash
RETURNING id, data_hash, version, area_id, notes, category
`

type CreateShopParams struct {
	DataHash string
	Version  sql.NullInt32
	AreaID   int32
	Notes    sql.NullString
	Category ShopCategory
}

func (q *Queries) CreateShop(ctx context.Context, arg CreateShopParams) (Shop, error) {
	row := q.db.QueryRowContext(ctx, createShop,
		arg.DataHash,
		arg.Version,
		arg.AreaID,
		arg.Notes,
		arg.Category,
	)
	var i Shop
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Version,
		&i.AreaID,
		&i.Notes,
		&i.Category,
	)
	return i, err
}

const createShopEquipmentPiece = `-- name: CreateShopEquipmentPiece :one
INSERT INTO shop_equipment_pieces (data_hash, found_equipment_id, price)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = shop_equipment_pieces.data_hash
RETURNING id, data_hash, found_equipment_id, price
`

type CreateShopEquipmentPieceParams struct {
	DataHash         string
	FoundEquipmentID int32
	Price            int32
}

func (q *Queries) CreateShopEquipmentPiece(ctx context.Context, arg CreateShopEquipmentPieceParams) (ShopEquipmentPiece, error) {
	row := q.db.QueryRowContext(ctx, createShopEquipmentPiece, arg.DataHash, arg.FoundEquipmentID, arg.Price)
	var i ShopEquipmentPiece
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.FoundEquipmentID,
		&i.Price,
	)
	return i, err
}

const createShopItem = `-- name: CreateShopItem :one
INSERT INTO shop_items (data_hash, item_id, price)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = shop_items.data_hash
RETURNING id, data_hash, item_id, price
`

type CreateShopItemParams struct {
	DataHash string
	ItemID   int32
	Price    int32
}

func (q *Queries) CreateShopItem(ctx context.Context, arg CreateShopItemParams) (ShopItem, error) {
	row := q.db.QueryRowContext(ctx, createShopItem, arg.DataHash, arg.ItemID, arg.Price)
	var i ShopItem
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.ItemID,
		&i.Price,
	)
	return i, err
}

const createShopsEquipmentJunction = `-- name: CreateShopsEquipmentJunction :exec
INSERT INTO j_shops_equipment (data_hash, shop_id, shop_equipment_id, shop_type)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateShopsEquipmentJunctionParams struct {
	DataHash        string
	ShopID          int32
	ShopEquipmentID int32
	ShopType        ShopType
}

func (q *Queries) CreateShopsEquipmentJunction(ctx context.Context, arg CreateShopsEquipmentJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createShopsEquipmentJunction,
		arg.DataHash,
		arg.ShopID,
		arg.ShopEquipmentID,
		arg.ShopType,
	)
	return err
}

const createShopsItemsJunction = `-- name: CreateShopsItemsJunction :exec
INSERT INTO j_shops_items (data_hash, shop_id, shop_item_id, shop_type)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateShopsItemsJunctionParams struct {
	DataHash   string
	ShopID     int32
	ShopItemID int32
	ShopType   ShopType
}

func (q *Queries) CreateShopsItemsJunction(ctx context.Context, arg CreateShopsItemsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createShopsItemsJunction,
		arg.DataHash,
		arg.ShopID,
		arg.ShopItemID,
		arg.ShopType,
	)
	return err
}

const createSubLocation = `-- name: CreateSubLocation :one
INSERT INTO sublocations (data_hash, location_id, name, specification)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = sublocations.data_hash
RETURNING id, data_hash, location_id, name, specification
`

type CreateSubLocationParams struct {
	DataHash      string
	LocationID    int32
	Name          string
	Specification sql.NullString
}

func (q *Queries) CreateSubLocation(ctx context.Context, arg CreateSubLocationParams) (Sublocation, error) {
	row := q.db.QueryRowContext(ctx, createSubLocation,
		arg.DataHash,
		arg.LocationID,
		arg.Name,
		arg.Specification,
	)
	var i Sublocation
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.LocationID,
		&i.Name,
		&i.Specification,
	)
	return i, err
}

const createTreasure = `-- name: CreateTreasure :one
INSERT INTO treasures (data_hash, area_id, version, treasure_type, loot_type, is_post_airship, is_anima_treasure, notes, gil_amount)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = treasures.data_hash
RETURNING id, data_hash, area_id, version, treasure_type, loot_type, is_post_airship, is_anima_treasure, notes, gil_amount, found_equipment_id
`

type CreateTreasureParams struct {
	DataHash        string
	AreaID          int32
	Version         int32
	TreasureType    TreasureType
	LootType        LootType
	IsPostAirship   bool
	IsAnimaTreasure bool
	Notes           sql.NullString
	GilAmount       sql.NullInt32
}

func (q *Queries) CreateTreasure(ctx context.Context, arg CreateTreasureParams) (Treasure, error) {
	row := q.db.QueryRowContext(ctx, createTreasure,
		arg.DataHash,
		arg.AreaID,
		arg.Version,
		arg.TreasureType,
		arg.LootType,
		arg.IsPostAirship,
		arg.IsAnimaTreasure,
		arg.Notes,
		arg.GilAmount,
	)
	var i Treasure
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.AreaID,
		&i.Version,
		&i.TreasureType,
		&i.LootType,
		&i.IsPostAirship,
		&i.IsAnimaTreasure,
		&i.Notes,
		&i.GilAmount,
		&i.FoundEquipmentID,
	)
	return i, err
}

const createTreasuresItemsJunction = `-- name: CreateTreasuresItemsJunction :exec
INSERT INTO j_treasures_items (data_hash, treasure_id, item_amount_id)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateTreasuresItemsJunctionParams struct {
	DataHash     string
	TreasureID   int32
	ItemAmountID int32
}

func (q *Queries) CreateTreasuresItemsJunction(ctx context.Context, arg CreateTreasuresItemsJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createTreasuresItemsJunction, arg.DataHash, arg.TreasureID, arg.ItemAmountID)
	return err
}

const getArea = `-- name: GetArea :one
SELECT
    l.id AS location_id,
    l.name AS location,
    s.name AS sublocation,
    a.id, a.data_hash, a.sublocation_id, a.name, a.version, a.specification, a.story_only, a.has_save_sphere, a.airship_drop_off, a.has_compilation_sphere, a.can_ride_chocobo
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id 
JOIN locations l ON s.location_id = l.id
WHERE a.id = $1
`

type GetAreaRow struct {
	LocationID           int32
	Location             string
	Sublocation          string
	ID                   int32
	DataHash             string
	SublocationID        int32
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	StoryOnly            bool
	HasSaveSphere        bool
	AirshipDropOff       bool
	HasCompilationSphere bool
	CanRideChocobo       bool
}

func (q *Queries) GetArea(ctx context.Context, id int32) (GetAreaRow, error) {
	row := q.db.QueryRowContext(ctx, getArea, id)
	var i GetAreaRow
	err := row.Scan(
		&i.LocationID,
		&i.Location,
		&i.Sublocation,
		&i.ID,
		&i.DataHash,
		&i.SublocationID,
		&i.Name,
		&i.Version,
		&i.Specification,
		&i.StoryOnly,
		&i.HasSaveSphere,
		&i.AirshipDropOff,
		&i.HasCompilationSphere,
		&i.CanRideChocobo,
	)
	return i, err
}

const getAreaAeons = `-- name: GetAreaAeons :many
SELECT
    ae.id, ae.data_hash, ae.unit_id, ae.unlock_condition, ae.is_optional, ae.battles_to_regenerate, ae.phys_atk_damage_constant, ae.phys_atk_range, ae.phys_atk_shatter_rate, ae.area_id, ae.accuracy_id,
    pu.name,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area, a.version AS area_version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN aeons ae ON ae.area_id = a.id
JOIN player_units pu ON ae.unit_id = pu.id
WHERE a.id = $1
ORDER BY ae.id
`

type GetAreaAeonsRow struct {
	ID                    int32
	DataHash              string
	UnitID                int32
	UnlockCondition       string
	IsOptional            bool
	BattlesToRegenerate   int32
	PhysAtkDamageConstant sql.NullInt32
	PhysAtkRange          interface{}
	PhysAtkShatterRate    interface{}
	AreaID                sql.NullInt32
	AccuracyID            sql.NullInt32
	Name                  string
	Location              string
	Sublocation           string
	Area                  string
	AreaVersion           sql.NullInt32
}

func (q *Queries) GetAreaAeons(ctx context.Context, id int32) ([]GetAreaAeonsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreaAeons, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreaAeonsRow
	for rows.Next() {
		var i GetAreaAeonsRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.UnitID,
			&i.UnlockCondition,
			&i.IsOptional,
			&i.BattlesToRegenerate,
			&i.PhysAtkDamageConstant,
			&i.PhysAtkRange,
			&i.PhysAtkShatterRate,
			&i.AreaID,
			&i.AccuracyID,
			&i.Name,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaBackgroundMusic = `-- name: GetAreaBackgroundMusic :many
SELECT
    so.id, so.data_hash, so.name, so.streaming_name, so.in_game_name, so.ost_name, so.translation, so.streaming_track_number, so.music_sphere_id, so.ost_disc, so.ost_track_number, so.duration_in_seconds, so.can_loop, so.special_use_case, so.credits_id,
    bm.replaces_encounter_music,
    l.name AS location,
    s.name As sublocation,
    a.name AS area,
    a.version AS area_version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN j_songs_background_music j ON j.area_id = a.id 
JOIN background_music bm ON j.bm_id = bm.id
JOIN songs so ON j.song_id = so.id
WHERE a.id = $1
ORDER BY so.id
`

type GetAreaBackgroundMusicRow struct {
	ID                     int32
	DataHash               string
	Name                   string
	StreamingName          sql.NullString
	InGameName             sql.NullString
	OstName                sql.NullString
	Translation            sql.NullString
	StreamingTrackNumber   sql.NullInt32
	MusicSphereID          sql.NullInt32
	OstDisc                interface{}
	OstTrackNumber         sql.NullInt32
	DurationInSeconds      int32
	CanLoop                bool
	SpecialUseCase         NullMusicUseCase
	CreditsID              sql.NullInt32
	ReplacesEncounterMusic bool
	Location               string
	Sublocation            string
	Area                   string
	AreaVersion            sql.NullInt32
}

func (q *Queries) GetAreaBackgroundMusic(ctx context.Context, id int32) ([]GetAreaBackgroundMusicRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreaBackgroundMusic, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreaBackgroundMusicRow
	for rows.Next() {
		var i GetAreaBackgroundMusicRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Name,
			&i.StreamingName,
			&i.InGameName,
			&i.OstName,
			&i.Translation,
			&i.StreamingTrackNumber,
			&i.MusicSphereID,
			&i.OstDisc,
			&i.OstTrackNumber,
			&i.DurationInSeconds,
			&i.CanLoop,
			&i.SpecialUseCase,
			&i.CreditsID,
			&i.ReplacesEncounterMusic,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaBossSongs = `-- name: GetAreaBossSongs :many
SELECT DISTINCT
    so.id, so.data_hash, so.name, so.streaming_name, so.in_game_name, so.ost_name, so.translation, so.streaming_track_number, so.music_sphere_id, so.ost_disc, so.ost_track_number, so.duration_in_seconds, so.can_loop, so.special_use_case, so.credits_id,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version AS area_version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN encounter_locations el ON el.area_id = a.id
JOIN j_encounter_location_formations j ON j.encounter_location_id = el.id
JOIN monster_formations mf ON j.monster_formation_id = mf.id
JOIN formation_boss_songs bs ON mf.boss_song_id = bs.id
JOIN songs so ON bs.song_id = so.id
WHERE a.id = $1
ORDER BY so.id
`

type GetAreaBossSongsRow struct {
	ID                   int32
	DataHash             string
	Name                 string
	StreamingName        sql.NullString
	InGameName           sql.NullString
	OstName              sql.NullString
	Translation          sql.NullString
	StreamingTrackNumber sql.NullInt32
	MusicSphereID        sql.NullInt32
	OstDisc              interface{}
	OstTrackNumber       sql.NullInt32
	DurationInSeconds    int32
	CanLoop              bool
	SpecialUseCase       NullMusicUseCase
	CreditsID            sql.NullInt32
	Location             string
	Sublocation          string
	Area                 string
	AreaVersion          sql.NullInt32
}

func (q *Queries) GetAreaBossSongs(ctx context.Context, id int32) ([]GetAreaBossSongsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreaBossSongs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreaBossSongsRow
	for rows.Next() {
		var i GetAreaBossSongsRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Name,
			&i.StreamingName,
			&i.InGameName,
			&i.OstName,
			&i.Translation,
			&i.StreamingTrackNumber,
			&i.MusicSphereID,
			&i.OstDisc,
			&i.OstTrackNumber,
			&i.DurationInSeconds,
			&i.CanLoop,
			&i.SpecialUseCase,
			&i.CreditsID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaCharacters = `-- name: GetAreaCharacters :many
SELECT
    c.id, c.data_hash, c.unit_id, c.story_only, c.weapon_type, c.armor_type, c.physical_attack_range, c.can_fight_underwater, c.area_id,
    pu.name,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area, a.version AS area_version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN characters c ON c.area_id = a.id
JOIN player_units pu ON c.unit_id = pu.id
WHERE a.id = $1
ORDER BY c.id
`

type GetAreaCharactersRow struct {
	ID                  int32
	DataHash            string
	UnitID              int32
	StoryOnly           bool
	WeaponType          WeaponType
	ArmorType           ArmorType
	PhysicalAttackRange interface{}
	CanFightUnderwater  bool
	AreaID              sql.NullInt32
	Name                string
	Location            string
	Sublocation         string
	Area                string
	AreaVersion         sql.NullInt32
}

func (q *Queries) GetAreaCharacters(ctx context.Context, id int32) ([]GetAreaCharactersRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreaCharacters, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreaCharactersRow
	for rows.Next() {
		var i GetAreaCharactersRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.UnitID,
			&i.StoryOnly,
			&i.WeaponType,
			&i.ArmorType,
			&i.PhysicalAttackRange,
			&i.CanFightUnderwater,
			&i.AreaID,
			&i.Name,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaConnections = `-- name: GetAreaConnections :many
SELECT
    ac.id, ac.data_hash, ac.area_id, ac.connection_type, ac.story_only, ac.notes,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version AS version,
    a.specification AS specification
FROM area_connections ac
JOIN j_area_connected_areas j ON j.connection_id = ac.id
JOIN areas a ON ac.area_id = a.id
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN areas a2 ON j.area_id = a2.id
WHERE a2.id = $1
ORDER BY ac.id
`

type GetAreaConnectionsRow struct {
	ID             int32
	DataHash       string
	AreaID         int32
	ConnectionType AreaConnectionType
	StoryOnly      bool
	Notes          sql.NullString
	Location       string
	Sublocation    string
	Area           string
	Version        sql.NullInt32
	Specification  sql.NullString
}

func (q *Queries) GetAreaConnections(ctx context.Context, id int32) ([]GetAreaConnectionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreaConnections, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreaConnectionsRow
	for rows.Next() {
		var i GetAreaConnectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.AreaID,
			&i.ConnectionType,
			&i.StoryOnly,
			&i.Notes,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.Version,
			&i.Specification,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaCues = `-- name: GetAreaCues :many
SELECT DISTINCT
    so.id, so.data_hash, so.name, so.streaming_name, so.in_game_name, so.ost_name, so.translation, so.streaming_track_number, so.music_sphere_id, so.ost_disc, so.ost_track_number, so.duration_in_seconds, so.can_loop, so.special_use_case, so.credits_id,
    c.replaces_encounter_music,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version AS area_version
FROM cues c
JOIN songs so ON c.song_id = so.id
JOIN j_songs_cues j ON j.cue_id = c.id
JOIN areas a ON COALESCE(c.trigger_area_id, j.included_area_id) = a.id
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
WHERE j.included_area_id = $1 OR c.trigger_area_id = $1
ORDER BY so.id
`

type GetAreaCuesRow struct {
	ID                     int32
	DataHash               string
	Name                   string
	StreamingName          sql.NullString
	InGameName             sql.NullString
	OstName                sql.NullString
	Translation            sql.NullString
	StreamingTrackNumber   sql.NullInt32
	MusicSphereID          sql.NullInt32
	OstDisc                interface{}
	OstTrackNumber         sql.NullInt32
	DurationInSeconds      int32
	CanLoop                bool
	SpecialUseCase         NullMusicUseCase
	CreditsID              sql.NullInt32
	ReplacesEncounterMusic bool
	Location               string
	Sublocation            string
	Area                   string
	AreaVersion            sql.NullInt32
}

func (q *Queries) GetAreaCues(ctx context.Context, includedAreaID int32) ([]GetAreaCuesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreaCues, includedAreaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreaCuesRow
	for rows.Next() {
		var i GetAreaCuesRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Name,
			&i.StreamingName,
			&i.InGameName,
			&i.OstName,
			&i.Translation,
			&i.StreamingTrackNumber,
			&i.MusicSphereID,
			&i.OstDisc,
			&i.OstTrackNumber,
			&i.DurationInSeconds,
			&i.CanLoop,
			&i.SpecialUseCase,
			&i.CreditsID,
			&i.ReplacesEncounterMusic,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaFMVSongs = `-- name: GetAreaFMVSongs :many
SELECT DISTINCT
    so.id, so.data_hash, so.name, so.streaming_name, so.in_game_name, so.ost_name, so.translation, so.streaming_track_number, so.music_sphere_id, so.ost_disc, so.ost_track_number, so.duration_in_seconds, so.can_loop, so.special_use_case, so.credits_id,
    l.name AS location,
    s.name As sublocation,
    a.name AS area,
    a.version AS area_version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN fmvs f ON f.area_id = a.id
JOIN songs so ON f.song_id = so.id
WHERE a.id = $1
ORDER BY so.id
`

type GetAreaFMVSongsRow struct {
	ID                   int32
	DataHash             string
	Name                 string
	StreamingName        sql.NullString
	InGameName           sql.NullString
	OstName              sql.NullString
	Translation          sql.NullString
	StreamingTrackNumber sql.NullInt32
	MusicSphereID        sql.NullInt32
	OstDisc              interface{}
	OstTrackNumber       sql.NullInt32
	DurationInSeconds    int32
	CanLoop              bool
	SpecialUseCase       NullMusicUseCase
	CreditsID            sql.NullInt32
	Location             string
	Sublocation          string
	Area                 string
	AreaVersion          sql.NullInt32
}

func (q *Queries) GetAreaFMVSongs(ctx context.Context, id int32) ([]GetAreaFMVSongsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreaFMVSongs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreaFMVSongsRow
	for rows.Next() {
		var i GetAreaFMVSongsRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Name,
			&i.StreamingName,
			&i.InGameName,
			&i.OstName,
			&i.Translation,
			&i.StreamingTrackNumber,
			&i.MusicSphereID,
			&i.OstDisc,
			&i.OstTrackNumber,
			&i.DurationInSeconds,
			&i.CanLoop,
			&i.SpecialUseCase,
			&i.CreditsID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaFMVs = `-- name: GetAreaFMVs :many
SELECT
    f.id, f.data_hash, f.name, f.translation, f.cutscene_description, f.song_id, f.area_id,
    l.name AS location,
    s.name As sublocation,
    a.name AS area,
    a.version AS area_version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN fmvs f ON f.area_id = a.id
WHERE a.id = $1
ORDER BY f.id
`

type GetAreaFMVsRow struct {
	ID                  int32
	DataHash            string
	Name                string
	Translation         sql.NullString
	CutsceneDescription string
	SongID              sql.NullInt32
	AreaID              int32
	Location            string
	Sublocation         string
	Area                string
	AreaVersion         sql.NullInt32
}

func (q *Queries) GetAreaFMVs(ctx context.Context, id int32) ([]GetAreaFMVsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreaFMVs, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreaFMVsRow
	for rows.Next() {
		var i GetAreaFMVsRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Name,
			&i.Translation,
			&i.CutsceneDescription,
			&i.SongID,
			&i.AreaID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaMonsterFormations = `-- name: GetAreaMonsterFormations :many
SELECT DISTINCT
    mf.id, mf.data_hash, mf.category, mf.is_forced_ambush, mf.can_escape, mf.boss_song_id, mf.notes,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version AS area_version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN encounter_locations el ON el.area_id = a.id
JOIN j_encounter_location_formations j ON j.encounter_location_id = el.id
JOIN monster_formations mf ON j.monster_formation_id = mf.id
WHERE a.id = $1
ORDER BY mf.id
`

type GetAreaMonsterFormationsRow struct {
	ID             int32
	DataHash       string
	Category       MonsterFormationCategory
	IsForcedAmbush bool
	CanEscape      bool
	BossSongID     sql.NullInt32
	Notes          sql.NullString
	Location       string
	Sublocation    string
	Area           string
	AreaVersion    sql.NullInt32
}

func (q *Queries) GetAreaMonsterFormations(ctx context.Context, id int32) ([]GetAreaMonsterFormationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreaMonsterFormations, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreaMonsterFormationsRow
	for rows.Next() {
		var i GetAreaMonsterFormationsRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Category,
			&i.IsForcedAmbush,
			&i.CanEscape,
			&i.BossSongID,
			&i.Notes,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaMonsters = `-- name: GetAreaMonsters :many
SELECT DISTINCT
    m.id, m.data_hash, m.name, m.version, m.specification, m.notes, m.species, m.is_story_based, m.is_repeatable, m.can_be_captured, m.area_conquest_location, m.ctb_icon_type, m.has_overdrive, m.is_underwater, m.is_zombie, m.distance, m.ap, m.ap_overkill, m.overkill_damage, m.gil, m.steal_gil, m.doom_countdown, m.poison_rate, m.threaten_chance, m.zanmato_level, m.monster_arena_price, m.sensor_text, m.scan_text,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version AS area_version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN encounter_locations el ON el.area_id = a.id
JOIN j_encounter_location_formations j1 ON j1.encounter_location_id = el.id
JOIN monster_formations mf ON j1.monster_formation_id = mf.id
JOIN j_monster_formations_monsters j2 ON j2.monster_formation_id = mf.id
JOIN monster_amounts ma ON j2.monster_amount_id = ma.id
JOIN monsters m ON ma.monster_id = m.id
WHERE a.id = $1
ORDER BY m.id
`

type GetAreaMonstersRow struct {
	ID                   int32
	DataHash             string
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	Notes                sql.NullString
	Species              MonsterSpecies
	IsStoryBased         bool
	IsRepeatable         bool
	CanBeCaptured        bool
	AreaConquestLocation NullMaCreationArea
	CtbIconType          CtbIconType
	HasOverdrive         bool
	IsUnderwater         bool
	IsZombie             bool
	Distance             interface{}
	Ap                   int32
	ApOverkill           int32
	OverkillDamage       int32
	Gil                  int32
	StealGil             sql.NullInt32
	DoomCountdown        interface{}
	PoisonRate           interface{}
	ThreatenChance       interface{}
	ZanmatoLevel         interface{}
	MonsterArenaPrice    sql.NullInt32
	SensorText           sql.NullString
	ScanText             sql.NullString
	Location             string
	Sublocation          string
	Area                 string
	AreaVersion          sql.NullInt32
}

func (q *Queries) GetAreaMonsters(ctx context.Context, id int32) ([]GetAreaMonstersRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreaMonsters, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreaMonstersRow
	for rows.Next() {
		var i GetAreaMonstersRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Name,
			&i.Version,
			&i.Specification,
			&i.Notes,
			&i.Species,
			&i.IsStoryBased,
			&i.IsRepeatable,
			&i.CanBeCaptured,
			&i.AreaConquestLocation,
			&i.CtbIconType,
			&i.HasOverdrive,
			&i.IsUnderwater,
			&i.IsZombie,
			&i.Distance,
			&i.Ap,
			&i.ApOverkill,
			&i.OverkillDamage,
			&i.Gil,
			&i.StealGil,
			&i.DoomCountdown,
			&i.PoisonRate,
			&i.ThreatenChance,
			&i.ZanmatoLevel,
			&i.MonsterArenaPrice,
			&i.SensorText,
			&i.ScanText,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaQuests = `-- name: GetAreaQuests :many
SELECT DISTINCT
    q.id, q.data_hash, q.name, q.type,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version AS area_version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN completion_locations cl ON cl.area_id = a.id
JOIN quest_completions qc ON cl.completion_id = qc.id
JOIN quests q ON qc.quest_id = q.id
WHERE a.id = $1
ORDER BY q.id
`

type GetAreaQuestsRow struct {
	ID          int32
	DataHash    string
	Name        string
	Type        QuestType
	Location    string
	Sublocation string
	Area        string
	AreaVersion sql.NullInt32
}

func (q *Queries) GetAreaQuests(ctx context.Context, id int32) ([]GetAreaQuestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreaQuests, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreaQuestsRow
	for rows.Next() {
		var i GetAreaQuestsRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Name,
			&i.Type,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaShops = `-- name: GetAreaShops :many
SELECT id, data_hash, version, area_id, notes, category FROM shops WHERE area_id = $1 ORDER BY id
`

func (q *Queries) GetAreaShops(ctx context.Context, areaID int32) ([]Shop, error) {
	rows, err := q.db.QueryContext(ctx, getAreaShops, areaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shop
	for rows.Next() {
		var i Shop
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Version,
			&i.AreaID,
			&i.Notes,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreaTreasures = `-- name: GetAreaTreasures :many
SELECT id, data_hash, area_id, version, treasure_type, loot_type, is_post_airship, is_anima_treasure, notes, gil_amount, found_equipment_id FROM treasures WHERE area_id = $1 ORDER BY id
`

func (q *Queries) GetAreaTreasures(ctx context.Context, areaID int32) ([]Treasure, error) {
	rows, err := q.db.QueryContext(ctx, getAreaTreasures, areaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Treasure
	for rows.Next() {
		var i Treasure
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.AreaID,
			&i.Version,
			&i.TreasureType,
			&i.LootType,
			&i.IsPostAirship,
			&i.IsAnimaTreasure,
			&i.Notes,
			&i.GilAmount,
			&i.FoundEquipmentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreas = `-- name: GetAreas :many
SELECT
    l.id AS location_id,
    l.name AS location,
    s.id AS sublocation_id,
    s.name AS sublocation,
    a.id, a.data_hash, a.sublocation_id, a.name, a.version, a.specification, a.story_only, a.has_save_sphere, a.airship_drop_off, a.has_compilation_sphere, a.can_ride_chocobo
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id 
JOIN locations l ON s.location_id = l.id
`

type GetAreasRow struct {
	LocationID           int32
	Location             string
	SublocationID        int32
	Sublocation          string
	ID                   int32
	DataHash             string
	SublocationID_2      int32
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	StoryOnly            bool
	HasSaveSphere        bool
	AirshipDropOff       bool
	HasCompilationSphere bool
	CanRideChocobo       bool
}

func (q *Queries) GetAreas(ctx context.Context) ([]GetAreasRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreasRow
	for rows.Next() {
		var i GetAreasRow
		if err := rows.Scan(
			&i.LocationID,
			&i.Location,
			&i.SublocationID,
			&i.Sublocation,
			&i.ID,
			&i.DataHash,
			&i.SublocationID_2,
			&i.Name,
			&i.Version,
			&i.Specification,
			&i.StoryOnly,
			&i.HasSaveSphere,
			&i.AirshipDropOff,
			&i.HasCompilationSphere,
			&i.CanRideChocobo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreasStoryOnly = `-- name: GetAreasStoryOnly :many
SELECT
    l.name AS location, 
    s.name AS sublocation,
    a.name AS area,
    a.version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
WHERE a.story_only = $1
ORDER BY a.id
`

type GetAreasStoryOnlyRow struct {
	Location    string
	Sublocation string
	Area        string
	Version     sql.NullInt32
}

func (q *Queries) GetAreasStoryOnly(ctx context.Context, storyOnly bool) ([]GetAreasStoryOnlyRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreasStoryOnly, storyOnly)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreasStoryOnlyRow
	for rows.Next() {
		var i GetAreasStoryOnlyRow
		if err := rows.Scan(
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreasWithAeons = `-- name: GetAreasWithAeons :many
SELECT
    a.id,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN aeons ae ON ae.area_id = a.id
JOIN player_units pu ON ae.unit_id = pu.id
ORDER BY a.id
`

type GetAreasWithAeonsRow struct {
	ID          int32
	Location    string
	Sublocation string
	Area        string
	Version     sql.NullInt32
}

func (q *Queries) GetAreasWithAeons(ctx context.Context) ([]GetAreasWithAeonsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreasWithAeons)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreasWithAeonsRow
	for rows.Next() {
		var i GetAreasWithAeonsRow
		if err := rows.Scan(
			&i.ID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreasWithBosses = `-- name: GetAreasWithBosses :many
SELECT DISTINCT
    a.id,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN encounter_locations el ON el.area_id = a.id
JOIN j_encounter_location_formations j ON j.encounter_location_id = el.id
JOIN monster_formations mf ON j.monster_formation_id = mf.id
JOIN formation_boss_songs bs ON mf.boss_song_id = bs.id
JOIN songs so ON bs.song_id = so.id
ORDER BY a.id
`

type GetAreasWithBossesRow struct {
	ID          int32
	Location    string
	Sublocation string
	Area        string
	Version     sql.NullInt32
}

func (q *Queries) GetAreasWithBosses(ctx context.Context) ([]GetAreasWithBossesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreasWithBosses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreasWithBossesRow
	for rows.Next() {
		var i GetAreasWithBossesRow
		if err := rows.Scan(
			&i.ID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreasWithCharacters = `-- name: GetAreasWithCharacters :many
SELECT
    a.id,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN characters c ON c.area_id = a.id
JOIN player_units pu ON c.unit_id = pu.id
ORDER BY a.id
`

type GetAreasWithCharactersRow struct {
	ID          int32
	Location    string
	Sublocation string
	Area        string
	Version     sql.NullInt32
}

func (q *Queries) GetAreasWithCharacters(ctx context.Context) ([]GetAreasWithCharactersRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreasWithCharacters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreasWithCharactersRow
	for rows.Next() {
		var i GetAreasWithCharactersRow
		if err := rows.Scan(
			&i.ID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreasWithChocobo = `-- name: GetAreasWithChocobo :many
SELECT
    l.name AS location, 
    s.name AS sublocation,
    a.name AS area,
    a.version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
WHERE a.can_ride_chocobo = $1
ORDER BY a.id
`

type GetAreasWithChocoboRow struct {
	Location    string
	Sublocation string
	Area        string
	Version     sql.NullInt32
}

func (q *Queries) GetAreasWithChocobo(ctx context.Context, canRideChocobo bool) ([]GetAreasWithChocoboRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreasWithChocobo, canRideChocobo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreasWithChocoboRow
	for rows.Next() {
		var i GetAreasWithChocoboRow
		if err := rows.Scan(
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreasWithCompSphere = `-- name: GetAreasWithCompSphere :many
SELECT
    l.name AS location, 
    s.name AS sublocation,
    a.name AS area,
    a.version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
WHERE a.has_compilation_sphere = $1
ORDER BY a.id
`

type GetAreasWithCompSphereRow struct {
	Location    string
	Sublocation string
	Area        string
	Version     sql.NullInt32
}

func (q *Queries) GetAreasWithCompSphere(ctx context.Context, hasCompilationSphere bool) ([]GetAreasWithCompSphereRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreasWithCompSphere, hasCompilationSphere)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreasWithCompSphereRow
	for rows.Next() {
		var i GetAreasWithCompSphereRow
		if err := rows.Scan(
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreasWithDropOff = `-- name: GetAreasWithDropOff :many
SELECT
    l.name AS location, 
    s.name AS sublocation,
    a.name AS area,
    a.version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
WHERE a.airship_drop_off = $1
ORDER BY a.id
`

type GetAreasWithDropOffRow struct {
	Location    string
	Sublocation string
	Area        string
	Version     sql.NullInt32
}

func (q *Queries) GetAreasWithDropOff(ctx context.Context, airshipDropOff bool) ([]GetAreasWithDropOffRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreasWithDropOff, airshipDropOff)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreasWithDropOffRow
	for rows.Next() {
		var i GetAreasWithDropOffRow
		if err := rows.Scan(
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreasWithFMVs = `-- name: GetAreasWithFMVs :many
SELECT DISTINCT
    a.id,
    l.name AS location,
    s.name As sublocation,
    a.name AS area,
    a.version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN fmvs f ON f.area_id = a.id
ORDER BY a.id
`

type GetAreasWithFMVsRow struct {
	ID          int32
	Location    string
	Sublocation string
	Area        string
	Version     sql.NullInt32
}

func (q *Queries) GetAreasWithFMVs(ctx context.Context) ([]GetAreasWithFMVsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreasWithFMVs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreasWithFMVsRow
	for rows.Next() {
		var i GetAreasWithFMVsRow
		if err := rows.Scan(
			&i.ID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreasWithItemMonster = `-- name: GetAreasWithItemMonster :many
SELECT DISTINCT
    a.id,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN encounter_locations el ON el.area_id = a.id
JOIN j_encounter_location_formations j1 ON j1.encounter_location_id = el.id
JOIN monster_formations mf ON j1.monster_formation_id = mf.id
JOIN j_monster_formations_monsters j2 ON j2.monster_formation_id = mf.id
JOIN monster_amounts ma ON j2.monster_amount_id = ma.id
JOIN monsters m ON ma.monster_id = m.id
JOIN monster_items mi ON mi.monster_id = m.id
LEFT JOIN j_monster_items_other_items jmio
  ON jmio.monster_items_id = mi.id
LEFT JOIN possible_items pi
  ON pi.id = jmio.possible_item_id
JOIN item_amounts ia
  ON ia.id IN (
      mi.steal_common_id,
      mi.steal_rare_id,
      mi.drop_common_id,
      mi.drop_rare_id,
      mi.secondary_drop_common_id,
      mi.secondary_drop_rare_id,
      mi.bribe_id,
      pi.item_amount_id
  )
JOIN master_items mit ON ia.master_item_id = mit.id
JOIN items i ON i.master_item_id = mit.id
WHERE i.id = $1
ORDER BY a.id
`

type GetAreasWithItemMonsterRow struct {
	ID          int32
	Location    string
	Sublocation string
	Area        string
	Version     sql.NullInt32
}

func (q *Queries) GetAreasWithItemMonster(ctx context.Context, id int32) ([]GetAreasWithItemMonsterRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreasWithItemMonster, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreasWithItemMonsterRow
	for rows.Next() {
		var i GetAreasWithItemMonsterRow
		if err := rows.Scan(
			&i.ID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreasWithItemQuest = `-- name: GetAreasWithItemQuest :many
SELECT DISTINCT
    a.id,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN completion_locations cl ON cl.area_id = a.id
JOIN quest_completions qc ON cl.completion_id = qc.id
JOIN item_amounts ia ON qc.item_amount_id = ia.id
JOIN master_items mi ON ia.master_item_id = mi.id
JOIN items i ON i.master_item_id = mi.id
WHERE i.id = $1
ORDER BY a.id
`

type GetAreasWithItemQuestRow struct {
	ID          int32
	Location    string
	Sublocation string
	Area        string
	Version     sql.NullInt32
}

func (q *Queries) GetAreasWithItemQuest(ctx context.Context, id int32) ([]GetAreasWithItemQuestRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreasWithItemQuest, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreasWithItemQuestRow
	for rows.Next() {
		var i GetAreasWithItemQuestRow
		if err := rows.Scan(
			&i.ID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreasWithItemShop = `-- name: GetAreasWithItemShop :many
SELECT DISTINCT
    a.id,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN shops sh ON sh.area_id = a.id
JOIN j_shops_items j ON j.shop_id = sh.id
JOIN shop_items si ON j.shop_item_id = si.id
JOIN items i ON si.item_id = i.id
WHERE i.id = $1
ORDER BY a.id
`

type GetAreasWithItemShopRow struct {
	ID          int32
	Location    string
	Sublocation string
	Area        string
	Version     sql.NullInt32
}

func (q *Queries) GetAreasWithItemShop(ctx context.Context, id int32) ([]GetAreasWithItemShopRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreasWithItemShop, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreasWithItemShopRow
	for rows.Next() {
		var i GetAreasWithItemShopRow
		if err := rows.Scan(
			&i.ID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreasWithItemTreasure = `-- name: GetAreasWithItemTreasure :many
SELECT DISTINCT
    a.id,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN treasures t ON t.area_id = a.id
JOIN j_treasures_items j ON j.treasure_id = t.id
JOIN item_amounts ia ON j.item_amount_id = ia.id
JOIN master_items mi ON ia.master_item_id = mi.id
JOIN items i ON i.master_item_id = mi.id
WHERE i.id = $1
ORDER BY a.id
`

type GetAreasWithItemTreasureRow struct {
	ID          int32
	Location    string
	Sublocation string
	Area        string
	Version     sql.NullInt32
}

func (q *Queries) GetAreasWithItemTreasure(ctx context.Context, id int32) ([]GetAreasWithItemTreasureRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreasWithItemTreasure, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreasWithItemTreasureRow
	for rows.Next() {
		var i GetAreasWithItemTreasureRow
		if err := rows.Scan(
			&i.ID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreasWithKeyItemQuest = `-- name: GetAreasWithKeyItemQuest :many
SELECT DISTINCT
    a.id,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN completion_locations cl ON cl.area_id = a.id
JOIN quest_completions qc ON cl.completion_id = qc.id
JOIN item_amounts ia ON qc.item_amount_id = ia.id
JOIN master_items mi ON ia.master_item_id = mi.id
JOIN key_items ki ON ki.master_item_id = mi.id
WHERE ki.id = $1
ORDER BY a.id
`

type GetAreasWithKeyItemQuestRow struct {
	ID          int32
	Location    string
	Sublocation string
	Area        string
	Version     sql.NullInt32
}

func (q *Queries) GetAreasWithKeyItemQuest(ctx context.Context, id int32) ([]GetAreasWithKeyItemQuestRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreasWithKeyItemQuest, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreasWithKeyItemQuestRow
	for rows.Next() {
		var i GetAreasWithKeyItemQuestRow
		if err := rows.Scan(
			&i.ID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreasWithKeyItemTreasure = `-- name: GetAreasWithKeyItemTreasure :many
SELECT DISTINCT
    a.id,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version
FROM areas a
JOIN treasures t ON t.area_id = a.id
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN j_treasures_items j ON j.treasure_id = t.id
JOIN item_amounts ia ON j.item_amount_id = ia.id
JOIN master_items mi ON ia.master_item_id = mi.id
JOIN key_items ki ON ki.master_item_id = mi.id
WHERE ki.id = $1
ORDER BY a.id
`

type GetAreasWithKeyItemTreasureRow struct {
	ID          int32
	Location    string
	Sublocation string
	Area        string
	Version     sql.NullInt32
}

func (q *Queries) GetAreasWithKeyItemTreasure(ctx context.Context, id int32) ([]GetAreasWithKeyItemTreasureRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreasWithKeyItemTreasure, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreasWithKeyItemTreasureRow
	for rows.Next() {
		var i GetAreasWithKeyItemTreasureRow
		if err := rows.Scan(
			&i.ID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreasWithMonsters = `-- name: GetAreasWithMonsters :many
SELECT DISTINCT
    a.id,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN encounter_locations el ON el.area_id = a.id
JOIN j_encounter_location_formations j1 ON j1.encounter_location_id = el.id
JOIN monster_formations mf ON j1.monster_formation_id = mf.id
JOIN j_monster_formations_monsters j2 ON j2.monster_formation_id = mf.id
JOIN monster_amounts ma ON j2.monster_amount_id = ma.id
JOIN monsters m ON ma.monster_id = m.id
ORDER BY a.id
`

type GetAreasWithMonstersRow struct {
	ID          int32
	Location    string
	Sublocation string
	Area        string
	Version     sql.NullInt32
}

func (q *Queries) GetAreasWithMonsters(ctx context.Context) ([]GetAreasWithMonstersRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreasWithMonsters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreasWithMonstersRow
	for rows.Next() {
		var i GetAreasWithMonstersRow
		if err := rows.Scan(
			&i.ID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreasWithSaveSphere = `-- name: GetAreasWithSaveSphere :many
SELECT
    l.name AS location, 
    s.name AS sublocation,
    a.name AS area,
    a.version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
WHERE a.has_save_sphere = $1
ORDER BY a.id
`

type GetAreasWithSaveSphereRow struct {
	Location    string
	Sublocation string
	Area        string
	Version     sql.NullInt32
}

func (q *Queries) GetAreasWithSaveSphere(ctx context.Context, hasSaveSphere bool) ([]GetAreasWithSaveSphereRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreasWithSaveSphere, hasSaveSphere)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreasWithSaveSphereRow
	for rows.Next() {
		var i GetAreasWithSaveSphereRow
		if err := rows.Scan(
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreasWithShops = `-- name: GetAreasWithShops :many
SELECT DISTINCT
    a.id,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN shops sh ON sh.area_id = a.id
ORDER BY a.id
`

type GetAreasWithShopsRow struct {
	ID          int32
	Location    string
	Sublocation string
	Area        string
	Version     sql.NullInt32
}

func (q *Queries) GetAreasWithShops(ctx context.Context) ([]GetAreasWithShopsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreasWithShops)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreasWithShopsRow
	for rows.Next() {
		var i GetAreasWithShopsRow
		if err := rows.Scan(
			&i.ID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreasWithSidequests = `-- name: GetAreasWithSidequests :many
SELECT DISTINCT
    a.id,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN completion_locations cl ON cl.area_id = a.id
JOIN quest_completions qc ON cl.completion_id = qc.id
JOIN quests q ON qc.quest_id = q.id
ORDER BY a.id
`

type GetAreasWithSidequestsRow struct {
	ID          int32
	Location    string
	Sublocation string
	Area        string
	Version     sql.NullInt32
}

func (q *Queries) GetAreasWithSidequests(ctx context.Context) ([]GetAreasWithSidequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreasWithSidequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreasWithSidequestsRow
	for rows.Next() {
		var i GetAreasWithSidequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAreasWithTreasures = `-- name: GetAreasWithTreasures :many
SELECT DISTINCT
    a.id,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id
JOIN locations l ON s.location_id = l.id
JOIN treasures t ON t.area_id = a.id
ORDER BY a.id
`

type GetAreasWithTreasuresRow struct {
	ID          int32
	Location    string
	Sublocation string
	Area        string
	Version     sql.NullInt32
}

func (q *Queries) GetAreasWithTreasures(ctx context.Context) ([]GetAreasWithTreasuresRow, error) {
	rows, err := q.db.QueryContext(ctx, getAreasWithTreasures)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAreasWithTreasuresRow
	for rows.Next() {
		var i GetAreasWithTreasuresRow
		if err := rows.Scan(
			&i.ID,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocationAreaByAreaName = `-- name: GetLocationAreaByAreaName :one
SELECT l.name, s.name, a.name, a.version FROM locations l JOIN sublocations s ON s.location_id = l.id JOIN areas a ON a.sublocation_id = a.id
WHERE l.id = $1 AND s.id = $2 AND a.name = $3 AND a.version = $4
`

type GetLocationAreaByAreaNameParams struct {
	ID      int32
	ID_2    int32
	Name    string
	Version sql.NullInt32
}

type GetLocationAreaByAreaNameRow struct {
	Name    string
	Name_2  string
	Name_3  string
	Version sql.NullInt32
}

func (q *Queries) GetLocationAreaByAreaName(ctx context.Context, arg GetLocationAreaByAreaNameParams) (GetLocationAreaByAreaNameRow, error) {
	row := q.db.QueryRowContext(ctx, getLocationAreaByAreaName,
		arg.ID,
		arg.ID_2,
		arg.Name,
		arg.Version,
	)
	var i GetLocationAreaByAreaNameRow
	err := row.Scan(
		&i.Name,
		&i.Name_2,
		&i.Name_3,
		&i.Version,
	)
	return i, err
}

const getLocationAreas = `-- name: GetLocationAreas :many
SELECT
    l.name AS location, 
    s.name AS sublocation,
    a.name AS area,
    a.version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id 
JOIN locations l ON s.location_id = l.id
WHERE l.id = $1
ORDER BY a.id
`

type GetLocationAreasRow struct {
	Location    string
	Sublocation string
	Area        string
	Version     sql.NullInt32
}

func (q *Queries) GetLocationAreas(ctx context.Context, id int32) ([]GetLocationAreasRow, error) {
	rows, err := q.db.QueryContext(ctx, getLocationAreas, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLocationAreasRow
	for rows.Next() {
		var i GetLocationAreasRow
		if err := rows.Scan(
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocationMonsters = `-- name: GetLocationMonsters :many
SELECT DISTINCT
    m.id, m.data_hash, m.name, m.version, m.specification, m.notes, m.species, m.is_story_based, m.is_repeatable, m.can_be_captured, m.area_conquest_location, m.ctb_icon_type, m.has_overdrive, m.is_underwater, m.is_zombie, m.distance, m.ap, m.ap_overkill, m.overkill_damage, m.gil, m.steal_gil, m.doom_countdown, m.poison_rate, m.threaten_chance, m.zanmato_level, m.monster_arena_price, m.sensor_text, m.scan_text,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version AS area_version
FROM monsters m
LEFT JOIN monster_amounts ma ON ma.monster_id = m.id
LEFT JOIN j_monster_formations_monsters j1 ON j1.monster_amount_id = ma.id
LEFT JOIN monster_formations mf ON j1.monster_formation_id = mf.id
LEFT JOIN j_encounter_location_formations j2 ON j2.monster_formation_id = mf.id
LEFT JOIN encounter_locations el ON j2.encounter_location_id = el.id
LEFT JOIN areas a ON el.area_id = a.id
LEFT JOIN sublocations s ON a.sublocation_id = s.id
LEFT JOIN locations l ON s.location_id = l.id
WHERE location_id = $1
ORDER BY m.id
`

type GetLocationMonstersRow struct {
	ID                   int32
	DataHash             string
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	Notes                sql.NullString
	Species              MonsterSpecies
	IsStoryBased         bool
	IsRepeatable         bool
	CanBeCaptured        bool
	AreaConquestLocation NullMaCreationArea
	CtbIconType          CtbIconType
	HasOverdrive         bool
	IsUnderwater         bool
	IsZombie             bool
	Distance             interface{}
	Ap                   int32
	ApOverkill           int32
	OverkillDamage       int32
	Gil                  int32
	StealGil             sql.NullInt32
	DoomCountdown        interface{}
	PoisonRate           interface{}
	ThreatenChance       interface{}
	ZanmatoLevel         interface{}
	MonsterArenaPrice    sql.NullInt32
	SensorText           sql.NullString
	ScanText             sql.NullString
	Location             sql.NullString
	Sublocation          sql.NullString
	Area                 sql.NullString
	AreaVersion          sql.NullInt32
}

func (q *Queries) GetLocationMonsters(ctx context.Context, locationID int32) ([]GetLocationMonstersRow, error) {
	rows, err := q.db.QueryContext(ctx, getLocationMonsters, locationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLocationMonstersRow
	for rows.Next() {
		var i GetLocationMonstersRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Name,
			&i.Version,
			&i.Specification,
			&i.Notes,
			&i.Species,
			&i.IsStoryBased,
			&i.IsRepeatable,
			&i.CanBeCaptured,
			&i.AreaConquestLocation,
			&i.CtbIconType,
			&i.HasOverdrive,
			&i.IsUnderwater,
			&i.IsZombie,
			&i.Distance,
			&i.Ap,
			&i.ApOverkill,
			&i.OverkillDamage,
			&i.Gil,
			&i.StealGil,
			&i.DoomCountdown,
			&i.PoisonRate,
			&i.ThreatenChance,
			&i.ZanmatoLevel,
			&i.MonsterArenaPrice,
			&i.SensorText,
			&i.ScanText,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSublocationAreas = `-- name: GetSublocationAreas :many
SELECT
    l.name AS location, 
    s.name AS sublocation,
    a.name AS area,
    a.version
FROM areas a
JOIN sublocations s ON a.sublocation_id = s.id 
JOIN locations l ON s.location_id = l.id
WHERE s.id = $1
ORDER BY a.id
`

type GetSublocationAreasRow struct {
	Location    string
	Sublocation string
	Area        string
	Version     sql.NullInt32
}

func (q *Queries) GetSublocationAreas(ctx context.Context, id int32) ([]GetSublocationAreasRow, error) {
	rows, err := q.db.QueryContext(ctx, getSublocationAreas, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSublocationAreasRow
	for rows.Next() {
		var i GetSublocationAreasRow
		if err := rows.Scan(
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSublocationMonsters = `-- name: GetSublocationMonsters :many
SELECT DISTINCT
    m.id, m.data_hash, m.name, m.version, m.specification, m.notes, m.species, m.is_story_based, m.is_repeatable, m.can_be_captured, m.area_conquest_location, m.ctb_icon_type, m.has_overdrive, m.is_underwater, m.is_zombie, m.distance, m.ap, m.ap_overkill, m.overkill_damage, m.gil, m.steal_gil, m.doom_countdown, m.poison_rate, m.threaten_chance, m.zanmato_level, m.monster_arena_price, m.sensor_text, m.scan_text,
    l.name AS location,
    s.name AS sublocation,
    a.name AS area,
    a.version AS area_version
FROM monsters m
LEFT JOIN monster_amounts ma ON ma.monster_id = m.id
LEFT JOIN j_monster_formations_monsters j1 ON j1.monster_amount_id = ma.id
LEFT JOIN monster_formations mf ON j1.monster_formation_id = mf.id
LEFT JOIN j_encounter_location_formations j2 ON j2.monster_formation_id = mf.id
LEFT JOIN encounter_locations el ON j2.encounter_location_id = el.id
LEFT JOIN areas a ON el.area_id = a.id
LEFT JOIN sublocations s ON a.sublocation_id = s.id
LEFT JOIN locations l ON s.location_id = l.id
WHERE sublocation_id = $1
ORDER BY m.id
`

type GetSublocationMonstersRow struct {
	ID                   int32
	DataHash             string
	Name                 string
	Version              sql.NullInt32
	Specification        sql.NullString
	Notes                sql.NullString
	Species              MonsterSpecies
	IsStoryBased         bool
	IsRepeatable         bool
	CanBeCaptured        bool
	AreaConquestLocation NullMaCreationArea
	CtbIconType          CtbIconType
	HasOverdrive         bool
	IsUnderwater         bool
	IsZombie             bool
	Distance             interface{}
	Ap                   int32
	ApOverkill           int32
	OverkillDamage       int32
	Gil                  int32
	StealGil             sql.NullInt32
	DoomCountdown        interface{}
	PoisonRate           interface{}
	ThreatenChance       interface{}
	ZanmatoLevel         interface{}
	MonsterArenaPrice    sql.NullInt32
	SensorText           sql.NullString
	ScanText             sql.NullString
	Location             sql.NullString
	Sublocation          sql.NullString
	Area                 sql.NullString
	AreaVersion          sql.NullInt32
}

func (q *Queries) GetSublocationMonsters(ctx context.Context, sublocationID int32) ([]GetSublocationMonstersRow, error) {
	rows, err := q.db.QueryContext(ctx, getSublocationMonsters, sublocationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSublocationMonstersRow
	for rows.Next() {
		var i GetSublocationMonstersRow
		if err := rows.Scan(
			&i.ID,
			&i.DataHash,
			&i.Name,
			&i.Version,
			&i.Specification,
			&i.Notes,
			&i.Species,
			&i.IsStoryBased,
			&i.IsRepeatable,
			&i.CanBeCaptured,
			&i.AreaConquestLocation,
			&i.CtbIconType,
			&i.HasOverdrive,
			&i.IsUnderwater,
			&i.IsZombie,
			&i.Distance,
			&i.Ap,
			&i.ApOverkill,
			&i.OverkillDamage,
			&i.Gil,
			&i.StealGil,
			&i.DoomCountdown,
			&i.PoisonRate,
			&i.ThreatenChance,
			&i.ZanmatoLevel,
			&i.MonsterArenaPrice,
			&i.SensorText,
			&i.ScanText,
			&i.Location,
			&i.Sublocation,
			&i.Area,
			&i.AreaVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTreasure = `-- name: UpdateTreasure :exec
UPDATE treasures
SET data_hash = $1,
    found_equipment_id = $2
WHERE id = $3
`

type UpdateTreasureParams struct {
	DataHash         string
	FoundEquipmentID sql.NullInt32
	ID               int32
}

func (q *Queries) UpdateTreasure(ctx context.Context, arg UpdateTreasureParams) error {
	_, err := q.db.ExecContext(ctx, updateTreasure, arg.DataHash, arg.FoundEquipmentID, arg.ID)
	return err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: abilities.sql

package database

import (
	"context"
	"database/sql"
)

const createAbility = `-- name: CreateAbility :one
INSERT INTO abilities (data_hash, name, version, specification, attributes_id, type)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (data_hash) DO UPDATE SET data_hash = abilities.data_hash
RETURNING id, data_hash, name, version, specification, attributes_id, type
`

type CreateAbilityParams struct {
	DataHash      string
	Name          string
	Version       sql.NullInt32
	Specification sql.NullString
	AttributesID  sql.NullInt32
	Type          AbilityType
}

func (q *Queries) CreateAbility(ctx context.Context, arg CreateAbilityParams) (Ability, error) {
	row := q.db.QueryRowContext(ctx, createAbility,
		arg.DataHash,
		arg.Name,
		arg.Version,
		arg.Specification,
		arg.AttributesID,
		arg.Type,
	)
	var i Ability
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Name,
		&i.Version,
		&i.Specification,
		&i.AttributesID,
		&i.Type,
	)
	return i, err
}

const createAbilityAttributes = `-- name: CreateAbilityAttributes :one
INSERT INTO ability_attributes (data_hash, rank, appears_in_help_bar, can_copycat)
VALUES ($1, $2, $3, $4)
ON CONFLICT (data_hash) DO UPDATE SET data_hash = ability_attributes.data_hash
RETURNING id, data_hash, rank, appears_in_help_bar, can_copycat
`

type CreateAbilityAttributesParams struct {
	DataHash         string
	Rank             sql.NullInt32
	AppearsInHelpBar bool
	CanCopycat       bool
}

func (q *Queries) CreateAbilityAttributes(ctx context.Context, arg CreateAbilityAttributesParams) (AbilityAttribute, error) {
	row := q.db.QueryRowContext(ctx, createAbilityAttributes,
		arg.DataHash,
		arg.Rank,
		arg.AppearsInHelpBar,
		arg.CanCopycat,
	)
	var i AbilityAttribute
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Rank,
		&i.AppearsInHelpBar,
		&i.CanCopycat,
	)
	return i, err
}

const createEnemyAbility = `-- name: CreateEnemyAbility :one
INSERT INTO enemy_abilities (data_hash, ability_id, effect)
VALUES ($1, $2, $3)
ON CONFLICT (data_hash) DO UPDATE SET data_hash = enemy_abilities.data_hash
RETURNING id, data_hash, ability_id, effect
`

type CreateEnemyAbilityParams struct {
	DataHash  string
	AbilityID int32
	Effect    sql.NullString
}

func (q *Queries) CreateEnemyAbility(ctx context.Context, arg CreateEnemyAbilityParams) (EnemyAbility, error) {
	row := q.db.QueryRowContext(ctx, createEnemyAbility, arg.DataHash, arg.AbilityID, arg.Effect)
	var i EnemyAbility
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.AbilityID,
		&i.Effect,
	)
	return i, err
}

const createOverdrive = `-- name: CreateOverdrive :one
INSERT INTO overdrives (data_hash, name, version, description, effect, topmenu, attributes_id, unlock_condition, countdown_in_sec, cursor)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = overdrives.data_hash
RETURNING id, data_hash, name, version, description, effect, topmenu, attributes_id, unlock_condition, countdown_in_sec, cursor, od_command_id, character_class_id
`

type CreateOverdriveParams struct {
	DataHash        string
	Name            string
	Version         sql.NullInt32
	Description     string
	Effect          string
	Topmenu         NullTopmenuType
	AttributesID    int32
	UnlockCondition sql.NullString
	CountdownInSec  sql.NullInt32
	Cursor          NullTargetType
}

func (q *Queries) CreateOverdrive(ctx context.Context, arg CreateOverdriveParams) (Overdrife, error) {
	row := q.db.QueryRowContext(ctx, createOverdrive,
		arg.DataHash,
		arg.Name,
		arg.Version,
		arg.Description,
		arg.Effect,
		arg.Topmenu,
		arg.AttributesID,
		arg.UnlockCondition,
		arg.CountdownInSec,
		arg.Cursor,
	)
	var i Overdrife
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Name,
		&i.Version,
		&i.Description,
		&i.Effect,
		&i.Topmenu,
		&i.AttributesID,
		&i.UnlockCondition,
		&i.CountdownInSec,
		&i.Cursor,
		&i.OdCommandID,
		&i.CharacterClassID,
	)
	return i, err
}

const createOverdriveAbility = `-- name: CreateOverdriveAbility :one
INSERT INTO overdrive_abilities (data_hash, ability_id)
VALUES ($1, $2)
ON CONFLICT (data_hash) DO UPDATE SET data_hash = overdrive_abilities.data_hash
RETURNING id, data_hash, ability_id
`

type CreateOverdriveAbilityParams struct {
	DataHash  string
	AbilityID int32
}

func (q *Queries) CreateOverdriveAbility(ctx context.Context, arg CreateOverdriveAbilityParams) (OverdriveAbility, error) {
	row := q.db.QueryRowContext(ctx, createOverdriveAbility, arg.DataHash, arg.AbilityID)
	var i OverdriveAbility
	err := row.Scan(&i.ID, &i.DataHash, &i.AbilityID)
	return i, err
}

const createOverdriveAbilityJunction = `-- name: CreateOverdriveAbilityJunction :exec
INSERT INTO j_overdrive_ability (data_hash, overdrive_id, overdrive_ability_id)
VALUES($1, $2, $3)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateOverdriveAbilityJunctionParams struct {
	DataHash           string
	OverdriveID        int32
	OverdriveAbilityID int32
}

func (q *Queries) CreateOverdriveAbilityJunction(ctx context.Context, arg CreateOverdriveAbilityJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createOverdriveAbilityJunction, arg.DataHash, arg.OverdriveID, arg.OverdriveAbilityID)
	return err
}

const createPlayerAbility = `-- name: CreatePlayerAbility :one
INSERT INTO player_abilities (data_hash, ability_id, description, effect, topmenu, can_use_outside_battle, mp_cost, cursor)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = player_abilities.data_hash
RETURNING id, data_hash, ability_id, description, effect, topmenu, can_use_outside_battle, mp_cost, cursor
`

type CreatePlayerAbilityParams struct {
	DataHash            string
	AbilityID           int32
	Description         sql.NullString
	Effect              string
	Topmenu             NullTopmenuType
	CanUseOutsideBattle bool
	MpCost              sql.NullInt32
	Cursor              NullTargetType
}

func (q *Queries) CreatePlayerAbility(ctx context.Context, arg CreatePlayerAbilityParams) (PlayerAbility, error) {
	row := q.db.QueryRowContext(ctx, createPlayerAbility,
		arg.DataHash,
		arg.AbilityID,
		arg.Description,
		arg.Effect,
		arg.Topmenu,
		arg.CanUseOutsideBattle,
		arg.MpCost,
		arg.Cursor,
	)
	var i PlayerAbility
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.AbilityID,
		&i.Description,
		&i.Effect,
		&i.Topmenu,
		&i.CanUseOutsideBattle,
		&i.MpCost,
		&i.Cursor,
	)
	return i, err
}

const createTriggerCommand = `-- name: CreateTriggerCommand :one
INSERT INTO trigger_commands (data_hash, ability_id, description, effect, topmenu, cursor)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (data_hash) DO UPDATE SET data_hash = trigger_commands.data_hash
RETURNING id, data_hash, ability_id, description, effect, topmenu, cursor
`

type CreateTriggerCommandParams struct {
	DataHash    string
	AbilityID   int32
	Description string
	Effect      string
	Topmenu     TopmenuType
	Cursor      TargetType
}

func (q *Queries) CreateTriggerCommand(ctx context.Context, arg CreateTriggerCommandParams) (TriggerCommand, error) {
	row := q.db.QueryRowContext(ctx, createTriggerCommand,
		arg.DataHash,
		arg.AbilityID,
		arg.Description,
		arg.Effect,
		arg.Topmenu,
		arg.Cursor,
	)
	var i TriggerCommand
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.AbilityID,
		&i.Description,
		&i.Effect,
		&i.Topmenu,
		&i.Cursor,
	)
	return i, err
}

const updateOverdrive = `-- name: UpdateOverdrive :exec
UPDATE overdrives
SET data_hash = $1,
    name = $2,
    version = $3,
    description = $4,
    effect = $5,
    topmenu = $6,
    attributes_id = $7,
    unlock_condition = $8,
    countdown_in_sec = $9,
    cursor = $10,
    od_command_id = $11,
    character_class_id = $12
WHERE id = $13
`

type UpdateOverdriveParams struct {
	DataHash         string
	Name             string
	Version          sql.NullInt32
	Description      string
	Effect           string
	Topmenu          NullTopmenuType
	AttributesID     int32
	UnlockCondition  sql.NullString
	CountdownInSec   sql.NullInt32
	Cursor           NullTargetType
	OdCommandID      sql.NullInt32
	CharacterClassID sql.NullInt32
	ID               int32
}

func (q *Queries) UpdateOverdrive(ctx context.Context, arg UpdateOverdriveParams) error {
	_, err := q.db.ExecContext(ctx, updateOverdrive,
		arg.DataHash,
		arg.Name,
		arg.Version,
		arg.Description,
		arg.Effect,
		arg.Topmenu,
		arg.AttributesID,
		arg.UnlockCondition,
		arg.CountdownInSec,
		arg.Cursor,
		arg.OdCommandID,
		arg.CharacterClassID,
		arg.ID,
	)
	return err
}

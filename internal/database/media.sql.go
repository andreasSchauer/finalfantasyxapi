// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: media.sql

package database

import (
	"context"
	"database/sql"
)

const createBackgroundMusic = `-- name: CreateBackgroundMusic :one
INSERT INTO background_music (data_hash, condition, replaces_encounter_music)
VALUES ($1, $2, $3)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = background_music.data_hash
RETURNING id, data_hash, condition, replaces_encounter_music
`

type CreateBackgroundMusicParams struct {
	DataHash               string
	Condition              sql.NullString
	ReplacesEncounterMusic bool
}

func (q *Queries) CreateBackgroundMusic(ctx context.Context, arg CreateBackgroundMusicParams) (BackgroundMusic, error) {
	row := q.db.QueryRowContext(ctx, createBackgroundMusic, arg.DataHash, arg.Condition, arg.ReplacesEncounterMusic)
	var i BackgroundMusic
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Condition,
		&i.ReplacesEncounterMusic,
	)
	return i, err
}

const createCue = `-- name: CreateCue :one
INSERT INTO cues (data_hash, scene_description, area_id, replaces_bg_music, end_trigger, replaces_encounter_music)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = cues.data_hash
RETURNING id, data_hash, scene_description, area_id, replaces_bg_music, end_trigger, replaces_encounter_music
`

type CreateCueParams struct {
	DataHash               string
	SceneDescription       string
	AreaID                 sql.NullInt32
	ReplacesBgMusic        NullBgReplacementType
	EndTrigger             sql.NullString
	ReplacesEncounterMusic bool
}

func (q *Queries) CreateCue(ctx context.Context, arg CreateCueParams) (Cue, error) {
	row := q.db.QueryRowContext(ctx, createCue,
		arg.DataHash,
		arg.SceneDescription,
		arg.AreaID,
		arg.ReplacesBgMusic,
		arg.EndTrigger,
		arg.ReplacesEncounterMusic,
	)
	var i Cue
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.SceneDescription,
		&i.AreaID,
		&i.ReplacesBgMusic,
		&i.EndTrigger,
		&i.ReplacesEncounterMusic,
	)
	return i, err
}

const createFMV = `-- name: CreateFMV :exec
INSERT INTO fmvs (data_hash, name, translation, cutscene_description, song_id, area_id)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateFMVParams struct {
	DataHash            string
	Name                string
	Translation         sql.NullString
	CutsceneDescription string
	SongID              sql.NullInt32
	AreaID              int32
}

func (q *Queries) CreateFMV(ctx context.Context, arg CreateFMVParams) error {
	_, err := q.db.ExecContext(ctx, createFMV,
		arg.DataHash,
		arg.Name,
		arg.Translation,
		arg.CutsceneDescription,
		arg.SongID,
		arg.AreaID,
	)
	return err
}

const createSong = `-- name: CreateSong :one
INSERT INTO songs (data_hash, name, streaming_name, in_game_name, ost_name, translation, streaming_track_number, music_sphere_id, ost_disc, ost_track_number, duration_in_seconds, can_loop, special_use_case)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = songs.data_hash
RETURNING id, data_hash, name, streaming_name, in_game_name, ost_name, translation, streaming_track_number, music_sphere_id, ost_disc, ost_track_number, duration_in_seconds, can_loop, special_use_case, credits_id
`

type CreateSongParams struct {
	DataHash             string
	Name                 string
	StreamingName        sql.NullString
	InGameName           sql.NullString
	OstName              sql.NullString
	Translation          sql.NullString
	StreamingTrackNumber sql.NullInt32
	MusicSphereID        sql.NullInt32
	OstDisc              interface{}
	OstTrackNumber       sql.NullInt32
	DurationInSeconds    int32
	CanLoop              bool
	SpecialUseCase       NullMusicUseCase
}

func (q *Queries) CreateSong(ctx context.Context, arg CreateSongParams) (Song, error) {
	row := q.db.QueryRowContext(ctx, createSong,
		arg.DataHash,
		arg.Name,
		arg.StreamingName,
		arg.InGameName,
		arg.OstName,
		arg.Translation,
		arg.StreamingTrackNumber,
		arg.MusicSphereID,
		arg.OstDisc,
		arg.OstTrackNumber,
		arg.DurationInSeconds,
		arg.CanLoop,
		arg.SpecialUseCase,
	)
	var i Song
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Name,
		&i.StreamingName,
		&i.InGameName,
		&i.OstName,
		&i.Translation,
		&i.StreamingTrackNumber,
		&i.MusicSphereID,
		&i.OstDisc,
		&i.OstTrackNumber,
		&i.DurationInSeconds,
		&i.CanLoop,
		&i.SpecialUseCase,
		&i.CreditsID,
	)
	return i, err
}

const createSongCredit = `-- name: CreateSongCredit :one
INSERT INTO song_credits (data_hash, composer, arranger, performer, lyricist)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = song_credits.data_hash
RETURNING id, data_hash, composer, arranger, performer, lyricist
`

type CreateSongCreditParams struct {
	DataHash  string
	Composer  sql.NullString
	Arranger  sql.NullString
	Performer sql.NullString
	Lyricist  sql.NullString
}

func (q *Queries) CreateSongCredit(ctx context.Context, arg CreateSongCreditParams) (SongCredit, error) {
	row := q.db.QueryRowContext(ctx, createSongCredit,
		arg.DataHash,
		arg.Composer,
		arg.Arranger,
		arg.Performer,
		arg.Lyricist,
	)
	var i SongCredit
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Composer,
		&i.Arranger,
		&i.Performer,
		&i.Lyricist,
	)
	return i, err
}

const createSongsBackgroundMusicJunction = `-- name: CreateSongsBackgroundMusicJunction :exec
INSERT INTO j_songs_background_music (data_hash, song_id, bm_id, area_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateSongsBackgroundMusicJunctionParams struct {
	DataHash string
	SongID   int32
	BmID     int32
	AreaID   int32
}

func (q *Queries) CreateSongsBackgroundMusicJunction(ctx context.Context, arg CreateSongsBackgroundMusicJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createSongsBackgroundMusicJunction,
		arg.DataHash,
		arg.SongID,
		arg.BmID,
		arg.AreaID,
	)
	return err
}

const createSongsCuesJunction = `-- name: CreateSongsCuesJunction :exec
INSERT INTO j_songs_cues (data_hash, song_id, cue_id, area_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateSongsCuesJunctionParams struct {
	DataHash string
	SongID   int32
	CueID    int32
	AreaID   int32
}

func (q *Queries) CreateSongsCuesJunction(ctx context.Context, arg CreateSongsCuesJunctionParams) error {
	_, err := q.db.ExecContext(ctx, createSongsCuesJunction,
		arg.DataHash,
		arg.SongID,
		arg.CueID,
		arg.AreaID,
	)
	return err
}

const updateSong = `-- name: UpdateSong :exec
UPDATE songs
SET data_hash = $1,
    credits_id = $2
WHERE id = $3
`

type UpdateSongParams struct {
	DataHash  string
	CreditsID sql.NullInt32
	ID        int32
}

func (q *Queries) UpdateSong(ctx context.Context, arg UpdateSongParams) error {
	_, err := q.db.ExecContext(ctx, updateSong, arg.DataHash, arg.CreditsID, arg.ID)
	return err
}

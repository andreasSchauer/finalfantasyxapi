// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: media.sql

package database

import (
	"context"
	"database/sql"
)

const createFMV = `-- name: CreateFMV :exec
INSERT INTO fmvs (data_hash, name, translation, cutscene_description, song_id, area_id)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT(data_hash) DO NOTHING
`

type CreateFMVParams struct {
	DataHash            string
	Name                string
	Translation         sql.NullString
	CutsceneDescription string
	SongID              sql.NullInt32
	AreaID              int32
}

func (q *Queries) CreateFMV(ctx context.Context, arg CreateFMVParams) error {
	_, err := q.db.ExecContext(ctx, createFMV,
		arg.DataHash,
		arg.Name,
		arg.Translation,
		arg.CutsceneDescription,
		arg.SongID,
		arg.AreaID,
	)
	return err
}

const createSong = `-- name: CreateSong :one
INSERT INTO songs (data_hash, name, streaming_name, in_game_name, ost_name, translation, streaming_track_number, music_sphere_id, ost_disc, ost_track_number, duration_in_seconds, can_loop, special_use_case, credits_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = songs.data_hash
RETURNING id, data_hash, name, streaming_name, in_game_name, ost_name, translation, streaming_track_number, music_sphere_id, ost_disc, ost_track_number, duration_in_seconds, can_loop, special_use_case, credits_id
`

type CreateSongParams struct {
	DataHash             string
	Name                 string
	StreamingName        sql.NullString
	InGameName           sql.NullString
	OstName              sql.NullString
	Translation          sql.NullString
	StreamingTrackNumber sql.NullInt32
	MusicSphereID        sql.NullInt32
	OstDisc              interface{}
	OstTrackNumber       sql.NullInt32
	DurationInSeconds    int32
	CanLoop              bool
	SpecialUseCase       NullMusicUseCase
	CreditsID            sql.NullInt32
}

func (q *Queries) CreateSong(ctx context.Context, arg CreateSongParams) (Song, error) {
	row := q.db.QueryRowContext(ctx, createSong,
		arg.DataHash,
		arg.Name,
		arg.StreamingName,
		arg.InGameName,
		arg.OstName,
		arg.Translation,
		arg.StreamingTrackNumber,
		arg.MusicSphereID,
		arg.OstDisc,
		arg.OstTrackNumber,
		arg.DurationInSeconds,
		arg.CanLoop,
		arg.SpecialUseCase,
		arg.CreditsID,
	)
	var i Song
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Name,
		&i.StreamingName,
		&i.InGameName,
		&i.OstName,
		&i.Translation,
		&i.StreamingTrackNumber,
		&i.MusicSphereID,
		&i.OstDisc,
		&i.OstTrackNumber,
		&i.DurationInSeconds,
		&i.CanLoop,
		&i.SpecialUseCase,
		&i.CreditsID,
	)
	return i, err
}

const createSongCredit = `-- name: CreateSongCredit :one
INSERT INTO song_credits (data_hash, composer, arranger, performer, lyricist)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(data_hash) DO UPDATE SET data_hash = song_credits.data_hash
RETURNING id, data_hash, composer, arranger, performer, lyricist
`

type CreateSongCreditParams struct {
	DataHash  string
	Composer  sql.NullString
	Arranger  sql.NullString
	Performer sql.NullString
	Lyricist  sql.NullString
}

func (q *Queries) CreateSongCredit(ctx context.Context, arg CreateSongCreditParams) (SongCredit, error) {
	row := q.db.QueryRowContext(ctx, createSongCredit,
		arg.DataHash,
		arg.Composer,
		arg.Arranger,
		arg.Performer,
		arg.Lyricist,
	)
	var i SongCredit
	err := row.Scan(
		&i.ID,
		&i.DataHash,
		&i.Composer,
		&i.Arranger,
		&i.Performer,
		&i.Lyricist,
	)
	return i, err
}
